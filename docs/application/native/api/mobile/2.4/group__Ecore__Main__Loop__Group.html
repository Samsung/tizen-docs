<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore main loop</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Ecore__Main__Loop__Group.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<div class="title">Ecore main loop</div>  </div>
<div class="ingroups"><a class="el" href="group__Ecore.html">Ecore</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga0b23ea5d7f31f45e2c2f37d4393ddb2e">ecore_main_loop_iterate</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a single iteration of the main loop to process everything on the queue.  <a href="#ga0b23ea5d7f31f45e2c2f37d4393ddb2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede">ecore_main_loop_select_func_set</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a> func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of the file descriptors before ready for some class of I/O operation.  <a href="#gab140536aa1a0f69136f50cc927b8cede"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga5e959406d2cc4aac55e040d47e42f5bd">ecore_main_loop_select_func_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the select function set by ecore_select_func_set(), or the native select function if none was set.  <a href="#ga5e959406d2cc4aac55e040d47e42f5bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga111f77f35bf6f6065357dd0033d75e5c">ecore_main_loop_glib_integrate</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request ecore to integrate GLib's main loop.  <a href="#ga111f77f35bf6f6065357dd0033d75e5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga41c7d11043af50636ec75082c9d745c8">ecore_main_loop_glib_always_integrate_disable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable always integrating glib.  <a href="#ga41c7d11043af50636ec75082c9d745c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the application main loop.  <a href="#gaf103b9f668bb3e4fed12e52c6180132d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Quits the main loop once all the events currently on the queue have been processed.  <a href="#ga95cf8e97dff0716433c2c5474d606a98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gad4c3bd5fb81af093ce3d64f6f8331043">ecore_fork_reset_callback_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function to be called by <a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808" title="Reset the ecore internal state after a fork.">ecore_fork_reset()</a>  <a href="#gad4c3bd5fb81af093ce3d64f6f8331043"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga10a1b477404946b0de4d01e32f84fec5">ecore_fork_reset_callback_del</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This removes the callback specified.  <a href="#ga10a1b477404946b0de4d01e32f84fec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808">ecore_fork_reset</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the ecore internal state after a fork.  <a href="#gaadff0a56ba8818d8a35f9dc95e25a808"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga12c98ccc13eb136ed62f8177d12a8fc0">ecore_main_loop_thread_safe_call_async</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a> callback, void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call callback asynchronously in the main loop.  <a href="#ga12c98ccc13eb136ed62f8177d12a8fc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga0df1b736c7f358c1df054c126d8dbc00">ecore_main_loop_thread_safe_call_sync</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#gac4edb7065bb785df0d1a90041380ea76">Ecore_Data_Cb</a> callback, void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call callback synchronously in the main loop.  <a href="#ga0df1b736c7f358c1df054c126d8dbc00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6">ecore_thread_main_loop_begin</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function suspend the main loop in a know state.  <a href="#ga0624ccd91c607ed241f45ac1da8875a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296">ecore_thread_main_loop_end</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the main loop.  <a href="#gabd2ff96845800d5fcb7cd2607fffa296"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> )(void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a> )(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a> )(void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gac4edb7065bb785df0d1a90041380ea76">Ecore_Data_Cb</a> )(void *data)</td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gae0c653baad8836232c0dc27f91f875d6">ECORE_CALLBACK_CANCEL</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga6a2922b8aa10c60f27c8ab49d84d75f2">ECORE_CALLBACK_PASS_ON</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga780091d7d49a4bb6cb753f12e1a3b19d">ECORE_CALLBACK_DONE</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2> </h2>
<p>This group discusses functions that are acting on Ecore's main loop itself or on events and infrastructure directly linked to it. Most programs only need to start and end the main loop, the rest of the function discussed here are meant to be used in special situations, and with great care.</p>
<p>For details on the usage of ecore's main loop and how it interacts with other ecore facilities see: <a class="el" href="Ecore_Main_Loop_Page.html">The Ecore Main Loop</a>. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gae0c653baad8836232c0dc27f91f875d6"></a><!-- doxytag: member="Ecore_Common.h::ECORE_CALLBACK_CANCEL" ref="gae0c653baad8836232c0dc27f91f875d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Ecore__Main__Loop__Group.html#gae0c653baad8836232c0dc27f91f875d6">ECORE_CALLBACK_CANCEL</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return value to remove a callback </p>

</div>
</div>
<a class="anchor" id="ga780091d7d49a4bb6cb753f12e1a3b19d"></a><!-- doxytag: member="Ecore_Common.h::ECORE_CALLBACK_DONE" ref="ga780091d7d49a4bb6cb753f12e1a3b19d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Ecore__Main__Loop__Group.html#ga780091d7d49a4bb6cb753f12e1a3b19d">ECORE_CALLBACK_DONE</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return value to stop event handling </p>

</div>
</div>
<a class="anchor" id="ga6a2922b8aa10c60f27c8ab49d84d75f2"></a><!-- doxytag: member="Ecore_Common.h::ECORE_CALLBACK_PASS_ON" ref="ga6a2922b8aa10c60f27c8ab49d84d75f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Ecore__Main__Loop__Group.html#ga6a2922b8aa10c60f27c8ab49d84d75f2">ECORE_CALLBACK_PASS_ON</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return value to pass event to next handler </p>

</div>
</div>
<a class="anchor" id="ga1ee9db07f9a46a8b20fb83e1c6dbed09"></a><!-- doxytag: member="Ecore_Common.h::ECORE_CALLBACK_RENEW" ref="ga1ee9db07f9a46a8b20fb83e1c6dbed09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return value to keep a callback </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga00aa98b68b33de046b49a0158956874f"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Cb" ref="ga00aa98b68b33de046b49a0158956874f" args=")(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A generic callback called as a hook when a certain point in execution is reached. </p>

</div>
</div>
<a class="anchor" id="gac4edb7065bb785df0d1a90041380ea76"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Data_Cb" ref="gac4edb7065bb785df0d1a90041380ea76" args=")(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Main__Loop__Group.html#gac4edb7065bb785df0d1a90041380ea76">Ecore_Data_Cb</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#gac4edb7065bb785df0d1a90041380ea76">Ecore_Data_Cb</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A callback which is used to return data to the main function </p>

</div>
</div>
<a class="anchor" id="gaaa812c3d1e70623817acce9dcd2e8b71"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Select_Function" ref="gaaa812c3d1e70623817acce9dcd2e8b71" args=")(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A function which can be used to replace select() in the main loop </p>

</div>
</div>
<a class="anchor" id="ga8a36ef1ac24bfa317a7826617264e530"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Task_Cb" ref="ga8a36ef1ac24bfa317a7826617264e530" args=")(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A callback run for a task (timer, idler, poller, animator, etc) </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaadff0a56ba8818d8a35f9dc95e25a808"></a><!-- doxytag: member="Ecore_Common.h::ecore_fork_reset" ref="gaadff0a56ba8818d8a35f9dc95e25a808" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808">ecore_fork_reset</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the ecore internal state after a fork. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Ecore maintains internal data that can be affected by the fork() system call which creates a duplicate of the current process. This also duplicates file descriptors which is problematic in that these file descriptors still point to their original sources. This function makes ecore reset internal state (e.g. pipes used for signalling between threads) so they function correctly afterwards.</dd>
<dd>
It is highly suggested that you call this function after any fork() system call inside the child process if you intend to use ecore features after this point and not call any exec() family functions. Not doing so will cause possible misbehaviour.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7 </dd></dl>

</div>
</div>
<a class="anchor" id="gad4c3bd5fb81af093ce3d64f6f8331043"></a><!-- doxytag: member="Ecore_Common.h::ecore_fork_reset_callback_add" ref="gad4c3bd5fb81af093ce3d64f6f8331043" args="(Ecore_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#gad4c3bd5fb81af093ce3d64f6f8331043">ecore_fork_reset_callback_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a function to be called by <a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808" title="Reset the ecore internal state after a fork.">ecore_fork_reset()</a> </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to pass to this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This queues <code>func</code> to be called (and passed <code>data</code> as its argument) when <a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808" title="Reset the ecore internal state after a fork.">ecore_fork_reset()</a> is called. This allows other libraries and subsystems to also reset their internal state after a fork.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EINA_TRUE on success, else EINA_FALSE. </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7 </dd></dl>

</div>
</div>
<a class="anchor" id="ga10a1b477404946b0de4d01e32f84fec5"></a><!-- doxytag: member="Ecore_Common.h::ecore_fork_reset_callback_del" ref="ga10a1b477404946b0de4d01e32f84fec5" args="(Ecore_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#ga10a1b477404946b0de4d01e32f84fec5">ecore_fork_reset_callback_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This removes the callback specified. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to delete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data passed to this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This deletes the callback added by <a class="el" href="group__Ecore__Main__Loop__Group.html#gad4c3bd5fb81af093ce3d64f6f8331043" title="Add a function to be called by ecore_fork_reset()">ecore_fork_reset_callback_add()</a> using the function and data pointer to specify which to remove.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EINA_TRUE on success, else EINA_FALSE. </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf103b9f668bb3e4fed12e52c6180132d"></a><!-- doxytag: member="Ecore_Common.h::ecore_main_loop_begin" ref="gaf103b9f668bb3e4fed12e52c6180132d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runs the application main loop. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function will not return until <a class="el" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a> is called. It will check for expired timers, idlers, file descriptors being watched by fd handlers, etc. Once everything is done, before entering again on idle state, any callback set as <code>Idle_Enterer</code> will be called.</dd>
<dd>
Each main loop iteration is done by calling <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0b23ea5d7f31f45e2c2f37d4393ddb2e" title="Runs a single iteration of the main loop to process everything on the queue.">ecore_main_loop_iterate()</a> internally.</dd>
<dd>
The polling (select) function used can be changed with <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a>.</dd>
<dd>
The function used to check for file descriptors, events, and that has a timeout for the timers can be changed using <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41c7d11043af50636ec75082c9d745c8"></a><!-- doxytag: member="Ecore_Common.h::ecore_main_loop_glib_always_integrate_disable" ref="ga41c7d11043af50636ec75082c9d745c8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#ga41c7d11043af50636ec75082c9d745c8">ecore_main_loop_glib_always_integrate_disable</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable always integrating glib. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If ecore is compiled with --with-glib=always (to always call <a class="el" href="group__Ecore__Main__Loop__Group.html#ga111f77f35bf6f6065357dd0033d75e5c" title="Request ecore to integrate GLib&#39;s main loop.">ecore_main_loop_glib_integrate()</a> when Ecore Init function is called), then calling this before calling ecore_init() will disable the integration. This is for apps that explicitly do not want this to happen for whatever reasons they may have. </dd></dl>

</div>
</div>
<a class="anchor" id="ga111f77f35bf6f6065357dd0033d75e5c"></a><!-- doxytag: member="Ecore_Common.h::ecore_main_loop_glib_integrate" ref="ga111f77f35bf6f6065357dd0033d75e5c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#ga111f77f35bf6f6065357dd0033d75e5c">ecore_main_loop_glib_integrate</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request ecore to integrate GLib's main loop. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This will add a small overhead during every main loop interaction by checking glib's default main context (used by its main loop). If it have events to be checked (timers, file descriptors or idlers), then these will be polled alongside with Ecore's own events, then dispatched before Ecore's. This is done by calling <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a>.</dd>
<dd>
This will cooperate with previously set <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a> by calling the old function. Similarly, if you want to override <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a> after main loop is integrated, call the new select function set by this call (get it by calling <a class="el" href="group__Ecore__Main__Loop__Group.html#ga5e959406d2cc4aac55e040d47e42f5bd" title="Gets the select function set by ecore_select_func_set(), or the native select function if none was se...">ecore_main_loop_select_func_get()</a> right after <a class="el" href="group__Ecore__Main__Loop__Group.html#ga111f77f35bf6f6065357dd0033d75e5c" title="Request ecore to integrate GLib&#39;s main loop.">ecore_main_loop_glib_integrate()</a>).</dd>
<dd>
This is useful to use GMainLoop libraries, like GTK, GUPnP, LibSoup, GConf and more. Adobe Flash plugin and other plugins systems depend on this as well.</dd>
<dd>
Once initialized/integrated, it will be valid until Ecore is completely shut down.</dd>
<dd>
Example of use: <div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
 {
    ecore_init();
    <a class="code" href="group__Ecore__Main__Loop__Group.html#ga111f77f35bf6f6065357dd0033d75e5c" title="Request ecore to integrate GLib&#39;s main loop.">ecore_main_loop_glib_integrate</a>();

    <span class="comment">// some code here</span>

    <a class="code" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d" title="Runs the application main loop.">ecore_main_loop_begin</a>();

    ecore_shutdown();

    <span class="keywordflow">return</span> 0;
 }
</pre></div></dd>
<dd>
This is only available if Ecore was compiled with GLib support. </dd>
<dd>
You don't need to call this function if Ecore was compiled with --with-glib=always.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> on success of <code>EINA_FALSE</code> if it failed, likely no GLib support in Ecore. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b23ea5d7f31f45e2c2f37d4393ddb2e"></a><!-- doxytag: member="Ecore_Common.h::ecore_main_loop_iterate" ref="ga0b23ea5d7f31f45e2c2f37d4393ddb2e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0b23ea5d7f31f45e2c2f37d4393ddb2e">ecore_main_loop_iterate</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runs a single iteration of the main loop to process everything on the queue. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>It does everything that is already done inside an <code>Ecore</code> main loop, like checking for expired timers, idlers, etc. But it will do it only once and return, instead of keep watching for new events.</dd>
<dd>
DO NOT use this function unless you are the person God comes to ask for advice when He has trouble managing the Universe. </dd></dl>

</div>
</div>
<a class="anchor" id="ga95cf8e97dff0716433c2c5474d606a98"></a><!-- doxytag: member="Ecore_Common.h::ecore_main_loop_quit" ref="ga95cf8e97dff0716433c2c5474d606a98" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Quits the main loop once all the events currently on the queue have been processed. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function returns immediately, but will mark the <a class="el" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d" title="Runs the application main loop.">ecore_main_loop_begin()</a> function to return at the end of the current main loop iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e959406d2cc4aac55e040d47e42f5bd"></a><!-- doxytag: member="Ecore_Common.h::ecore_main_loop_select_func_get" ref="ga5e959406d2cc4aac55e040d47e42f5bd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#ga5e959406d2cc4aac55e040d47e42f5bd">ecore_main_loop_select_func_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the select function set by ecore_select_func_set(), or the native select function if none was set. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gab140536aa1a0f69136f50cc927b8cede"></a><!-- doxytag: member="Ecore_Common.h::ecore_main_loop_select_func_set" ref="gab140536aa1a0f69136f50cc927b8cede" args="(Ecore_Select_Function func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede">ecore_main_loop_select_func_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of the file descriptors before ready for some class of I/O operation. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function will be used instead of the system call select and could possible be used to integrate the Ecore event loop with an external event loop.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>you don't know how to use, don't even try to use it.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12c98ccc13eb136ed62f8177d12a8fc0"></a><!-- doxytag: member="Ecore_Common.h::ecore_main_loop_thread_safe_call_async" ref="ga12c98ccc13eb136ed62f8177d12a8fc0" args="(Ecore_Cb callback, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#ga12c98ccc13eb136ed62f8177d12a8fc0">ecore_main_loop_thread_safe_call_async</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call callback asynchronously in the main loop. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1.0</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to call in the main loop </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to give to that call back</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>For all calls that need to happen in the main loop (most EFL functions do), this helper function provides the infrastructure needed to do it safely by avoiding dead lock, race condition and properly wake up the main loop.</dd>
<dd>
Remember after that function call, you should never touch again the <code>data</code> in the thread, it is owned by the main loop and your callback should take care of freeing it if necessary. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0df1b736c7f358c1df054c126d8dbc00"></a><!-- doxytag: member="Ecore_Common.h::ecore_main_loop_thread_safe_call_sync" ref="ga0df1b736c7f358c1df054c126d8dbc00" args="(Ecore_Data_Cb callback, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0df1b736c7f358c1df054c126d8dbc00">ecore_main_loop_thread_safe_call_sync</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#gac4edb7065bb785df0d1a90041380ea76">Ecore_Data_Cb</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call callback synchronously in the main loop. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1.0</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>The callback to call in the main loop </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to give to that call back </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value returned by the callback in the main loop</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>For all calls that need to happen in the main loop (most EFL functions do), this helper function provides the infrastructure needed to do it safely by avoiding dead lock, race condition and properly wake up the main loop.</dd>
<dd>
Remember this function will block until the callback is executed in the main loop. It can take time and you have no guaranty about the timeline. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0624ccd91c607ed241f45ac1da8875a6"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_main_loop_begin" ref="ga0624ccd91c607ed241f45ac1da8875a6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6">ecore_thread_main_loop_begin</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function suspend the main loop in a know state. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1.0</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of time <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6" title="This function suspend the main loop in a know state.">ecore_thread_main_loop_begin()</a> has been called in this thread, if the main loop was suspended correctly. If not, it return <code>-1</code>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function suspend the main loop in a know state, this let you use any EFL call you want after it return. Be carefully, the main loop is blocked until you call <a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296" title="Unlock the main loop.">ecore_thread_main_loop_end()</a>. This is the only sane way to achieve pseudo thread safety.</dd>
<dd>
Notice that until the main loop is blocked, the thread is blocked and their is noway around that.</dd>
<dd>
We still advise you, when possible, to use <a class="el" href="group__Ecore__Main__Loop__Group.html#ga12c98ccc13eb136ed62f8177d12a8fc0" title="Call callback asynchronously in the main loop.">ecore_main_loop_thread_safe_call_async()</a> as it will not block the thread nor the main loop. </dd></dl>

</div>
</div>
<a class="anchor" id="gabd2ff96845800d5fcb7cd2607fffa296"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_main_loop_end" ref="gabd2ff96845800d5fcb7cd2607fffa296" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296">ecore_thread_main_loop_end</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the main loop. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1.0</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of time <a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296" title="Unlock the main loop.">ecore_thread_main_loop_end()</a> need to be called before the main loop is unlocked again. <code>-1</code> will be returned if you are trying to unlock when there wasn't enough call to <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6" title="This function suspend the main loop in a know state.">ecore_thread_main_loop_begin()</a>.</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>After a call to <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6" title="This function suspend the main loop in a know state.">ecore_thread_main_loop_begin()</a>, you need to absolutely call <a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296" title="Unlock the main loop.">ecore_thread_main_loop_end()</a>, or you application will stay frozen. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
