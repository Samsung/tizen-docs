<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore_Thread - API overview</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Ecore_Thread - API overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Working with threads is hard. Ecore helps to do so a bit easier, but as the example in <a class="el" href="ecore_thread_example_8c-example.html">ecore_thread_example.c</a> shows, there's a lot to consider even when doing the most simple things.</p>
<p>We'll be going through this thorough example now, showing how the differents aspects of <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> are used, but users are encourage to avoid threads unless it's really the only option, as they always add more complexity than the program usually requires.</p>
<p>Ecore Threads come in two flavors, short jobs and feedback jobs. Short jobs just run the given function and are more commonly used for small tasks where the main loop does not need to know how the work is going in between. The short job in our example is so short we had to artificially enlarge it with <code>sleep()</code>. Other than that, it also uses threads local data to keep the data we are working with persistent across different jobs ran by the same system thread. This data will be freed when the no more jobs are pending and the thread is terminated. If the data doesn't exist in the thread's storage, we create it and save it there for future jobs to find it. If creation fails, we cancel ourselves, so the main loop knows that we didn't just exit normally, meaning the job could not be done. The main part of the function checks in each iteration if it was canceled by the main loop, and if it was, it stops processing and clears the data from the storage (we assume <code>cancel</code> means no one else will need this, but this is really application dependent).  <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Feedback jobs, on the other hand, run tasks that will inform back to the main loop its progress, send partial data as is processed, just ping saying it's still alive and processing, or anything that needs the thread to talk back to the main loop. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Finally, one more feedback job, but this one will be running outside of Ecore's pool, so we can use the pool for real work and keep this very light function unchecked. All it does is check if some condition is met and send a message to the main loop telling it it's time to close. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Every now and then the program prints its status, counting threads running and pending jobs. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>In our main loop, we'll be receiving messages from our feedback jobs using the same callback for both of them. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>The light job running out of the pool will let us know when we can exit our program. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Next comes the handling of data sent from the actual worker threads, always remembering that the data belongs to us now, and not the thread, so it's our responsibility to free it. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Last, the condition to exit is given by how many messages we want to handle, so we need to count them and inform the condition checking thread that the value changed. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>When a thread finishes its job or gets canceled, the main loop is notified through the callbacks set when creating the task. In this case, we just print what happen and keep track of one of them used to exemplify canceling. Here we are pretending one of our short jobs has a timeout, so if it doesn't finish before a timer is triggered, it will be canceled. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>The main function does some setup that includes reading parameters from the command line to change its behaviour and test different results. These are: </p>
<ul>
<li>-t &lt;some_num&gt; maximum number of threads to run at the same time. </li>
<li>-p &lt;some_path&gt; adds <code>some_path</code> to the list used by the feedback jobs. This parameter can be used multiple times. </li>
<li>-m &lt;some_num&gt; the number of messages to process before the program is signalled to exit.</li>
</ul>
<p>Skipping some bits, we init Ecore and our application data. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>If any paths for the feedback jobs were given, we use them, otherwise we fallback to some defaults. Always initializing the proper mutexes used by the threaded job. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Initialize the mutex needed for the condition checking thread <div class="fragment"><pre class="fragment"></pre></div></p>
<p>And start our tasks. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>To finalize, set a timer to cancel one of the tasks if it doesn't end before the timeout, one more timer for status report and get into the main loop. Once we are out, destroy our mutexes and finish the program. <div class="fragment"><pre class="fragment"></pre></div> </p>
</div></div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
