<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore_Con - Creating a server</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Ecore_Con - Creating a server </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This feature is not supported on Tizen.</p>
<p>In this example we are going to create a server that listens for connections from clients through a TCP port. You can get the full source code at <a class="el" href="ecore_con_server_simple_example_8c-example.html">ecore_con_server_simple_example::c</a>.</p>
<p>We begin our example in the main function, to demonstrate how to setup things, and then go to the callbacks that are needed for it to run properly.</p>
<p>In the <code>main</code> function, after initializing the libraries, we use Server Add Function() to startup the server. Look at the reference documentation of this function: it supports many types of server, and we are going to use #ECORE_CON_REMOTE_TCP (a TCP based server). Other arguments to this function are the address where we are listening on, the port, and a data pointer that will associate that data with the server:</p>
 <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Notice that we are listening only on 127.0.0.1, which is the internal loopback interface. If the server needs to listening on all of its ips, use 0.0.0.0 instead.</p>
<p>We also need to set event handlers to be called when we receive any data from the clients, when a new client connects to our server, or when a client disconnects. These callbacks are:</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>More details about what these callbacks do will be given later.</p>
<p>Now, before running the main loop, we also want to set some limits to our server. To avoid it to be overloaded with too many connections to handle, we are going to set a maximum of 3 clients connected at the same time. This number is used just to demonstrate the API. A good number to be used here would need to be determined by tests done on the server, to check the load supported by it.</p>
<p>Any other client trying to connect to this server, after the limit is reached, will wait until one of the connected clients disconnect and the server accepts the new connection.</p>
<p>Another important thing to do is setting a timeout, to avoid that a client hold a connection for too long without doing anything. This timeout will disconnect the idle client, allowing that other clients that may be waiting to connect finally can do it.</p>
<p>Then we just start the main loop:</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>After exiting the main loop, we print the list of connected clients, and also free the data associated with each respective client.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Then before exiting we show the total uptime of the server:</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now let's go back to the used callbacks.</p>
<p>The first callback, <code>_add</code>, is registered to the corresponding event , which will be called whenever a client connects to the server.</p>
<p>This callback will associate a data structure to this client, that will be used to count how many bytes were received from it. It also prints some info about the client, and send a welcome string to it. flush function is used to ensure that the string is sent immediately, instead of being buffered.</p>
<p>A timeout for idle specific for this client is also set, to demonstrate that it is independent of the general timeout of the server.</p>
<p>Before exiting, the callback will display a list of all clients still connected to this server. The code for this callback follows:</p>
 <div class="fragment"><pre class="fragment"></pre></div></p>
<p>The second callback is <code>_del</code>. It is associated with the corresponding event, and is called whenever a client disconnects from this server.</p>
<p>It will just print some information about the client, free the associated data structure, and call delete function on it before exiting the callback. Here's its code:</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The last callback will print any data received by this server from its clients. It also increments the "bytes received" counter, sdata, in the data structure associated with this client. The callback code follows:</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The important parts of this example were described above. If you need to see the full source code for it, there's a link to the code in the beginning of this page.</p>
<p>This example will start a server and start accepting connections from clients, as demonstrated in the following diagram:  
 <img src="ecore_con-client-server-example.png" style="max-width: 400px"/>
 <a href="ecore_con-client-server-example.png">Full size</a>
  <dl class="note"><dt><b>Note:</b></dt><dd>This example contains a serious security flaw: it doesn't check for the size of data being received, thus allowing to the string to be exploited in some way. However, it is left like this to make the code simpler and just demonstrate the API usage. </dd></dl>
</div></div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
