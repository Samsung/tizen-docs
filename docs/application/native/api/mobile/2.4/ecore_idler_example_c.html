<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: ecore idle state - Idlers, enterers and exiters</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ecore idle state - Idlers, enterers and exiters </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This example demonstrates how to manage the idle state of the main loop. Once a program knows that the main loop is going to enter in idle state, it could start doing some processing until getting out of this state.</p>
<p>To exemplify this, we also add events and a timer to this program, so we can see the idle exiter callback being called before processing the event and/or timer, the event/timer callback being called (processed), then the idle enterer being called before entering in idle state again. Once in idle, the main loop keeps calling the idler callback continuously until a new event or timer is received.</p>
<p>First, we declare a struct that will be used as context to be passed to every callback. It's not useful everywhere, since this example is very simple and doesn't do anything other than printing messages, but using this context will make it a little bit more real. Our context will be used to delete the timer, idler, idle enterer and exiter, and the event handler, and also to count how many times the idler was called.</p>
<p>Then we start declaring callbacks for the idle enterer, idle exiter and the idler itself. Idle enterer and exiter callbacks just print a message saying that they were called, while the idler, in addition to printing a message too, also sends an event every 10 times that it is called, incrementing the context count variable. This event will be used to make the main loop exit the idle state and call the event callback.</p>
<p>These callbacks return <a class="el" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>, since we want them to keep being called every time the main loop changes to/from idle state. Otherwise, if we didn't want them to be called again, they should return <a class="el" href="group__Ecore__Main__Loop__Group.html#gae0c653baad8836232c0dc27f91f875d6">ECORE_CALLBACK_CANCEL</a>.</p>
<p>The next function declared is the event callback <code>_event_handler_cb</code>. It will check if the idler was called more than 100 times already <code></code>(ctxt-&gt;count &gt; 100), and will delete the idler, idle enterer and exiter, the timer (if it still exists), and request that the main loop stop running. Then it returns <a class="el" href="group__Ecore__Main__Loop__Group.html#ga780091d7d49a4bb6cb753f12e1a3b19d">ECORE_CALLBACK_DONE</a> to indicate that the event shouldn't be handled by any other callback.</p>
<p>Finally, we add a callback to the timer, that will just print a message when it is called, and this will happen only once (<a class="el" href="group__Ecore__Main__Loop__Group.html#gae0c653baad8836232c0dc27f91f875d6">ECORE_CALLBACK_CANCEL</a> is being returned). This timer callback is just here to show that the main loop gets out of idle state when processing timers too.</p>
<p>The <b>main</b> function is simple, just creates a new type of event that we will use to demonstrate the event handling together with the idle state, adds the callbacks that we declared so far, fill the context struct, and starts running the main loop.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>We use timer and event callbacks to demonstrate the idle state changing, but it also happens for file descriptor handlers, pipe handlers, etc.</dd></dl>
<div class="fragment"><pre class="fragment"></pre></div> </div></div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
