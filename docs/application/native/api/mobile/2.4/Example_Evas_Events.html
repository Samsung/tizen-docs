<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Evas events (canvas and object ones) and some canvas operations example</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Evas events (canvas and object ones) and some canvas operations example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example we illustrate how to interact with canvas' (and its objects') events, including the key input ones. We also demonstrate precise point collision on objects and canvas "obscured regions", here.</p>
<p>The example application consists of a window with a white background and an image -- the Enlightenment logo. The application begins with this image switching back and forth into two sizes: the exact canvas' size and one quarter of it (when it's placed on the top left quadrant). Thus, we'll have an <b>animation</b> going on, with image states set to change each 2 elapsed seconds.</p>
<p>There's a global variable to aid accessing our desired context variables from anywhere in the code:  <div class="fragment"><pre class="fragment"></pre></div></p>
<p>What interests us there are the <code>canvas</code> pointer, our image handle -- <code>img</code> -- and the background one, <code>bg</code>.</p>
<p>The first interesting thing on the example is the registration of a callback on each canvas resizing event, where we put our canvas' size and the background rectangle's one in synchrony, so that we don't get bogus content on rendering with canvas resizes:  <div class="fragment"><pre class="fragment"></pre></div>  <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Than, after grabbing our canvas pointer from the Ecore Evas helper infrastructure, we registrate an event callbacks on it: <div class="fragment"><pre class="fragment"></pre></div>  <div class="fragment"><pre class="fragment"></pre></div> It will be called whenever our canvas has to flush its rendering pipeline. In this example, two ways of observing that message which is printed in the cited callback are:</p>
<ul>
<li>to resize the example's window (thus resizing the canvas' viewport)</li>
<li>let the animation run</li>
</ul>
<p>When one resizes the canvas, there's at least one operation it has to do which will require new calculation for rendering: the resizing of the background rectangle, in a callback we already shown you.</p>
<p>The creation of our background rectangle is so that we give it a <b>name</b>, via <a class="el" href="group__Evas__Object__Group__Basic.html#ga88bfcce07ad3bcef31687e29075ae2d2" title="Sets the name of the given Evas object to the given name.">evas_object_name_set()</a> and we give it the canvas <b>focus:</b>  <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Still exemplifying events and callbacks, we register a callback on the canvas event of an object being focused:  <div class="fragment"><pre class="fragment"></pre></div>  <div class="fragment"><pre class="fragment"></pre></div></p>
<p>In that call, <code>event_info</code> is going to be the focused object's handle, in this case our background rectangle. We print its name, so you can check it's the same. We check that pointer is the same reported by Evas' API with regard to the newest focused object. Finally, we check whether that object is really flagged as focused, now using an Evas object API function.</p>
<p>The animation we talked about comes from a timer we register just before we start the example's main loop. As we said, the resizing of the image will also force the canvas to repaint itself, thus flushing the rendering pipeline whenever the timer ticks:  <div class="fragment"><pre class="fragment"></pre></div>  <div class="fragment"><pre class="fragment"></pre></div> When you start this example, this animation will be running, by default. To interact with the program, there's a command line interface. A help string can be asked for with the 'h' key:  <div class="fragment"><pre class="fragment"></pre></div> These are the commands the example will accept at any time, except when one triggers the 'f' one. This command will exemplify <a class="el" href="group__Evas__Event__Freezing__Group.html#ga4f6046343eab8b062e5509d984100ec8" title="Freeze all input events processing.">evas_event_freeze()</a>, which interrupts <b>all</b> input events processing for the canvas (in the example, just for 3 seconds). Try to issue events for it during that freeze time:  <div class="fragment"><pre class="fragment"></pre></div> The 'd' command will unregister those two canvas callbacks for you, so you won't see the messages about the focused object and the rendering process anymore:  <div class="fragment"><pre class="fragment"></pre></div> In this example, we start using a focused object to handle the input events -- the background rectangle. We register a callback on an key input event occurring on it, so that we can act on each key stroke: <div class="fragment"><pre class="fragment"></pre></div>  <div class="fragment"><pre class="fragment"></pre></div> We do so by examining the <code>ev-&gt;key</code> string (remember the event information struct for key down events is the <a class="el" href="group__Evas.html#ga9a1bfd297b751119977f3c14c0004612">Evas_Event_Key_Down</a> one). There's one more trick for grabbing input events on this example -- <a class="el" href="group__Evas__Keys.html#ga85828f3c1f252391def19e179b850def" title="Requests keyname key events be directed to obj.">evas_object_key_grab()</a>. The 'c' command will, when firstly used, <b>unfocus</b> the background rectangle. Unfocused objects on an Evas canvas will <b>never</b> receive key events. We grab, then, the keys we're interested at to the object forcefully: <div class="fragment"><pre class="fragment"></pre></div> This shows how one can handle input not depending on focus issues -- you can grab them globally. Switch back and forth focus and forced key grabbing with the 'c' key, and observe the messages printed about the focused object. Observe, also, that we register two more <b>object</b> callbacks, this time on the image object (Enlightenment logo), where we just print messages telling the mouse pointer has entered or exited it area: <div class="fragment"><pre class="fragment"></pre></div>  <div class="fragment"><pre class="fragment"></pre></div> Experiment with moving the mouse pointer over the image, letting it enter and exit its area (stop the animation with 'a', for a better experience). When you start the example, Evas will consider this area by being the whole boundary rectangle around the picture. If you issue the 'p' command, though, you get a demonstration of Evas' precise point collision detection on objects. With <a class="el" href="group__Evas__Object__Group__Extras.html#ga4d2551c3265c013448f2b7cbb6bdf74d" title="Determine whether an object is set to use precise point collision detection.">evas_object_precise_is_inside_get()</a>, one can make Evas consider the transparent areas of an object (the middle of the logo's E letter, in the case) as not belonging to it when calculating mouse in/out/up/down events:  <div class="fragment"><pre class="fragment"></pre></div> To finish the example, try the command bound to Control + 'o', which exemplifies Evas' <b>obscured regions</b>. When firstly pressed, you'll get the same contents, in a region in the middle of the canvas, at the time the key was pressed, until you toggle the effect off again (make sure the animation is running on to get the idea better). When you toggle this effect off, we also demonstrate the use of <a class="el" href="group__Evas__Canvas.html#ga1867d9f5f97545418598496af93e4c71" title="Force immediate renderization of the given Evas canvas.">evas_render_updates()</a>, which will force immediate updates on the canvas rendering, bringing back the obscured region's contents to normal. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>What follows is the complete code for this example.</p>
<div class="fragment"><pre class="fragment"></pre></div> </div></div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
