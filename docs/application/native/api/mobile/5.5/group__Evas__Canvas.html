<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Canvas Functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.5</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Evas__Canvas.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Canvas Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__Evas.html">Evas</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>Low level Evas canvas functions. Sub groups will present more high level ones, though.</p>
<p>Most of these functions deal with low level Evas actions, like: </p>
<ul>
<li>create/destroy raw canvases, not bound to any displaying engine </li>
<li>tell a canvas i got focused (in a windowing context, for example) </li>
<li>tell a canvas a region should not be calculated anymore in rendering </li>
<li>tell a canvas to render its contents, immediately</li>
</ul>
<p>Most users will be using Evas by means of the <code>Ecore_Evas</code> wrapper, which deals with all the above mentioned issues automatically for them. Thus, you'll be looking at this section only if you're building low level stuff.</p>
<p>The groups within present you functions that deal with the canvas directly, too, and not yet with its <b>objects</b>. They are the functions you need to use at a minimum to get a working canvas.</p>
<p>Some of the functions in this group are exemplified <a class="el" href="Example_Evas_Events.html">here</a>. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga038d98c7c13a86b6ba4de51f8aba3595">evas_render_updates_free</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *updates)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__Evas__Keys.html#ga198d0b10861c1da456004688d3443e96">Evas_Modifier</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#gaad42bb4caa43c1cfef4096f6ac2b99ec">evas_key_modifier_get</a> (const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the list of modifier keys registered in the canvas <code>e</code>.  <a href="#gaad42bb4caa43c1cfef4096f6ac2b99ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Evas__Keys.html#ga111c7333a7d49e44698bd19dd5bc9059">Evas_Modifier_Mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga668f8e34ce152d130f37b6b903db3ee2">evas_key_modifier_mask_get</a> (const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *evas, const char *keyname)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bit mask from the <code>keyname</code> modifier key. Values returned from different calls to it may be ORed together, naturally.  <a href="#ga668f8e34ce152d130f37b6b903db3ee2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__Evas__Keys.html#ga791323b644ee831ead4c5d25552a0fd8">Evas_Lock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#gab896e54f904562f291dc6f3acb5c45bc">evas_key_lock_get</a> (const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the list of lock keys registered in the canvas <code>e</code>.  <a href="#gab896e54f904562f291dc6f3acb5c45bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga65ae9005097b7131b8c9d20f1c0e991a">evas_pointer_inside_get</a> (const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the mouse pointer is logically inside the canvas.  <a href="#ga65ae9005097b7131b8c9d20f1c0e991a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga4fd01f00dea7c4877d887d3c65816b60">evas_output_view_get</a> (const Evas_Out *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h) <a class="el" href="group__Eina__Types__Group.html#gad5b2116495471db12a34bab9a34edfaa">EINA_DEPRECATED</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the viewport region of the canvas that the output display.  <a href="#ga4fd01f00dea7c4877d887d3c65816b60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#gaa6903b6e66c61568175046288c51ea32">evas_output_framespace_set</a> (<a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output framespace size of the render engine of the given evas.  <a href="#gaa6903b6e66c61568175046288c51ea32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga4db30a34668013944c30131c7bf5ecb1">evas_output_framespace_get</a> (const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the render engine's output framespace coordinates in canvas units.  <a href="#ga4db30a34668013944c30131c7bf5ecb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga6dcd13997f7825f03807dc0ec38dd38e">evas_output_viewport_set</a> (<a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output viewport of the given evas in evas units.  <a href="#ga6dcd13997f7825f03807dc0ec38dd38e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga346bb724a254e8681c382b84886045b4">evas_output_viewport_get</a> (const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the render engine's output viewport coordinates in canvas units.  <a href="#ga346bb724a254e8681c382b84886045b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga15b85dc673baa6aa40f91f8bfcd3cbaa">evas_output_method_set</a> (<a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, int render_method)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output engine for the given evas.  <a href="#ga15b85dc673baa6aa40f91f8bfcd3cbaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga9448841c72f804fd1533b6dcceeabd1a">evas_output_method_get</a> (const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of the output engine used for the given evas.  <a href="#ga9448841c72f804fd1533b6dcceeabd1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#gaf6478cb249ed09fa0fe961085773fe1e">evas_output_size_set</a> (<a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, int w, int h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output size of the render engine of the given evas.  <a href="#gaf6478cb249ed09fa0fe961085773fe1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#gadd22b11c786b3b00448ef58550aa55c4">evas_output_size_get</a> (const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, int *w, int *h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the output size of the render engine of the given evas.  <a href="#gadd22b11c786b3b00448ef58550aa55c4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Eo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct _Evas_Public_Data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Canvas.html#ga247928fced30bd79d1b294371a44add9">Evas_Public_Data</a></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga5ff87cc4ce6bc43e3b640a6d37f73043"></a><!-- doxytag: member="Evas_Common.h::Evas" ref="ga5ff87cc4ce6bc43e3b640a6d37f73043" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An opaque handle to an Evas canvas.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Canvas.html#ga67e8eb17d2a676bfdfb8794fc5f72bc0">evas_new()</a> </dd>
<dd>
<a class="el" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga247928fced30bd79d1b294371a44add9"></a><!-- doxytag: member="Evas_Common.h::Evas_Public_Data" ref="ga247928fced30bd79d1b294371a44add9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Canvas.html#ga247928fced30bd79d1b294371a44add9">Evas_Public_Data</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public data for an Evas. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf396b44e1b97ec0d9dce49fcf9ad54b7"></a><!-- doxytag: member="Evas_Legacy.h::evas_engine_info_get" ref="gaf396b44e1b97ec0d9dce49fcf9ad54b7" args="(const Evas *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__Evas__Engine__Info.html">Evas_Engine_Info</a>* <a class="el" href="group__Evas__Canvas.html#gaf396b44e1b97ec0d9dce49fcf9ad54b7">evas_engine_info_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the current render engine info struct from the given evas. </p>
<p>The returned structure is publicly modifiable. The contents are valid until either <a class="el" href="group__Evas__Canvas.html#gae917a8b0d52df622498bbf55357c1af3">evas_engine_info_set</a> or evas_render are called.</p>
<p>This structure does not need to be freed by the caller.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the engine info to use. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-buffer-simple_8c-example.html#a10">evas-buffer-simple.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae917a8b0d52df622498bbf55357c1af3"></a><!-- doxytag: member="Evas_Legacy.h::evas_engine_info_set" ref="gae917a8b0d52df622498bbf55357c1af3" args="(Evas *obj, Evas_Engine_Info *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Canvas.html#gae917a8b0d52df622498bbf55357c1af3">evas_engine_info_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Evas__Engine__Info.html">Evas_Engine_Info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the engine settings for the given evas from the given <code>Evas_Engine_Info</code> structure. </p>
<p>To get the Evas_Engine_Info structure to use, call <a class="el" href="group__Evas__Canvas.html#gaf396b44e1b97ec0d9dce49fcf9ad54b7">evas_engine_info_get</a>. Do not try to obtain a pointer to an <code>Evas_Engine_Info</code> structure in any other way.</p>
<p>You will need to call this function at least once before you can create objects on an evas or render that evas. Some engines allow their settings to be changed more than once.</p>
<p>Once called, the <code>info</code> pointer should be considered invalid.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>The pointer to the engine info to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if no error occurred, <code>false</code> otherwise. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-buffer-simple_8c-example.html#a12">evas-buffer-simple.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gafbd2b20f61cb2daf90f474d4e75a5260"></a><!-- doxytag: member="Evas_Legacy.h::evas_font_hinting_can_hint" ref="gafbd2b20f61cb2daf90f474d4e75a5260" args="(const Evas *e, Evas_Font_Hinting_Flags hinting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Canvas.html#gafbd2b20f61cb2daf90f474d4e75a5260">evas_font_hinting_can_hint</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Font_Hinting_Flags&#160;</td>
          <td class="paramname"><em>hinting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if the font hinting is supported by the given evas. </p>
<p>One of #EVAS_FONT_HINTING_NONE, #EVAS_FONT_HINTING_AUTO, #EVAS_FONT_HINTING_BYTECODE.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hinting</td><td>The hinting to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if it is supported, <code>false</code> otherwise. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0d5d3f1a1e1ffa3b14b09bb374215b4"></a><!-- doxytag: member="Evas_Legacy.h::evas_free" ref="gaa0d5d3f1a1e1ffa3b14b09bb374215b4" args="(Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Frees the given evas and any objects created on it.</p>
<p>Any objects with 'free' callbacks will have those callbacks called in this function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The given evas. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-buffer-simple_8c-example.html#a11">evas-buffer-simple.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gab896e54f904562f291dc6f3acb5c45bc"></a><!-- doxytag: member="Evas_Legacy.h::evas_key_lock_get" ref="gab896e54f904562f291dc6f3acb5c45bc" args="(const Evas *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__Evas__Keys.html#ga791323b644ee831ead4c5d25552a0fd8">Evas_Lock</a>* <a class="el" href="group__Evas__Canvas.html#gab896e54f904562f291dc6f3acb5c45bc">evas_key_lock_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a handle to the list of lock keys registered in the canvas <code>e</code>. </p>
<p>Checks the state of a given lock key of a given seat, at the time of the call. If the lock is set, such as caps lock, this function returns <code>Eina_True</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The current locks set, as returned by <a class="el" href="group__Evas__Canvas.html#gab896e54f904562f291dc6f3acb5c45bc" title="Returns a handle to the list of lock keys registered in the canvas e.">evas_key_lock_get()</a>. </td></tr>
    <tr><td class="paramname">keyname</td><td>The name of the lock key to check status for. </td></tr>
    <tr><td class="paramname">seat</td><td>The seat to check if the lock is set. Use <code>NULL</code> for the default seat.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>Eina_True</code> if the <code>keyname</code> lock key is set, <code>Eina_False</code> otherwise.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Canvas.html#gab896e54f904562f291dc6f3acb5c45bc" title="Returns a handle to the list of lock keys registered in the canvas e.">evas_key_lock_get</a> </dd>
<dd>
evas_key_lock_add </dd>
<dd>
evas_key_lock_del </dd>
<dd>
evas_key_lock_on </dd>
<dd>
evas_key_lock_off </dd>
<dd>
<a class="el" href="group__Evas__Keys.html#ga08080dfe3ad50c85f4965b9063bfd7de">evas_key_lock_is_set</a> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>This is required to check for which locks are set at a given time with the <a class="el" href="group__Evas__Keys.html#ga08080dfe3ad50c85f4965b9063bfd7de">evas_key_lock_is_set</a> function.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An Evas_Lock handle to query Evas' keys subsystem with <a class="el" href="group__Evas__Keys.html#ga08080dfe3ad50c85f4965b9063bfd7de">evas_key_lock_is_set</a> or evas_seat_key_lock_is_set, or <code>null</code> on error. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gaad42bb4caa43c1cfef4096f6ac2b99ec"></a><!-- doxytag: member="Evas_Legacy.h::evas_key_modifier_get" ref="gaad42bb4caa43c1cfef4096f6ac2b99ec" args="(const Evas *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__Evas__Keys.html#ga198d0b10861c1da456004688d3443e96">Evas_Modifier</a>* <a class="el" href="group__Evas__Canvas.html#gaad42bb4caa43c1cfef4096f6ac2b99ec">evas_key_modifier_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a handle to the list of modifier keys registered in the canvas <code>e</code>. </p>
<p>This is required to check for which modifiers are set at a given time with the <a class="el" href="group__Evas__Keys.html#ga6cc24a5ea4b39b84c7a3e617de3db261">evas_key_modifier_is_set</a> function.</p>
<p>See also evas_key_modifier_add, evas_key_modifier_del, evas_key_modifier_on, evas_key_modifier_off, evas_seat_key_modifier_on, evas_seat_key_modifier_off.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An Evas_Modifier handle to query Evas' keys subsystem with <a class="el" href="group__Evas__Keys.html#ga6cc24a5ea4b39b84c7a3e617de3db261">evas_key_modifier_is_set</a> or evas_seat_key_modifier_is_set, or <code>null</code> on error. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="edje-box2_8c-example.html#a13">edje-box2.c</a>, <a class="el" href="evas-aspect-hints_8c-example.html#a3">evas-aspect-hints.c</a>, <a class="el" href="evas-box_8c-example.html#a13">evas-box.c</a>, <a class="el" href="evas-events_8c-example.html#a20">evas-events.c</a>, <a class="el" href="evas-hints_8c-example.html#a6">evas-hints.c</a>, and <a class="el" href="web_example_02_8c-example.html#a15">web_example_02.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga668f8e34ce152d130f37b6b903db3ee2"></a><!-- doxytag: member="Evas_Legacy.h::evas_key_modifier_mask_get" ref="ga668f8e34ce152d130f37b6b903db3ee2" args="(const Evas *evas, const char *keyname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Keys.html#ga111c7333a7d49e44698bd19dd5bc9059">Evas_Modifier_Mask</a> <a class="el" href="group__Evas__Canvas.html#ga668f8e34ce152d130f37b6b903db3ee2">evas_key_modifier_mask_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>evas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a bit mask from the <code>keyname</code> modifier key. Values returned from different calls to it may be ORed together, naturally. </p>
<p>This function is meant to be using in conjunction with <a class="el" href="group__Evas__Object__Group__Events.html#ga85828f3c1f252391def19e179b850def">evas_object_key_grab</a>/@ref evas_object_key_ungrab. Go check their documentation for more information.</p>
<p>See also evas_key_modifier_add, <a class="el" href="group__Evas__Canvas.html#gaad42bb4caa43c1cfef4096f6ac2b99ec">evas_key_modifier_get</a>, evas_key_modifier_on, evas_key_modifier_off, evas_seat_key_modifier_on, evas_seat_key_modifier_off, <a class="el" href="group__Evas__Keys.html#ga6cc24a5ea4b39b84c7a3e617de3db261">evas_key_modifier_is_set</a>, evas_seat_key_modifier_is_set..</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyname</td><td>The name of the modifier key to create the mask for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit mask or 0 if the <code>keyname</code> key wasn't registered as a modifier for canvas <code>e</code>. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-events_8c-example.html#a13">evas-events.c</a>, and <a class="el" href="web_example_02_8c-example.html#a33">web_example_02.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga67e8eb17d2a676bfdfb8794fc5f72bc0"></a><!-- doxytag: member="Evas_Legacy.h::evas_new" ref="ga67e8eb17d2a676bfdfb8794fc5f72bc0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a>* <a class="el" href="group__Evas__Canvas.html#ga67e8eb17d2a676bfdfb8794fc5f72bc0">evas_new</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new empty evas.</p>
<p>Note that before you can use the evas, you will to at a minimum: </p>
<ul>
<li>Set its render method with <a class="el" href="group__Evas__Canvas.html#ga15b85dc673baa6aa40f91f8bfcd3cbaa">evas_output_method_set</a> . </li>
<li>Set its viewport size with <a class="el" href="group__Evas__Canvas.html#ga6dcd13997f7825f03807dc0ec38dd38e">evas_output_viewport_set</a> . </li>
<li>Set its size of the canvas with <a class="el" href="group__Evas__Canvas.html#gaf6478cb249ed09fa0fe961085773fe1e">evas_output_size_set</a> . </li>
<li>Ensure that the render engine is given the correct settings with <a class="el" href="group__Evas__Canvas.html#gae917a8b0d52df622498bbf55357c1af3">evas_engine_info_set</a> .</li>
</ul>
<p>This function should only fail if the memory allocation fails</p>
<dl class="note"><dt><b>Note:</b></dt><dd>this function is very low level. Instead of using it directly, consider using the high level functions in <a class="el" href="group__Ecore__Evas__Group.html">Ecore_Evas wrapper/helper set of functions</a> such as <code><a class="el" href="group__Ecore__Evas__Group.html#gac3d6e2809d0c8811fc9958de24b68167" title="Creates a new Ecore_Evas based on engine name and common parameters.">ecore_evas_new()</a></code>. See <a class="el" href="group__Ecore.html">Ecore</a>.</dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>it is recommended that one calls <a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init()</a> before creating new canvas.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new uninitialised Evas canvas on success. Otherwise, <code>NULL</code>. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-buffer-simple_8c-example.html#a6">evas-buffer-simple.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad80de73a33446f902d4b39141a8d0a05"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_add" ref="gad80de73a33446f902d4b39141a8d0a05" args="(Evas *e, Evas_Smart *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a>* <a class="el" href="group__Evas__Canvas.html#gad80de73a33446f902d4b39141a8d0a05">evas_object_smart_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Smart *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get if the canvas is currently calculating smart objects. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if currently calculating smart objects. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Instantiates a new smart object described by <code>s</code>.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the canvas on which to add the object </td></tr>
    <tr><td class="paramname">s</td><td>the #Evas_Smart describing the smart object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> handle</dd></dl>
<p>This is the function one should use when defining the public function <b>adding</b> an instance of the new smart object to a given canvas. It will take care of setting all of its internals to work as they should, if the user set things properly, as seem on the <a class="el" href="group__Evas__Smart__Group.html#ga58dc94af6f064b39b2bf0155908fbe52">EVAS_SMART_SUBCLASS_NEW</a>, for example. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a27">evas-smart-interface.c</a>, and <a class="el" href="evas-smart-object_8c-example.html#a21">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga75e5d730482af584eb161bbb6edd551c"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_calculate" ref="ga75e5d730482af584eb161bbb6edd551c" args="(Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga75e5d730482af584eb161bbb6edd551c">evas_object_smart_calculate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call the calculate() smart function immediately on a given smart object. </p>
<p>This will force immediate calculations (see <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a>) needed for renderization of this object and, besides, unset the flag on it telling it needs recalculation for the next rendering phase.</p>
<p>See also <a class="el" href="group__Evas__Canvas.html#ga4d51b8dce4c65e45e3ff0b692dc0bf83">evas_object_smart_need_recalculate_set</a> </p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga18a8b179f94d21b2b09e19db11741061"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_callback_add" ref="ga18a8b179f94d21b2b09e19db11741061" args="(Evas_Object *obj, const char *event, Evas_Smart_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga18a8b179f94d21b2b09e19db11741061">evas_object_smart_callback_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Smart_Cb&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add (register) a callback function to the smart event specified by <code>event</code> on the smart object <code>obj</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>a smart object </td></tr>
    <tr><td class="paramname">event</td><td>the event's name string </td></tr>
    <tr><td class="paramname">func</td><td>the callback function </td></tr>
    <tr><td class="paramname">data</td><td>user data to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<p>Smart callbacks look very similar to Evas callbacks, but are implemented as smart object's custom ones.</p>
<p>This function adds a function callback to an smart object when the event named <code>event</code> occurs in it. The function is <code>func</code>.</p>
<p>In the event of a memory allocation error during addition of the callback to the object, <a class="el" href="group__Evas__Main__Group.html#gacfae4f589c777003f58d51e502c52835" title="Get the error status of the most recent memory allocation call.">evas_alloc_error()</a> should be used to determine the nature of the error, if any, and the program should sensibly try and recover.</p>
<p>A smart callback function must have the ::Evas_Smart_Cb prototype definition. The first parameter (<code>data</code>) in this definition will have the same value passed to <a class="el" href="group__Evas__Canvas.html#ga18a8b179f94d21b2b09e19db11741061">evas_object_smart_callback_add()</a> as the <code>data</code> parameter, at runtime. The second parameter <code>obj</code> is a handle to the object on which the event occurred. The third parameter, <code>event_info</code>, is a pointer to data which is totally dependent on the smart object's implementation and semantic for the given event.</p>
<p>There is an infrastructure for introspection on smart objects' events (see <a class="el" href="group__Evas__Smart__Group.html#ga21bfd8ca489ecc08a0c3c9f66764f06d">evas_smart_callbacks_descriptions_get()</a>), but no internal smart objects on Evas implement them yet.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Smart__Object__Group.html#Evas_Smart_Object_Group_Callbacks">Smart events and callbacks</a> for more details.</dd>
<dd>
<a class="el" href="group__Evas__Canvas.html#gaa79948c7d1bee9a75baa01e72dc4ef63">evas_object_smart_callback_del()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="actionslider_example_01_8c-example.html#a11">actionslider_example_01.c</a>, <a class="el" href="bg_example_03_8c-example.html#a23">bg_example_03.c</a>, <a class="el" href="box_example_02_8c-example.html#a21">box_example_02.c</a>, <a class="el" href="bubble_example_01_8c-example.html#a14">bubble_example_01.c</a>, <a class="el" href="button_example_00_8c-example.html#a9">button_example_00.c</a>, <a class="el" href="button_example_01_8c-example.html#a17">button_example_01.c</a>, <a class="el" href="calendar_example_05_8c-example.html#a9">calendar_example_05.c</a>, <a class="el" href="calendar_example_06_8c-example.html#a12">calendar_example_06.c</a>, <a class="el" href="check_example_01_8c-example.html#a9">check_example_01.c</a>, <a class="el" href="codegen_example_8c-example.html#a15">codegen_example.c</a>, <a class="el" href="colorselector_example_01_8c-example.html#a14">colorselector_example_01.c</a>, <a class="el" href="combobox_example_01_8c-example.html#a23">combobox_example_01.c</a>, <a class="el" href="ctxpopup_example_01_8c-example.html#a7">ctxpopup_example_01.c</a>, <a class="el" href="dayselector_example_8c-example.html#a10">dayselector_example.c</a>, <a class="el" href="diskselector_example_02_8c-example.html#a17">diskselector_example_02.c</a>, <a class="el" href="efl_thread_1_8c-example.html#a4">efl_thread_1.c</a>, <a class="el" href="efl_thread_2_8c-example.html#a3">efl_thread_2.c</a>, <a class="el" href="efl_thread_3_8c-example.html#a7">efl_thread_3.c</a>, <a class="el" href="efl_thread_4_8c-example.html#a8">efl_thread_4.c</a>, <a class="el" href="efl_thread_5_8c-example.html#a10">efl_thread_5.c</a>, <a class="el" href="entry_example_8c-example.html#a32">entry_example.c</a>, <a class="el" href="evas-smart-interface_8c-example.html#a45">evas-smart-interface.c</a>, <a class="el" href="evas-smart-object_8c-example.html#a44">evas-smart-object.c</a>, <a class="el" href="fileselector_button_example_8c-example.html#a15">fileselector_button_example.c</a>, <a class="el" href="fileselector_entry_example_8c-example.html#a15">fileselector_entry_example.c</a>, <a class="el" href="fileselector_example_8c-example.html#a12">fileselector_example.c</a>, <a class="el" href="flip_example_01_8c-example.html#a16">flip_example_01.c</a>, <a class="el" href="flipselector_example_8c-example.html#a16">flipselector_example.c</a>, <a class="el" href="general_funcs_example_8c-example.html#a29">general_funcs_example.c</a>, <a class="el" href="gengrid_example_8c-example.html#a37">gengrid_example.c</a>, <a class="el" href="genlist_example_02_8c-example.html#a40">genlist_example_02.c</a>, <a class="el" href="genlist_example_04_8c-example.html#a13">genlist_example_04.c</a>, <a class="el" href="genlist_example_05_8c-example.html#a20">genlist_example_05.c</a>, <a class="el" href="glview_example_01_8c-example.html#a53">glview_example_01.c</a>, <a class="el" href="hover_example_01_8c-example.html#a14">hover_example_01.c</a>, <a class="el" href="hoversel_example_01_8c-example.html#a17">hoversel_example_01.c</a>, <a class="el" href="index_example_01_8c-example.html#a15">index_example_01.c</a>, <a class="el" href="index_example_02_8c-example.html#a24">index_example_02.c</a>, <a class="el" href="inwin_example_8c-example.html#a14">inwin_example.c</a>, <a class="el" href="layout_example_01_8c-example.html#a6">layout_example_01.c</a>, <a class="el" href="layout_example_03_8c-example.html#a23">layout_example_03.c</a>, <a class="el" href="list_example_03_8c-example.html#a21">list_example_03.c</a>, <a class="el" href="map_example_01_8c-example.html#a20">map_example_01.c</a>, <a class="el" href="map_example_02_8c-example.html#a31">map_example_02.c</a>, <a class="el" href="map_example_03_8c-example.html#a4">map_example_03.c</a>, <a class="el" href="mapbuf_example_8c-example.html#a20">mapbuf_example.c</a>, <a class="el" href="menu_example_01_8c-example.html#a19">menu_example_01.c</a>, <a class="el" href="naviframe_example_8c-example.html#a2">naviframe_example.c</a>, <a class="el" href="notify_example_01_8c-example.html#a13">notify_example_01.c</a>, <a class="el" href="panes_example_8c-example.html#a14">panes_example.c</a>, <a class="el" href="photocam_example_01_8c-example.html#a13">photocam_example_01.c</a>, <a class="el" href="popup_example_01_8c-example.html#a9">popup_example_01.c</a>, <a class="el" href="popup_example_02_8c-example.html#a16">popup_example_02.c</a>, <a class="el" href="popup_example_03_8c-example.html#a16">popup_example_03.c</a>, <a class="el" href="prefs_example_01_8c-example.html#a14">prefs_example_01.c</a>, <a class="el" href="prefs_example_02_8c-example.html#a19">prefs_example_02.c</a>, <a class="el" href="prefs_example_03_8c-example.html#a17">prefs_example_03.c</a>, <a class="el" href="progressbar_example_8c-example.html#a13">progressbar_example.c</a>, <a class="el" href="radio_example_01_8c-example.html#a14">radio_example_01.c</a>, <a class="el" href="slider_example_8c-example.html#a25">slider_example.c</a>, <a class="el" href="slideshow_example_8c-example.html#a24">slideshow_example.c</a>, <a class="el" href="spinner_example_8c-example.html#a16">spinner_example.c</a>, <a class="el" href="theme_example_01_8c-example.html#a18">theme_example_01.c</a>, <a class="el" href="theme_example_02_8c-example.html#a17">theme_example_02.c</a>, <a class="el" href="thumb_example_01_8c-example.html#a8">thumb_example_01.c</a>, <a class="el" href="transit_example_03_8c-example.html#a43">transit_example_03.c</a>, <a class="el" href="transit_example_04_8c-example.html#a32">transit_example_04.c</a>, <a class="el" href="web_example_02_8c-example.html#a9">web_example_02.c</a>, and <a class="el" href="win_example_8c-example.html#a16">win_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa81bbe0af70df6c90b8fc781c59237bc"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_callback_call" ref="gaa81bbe0af70df6c90b8fc781c59237bc" args="(Evas_Object *obj, const char *event, void *event_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#gaa81bbe0af70df6c90b8fc781c59237bc">evas_object_smart_callback_call</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>event_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call a given smart callback on the smart object <code>obj</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the smart object </td></tr>
    <tr><td class="paramname">event</td><td>the event's name string </td></tr>
    <tr><td class="paramname">event_info</td><td>pointer to an event specific struct or information to pass to the callback functions registered on this smart event</td></tr>
  </table>
  </dd>
</dl>
<p>This should be called <b>internally</b>, from the smart object's own code, when some specific event has occurred and the implementor wants is to pertain to the object's events API (see <a class="el" href="group__Evas__Smart__Object__Group.html#Evas_Smart_Object_Group_Callbacks">Smart events and callbacks</a>). The documentation for the smart object should include a list of possible events and what type of <code>event_info</code> to expect for each of them. Also, when defining an <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a>, smart object implementors are strongly encouraged to properly set the <a class="el" href="struct__Evas__Smart__Class.html#af7074494030024c3d0e502bca7b19067">Evas_Smart_Class::callbacks</a> callbacks description array, so that the users of the smart object can have introspection on its events API <b>at run time</b>. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a28">evas-smart-interface.c</a>, and <a class="el" href="evas-smart-object_8c-example.html#a22">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa79948c7d1bee9a75baa01e72dc4ef63"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_callback_del" ref="gaa79948c7d1bee9a75baa01e72dc4ef63" args="(Evas_Object *obj, const char *event, Evas_Smart_Cb func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Evas__Canvas.html#gaa79948c7d1bee9a75baa01e72dc4ef63">evas_object_smart_callback_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Smart_Cb&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete (unregister) a callback function from the smart event specified by <code>event</code> on the smart object <code>obj</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>a smart object </td></tr>
    <tr><td class="paramname">event</td><td>the event's name string </td></tr>
    <tr><td class="paramname">func</td><td>the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the data pointer</dd></dl>
<p>This function removes <b>the first</b> added smart callback on the object <code>obj</code> matching the event name <code>event</code> and the registered function pointer <code>func</code>. If the removal is successful it will also return the data pointer that was passed to <a class="el" href="group__Evas__Canvas.html#ga18a8b179f94d21b2b09e19db11741061">evas_object_smart_callback_add()</a> (that will be the same as the parameter) when the callback(s) was(were) added to the canvas. If not successful <code>NULL</code> will be returned.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Canvas.html#ga18a8b179f94d21b2b09e19db11741061">evas_object_smart_callback_add()</a> for more details. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2163df56f3c1759f83b2996572e94fef"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_callback_del_full" ref="ga2163df56f3c1759f83b2996572e94fef" args="(Evas_Object *obj, const char *event, Evas_Smart_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Evas__Canvas.html#ga2163df56f3c1759f83b2996572e94fef">evas_object_smart_callback_del_full</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Smart_Cb&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete (unregister) a callback function from the smart event specified by <code>event</code> on the smart object <code>obj</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>a smart object </td></tr>
    <tr><td class="paramname">event</td><td>the event's name string </td></tr>
    <tr><td class="paramname">func</td><td>the callback function </td></tr>
    <tr><td class="paramname">data</td><td>the data pointer that was passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the data pointer</dd></dl>
<p>This function removes <b>the first</b> added smart callback on the object <code>obj</code> matching the event name <code>event</code>, the registered function pointer <code>func</code> and the callback data pointer <code>data</code>. If the removal is successful it will also return the data pointer that was passed to <a class="el" href="group__Evas__Canvas.html#ga18a8b179f94d21b2b09e19db11741061">evas_object_smart_callback_add()</a> (that will be the same as the parameter) when the callback(s) was(were) added to the canvas. If not successful <code>NULL</code> will be returned. A common use would be to remove an exact match of a callback</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Canvas.html#ga18a8b179f94d21b2b09e19db11741061">evas_object_smart_callback_add()</a> for more details. </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>To delete all smart event callbacks which match <code>type</code> and <code>func</code>, use <a class="el" href="group__Evas__Canvas.html#gaa79948c7d1bee9a75baa01e72dc4ef63">evas_object_smart_callback_del()</a>. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gac823969882ff252d6cd56b876242b82f"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_callback_description_find" ref="gac823969882ff252d6cd56b876242b82f" args="(const Evas_Object *obj, const char *name, const Evas_Smart_Cb_Description **class_description, const Evas_Smart_Cb_Description **instance_description)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#gac823969882ff252d6cd56b876242b82f">evas_object_smart_callback_description_find</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a> **&#160;</td>
          <td class="paramname"><em>class_description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a> **&#160;</td>
          <td class="paramname"><em>instance_description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find callback description for callback called name or <code>null</code> if not found. </p>
<p>If parameter is <code>null</code>, no search will be done on instance descriptions.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of desired callback, must not be <code>null</code>. The search have a special case for name being the same pointer as registered with Evas_Smart_Cb_Description, one can use it to avoid excessive use of strcmp(). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">class_description</td><td>pointer to return class description or <code>null</code> if not found. If parameter is <code>null</code>, no search will be done on class descriptions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">instance_description</td><td>pointer to return instance description. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gac0332a965f191376d30786a624bfad41"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_callback_priority_add" ref="gac0332a965f191376d30786a624bfad41" args="(Evas_Object *obj, const char *event, Evas_Callback_Priority priority, Evas_Smart_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#gac0332a965f191376d30786a624bfad41">evas_object_smart_callback_priority_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Callback_Priority&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Smart_Cb&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add (register) a callback function to the smart event specified by <code>event</code> on the smart object <code>obj</code>. Except for the priority field, it's exactly the same as <a class="el" href="group__Evas__Canvas.html#ga18a8b179f94d21b2b09e19db11741061">evas_object_smart_callback_add</a></p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>a smart object </td></tr>
    <tr><td class="paramname">event</td><td>the event's name string </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the callback, lower values called first. </td></tr>
    <tr><td class="paramname">func</td><td>the callback function </td></tr>
    <tr><td class="paramname">data</td><td>user data to be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Canvas.html#ga18a8b179f94d21b2b09e19db11741061">evas_object_smart_callback_add</a> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga78cb1ef59bcf3e20e2b437dbf1f5aac8"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_callbacks_descriptions_get" ref="ga78cb1ef59bcf3e20e2b437dbf1f5aac8" args="(const Evas_Object *obj, const Evas_Smart_Cb_Description ***class_descriptions, unsigned int *class_count, const Evas_Smart_Cb_Description ***instance_descriptions, unsigned int *instance_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga78cb1ef59bcf3e20e2b437dbf1f5aac8">evas_object_smart_callbacks_descriptions_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a> ***&#160;</td>
          <td class="paramname"><em>class_descriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>class_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a> ***&#160;</td>
          <td class="paramname"><em>instance_descriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>instance_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve an smart object's know smart callback descriptions (both instance and class ones). </p>
<p>This call searches for registered callback descriptions for both instance and class of the given smart object. These arrays will be sorted by <a class="el" href="struct__Evas__Smart__Cb__Description.html#ab377859f4cfcf1c2dd3c149a76b70b53">Evas_Smart_Cb_Description.name</a> and also <code>null</code> terminated, so both class_count and instance_count can be ignored, if the caller wishes so. The terminator <code>null</code> is not counted in these values.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If just class descriptions are of interest, try <a class="el" href="group__Evas__Smart__Group.html#ga21bfd8ca489ecc08a0c3c9f66764f06d">evas_smart_callbacks_descriptions_get()</a> instead.</dd>
<dd>
Use <code>null</code> pointers on the descriptions/counters you're not interested in: they'll be ignored by the function.</dd></dl>
<p><a class="el" href="group__Evas__Smart__Group.html#ga21bfd8ca489ecc08a0c3c9f66764f06d">evas_smart_callbacks_descriptions_get()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">class_descriptions</td><td>Where to store class callbacks descriptions array, if any is known. If no descriptions are known, <code>null</code> is returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">class_count</td><td>Returns how many class callbacks descriptions are known. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">instance_descriptions</td><td>Where to store instance callbacks descriptions array, if any is known. If no descriptions are known, <code>null</code> is returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">instance_count</td><td>Returns how many instance callbacks descriptions are known. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a44">evas-smart-interface.c</a>, and <a class="el" href="evas-smart-object_8c-example.html#a43">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga221c5b16b65485229becc77bd22c7213"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_callbacks_descriptions_set" ref="ga221c5b16b65485229becc77bd22c7213" args="(Evas_Object *obj, const Evas_Smart_Cb_Description *descriptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Canvas.html#ga221c5b16b65485229becc77bd22c7213">evas_object_smart_callbacks_descriptions_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a> *&#160;</td>
          <td class="paramname"><em>descriptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set an smart object instance's smart callbacks descriptions. </p>
<p>These descriptions are hints to be used by introspection and are not enforced in any way.</p>
<p>It will not be checked if instance callbacks descriptions have the same name as respective possibly registered in the smart object class. Both are kept in different arrays and users of <a class="el" href="group__Evas__Canvas.html#ga78cb1ef59bcf3e20e2b437dbf1f5aac8" title="Retrieve an smart object&#39;s know smart callback descriptions (both instance and class ones)...">evas_object_smart_callbacks_descriptions_get()</a> should handle this case as they wish.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because <code>descriptions</code> must be <code>null</code> terminated, and because a <code>null</code> name makes little sense, too, <a class="el" href="struct__Evas__Smart__Cb__Description.html#ab377859f4cfcf1c2dd3c149a76b70b53">Evas_Smart_Cb_Description.name</a> must not be <code>null</code>.</dd>
<dd>
While instance callbacks descriptions are possible, they are not recommended. Use class callbacks descriptions instead as they make you smart object user's life simpler and will use less memory, as descriptions and arrays will be shared among all instances.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptions</td><td><code>null</code> terminated array with <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a> descriptions. Array elements won't be modified at run time, but references to them and their contents will be made, so this array should be kept alive during the whole object's lifetime.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on failure. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f08aefaa29ea4bfc5b3f5c89c85dd59"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_changed" ref="ga4f08aefaa29ea4bfc5b3f5c89c85dd59" args="(Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga4f08aefaa29ea4bfc5b3f5c89c85dd59">evas_object_smart_changed</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark smart object as changed, dirty. </p>
<p>This will flag the given object as needing recalculation, forcefully. As an effect, on the next rendering cycle its calculate() (see <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a>) smart function will be called.</p>
<p>See also <a class="el" href="group__Evas__Canvas.html#ga4d51b8dce4c65e45e3ff0b692dc0bf83">evas_object_smart_need_recalculate_set</a> and <a class="el" href="group__Evas__Canvas.html#ga75e5d730482af584eb161bbb6edd551c">evas_object_smart_calculate</a>. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-aspect-hints_8c-example.html#a18">evas-aspect-hints.c</a>, <a class="el" href="evas-smart-interface_8c-example.html#a12">evas-smart-interface.c</a>, and <a class="el" href="evas-smart-object_8c-example.html#a9">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga1ea2217e8a4abc28a35d8273949d4444"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_clipped_clipper_get" ref="ga1ea2217e8a4abc28a35d8273949d4444" args="(const Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a>* <a class="el" href="group__Evas__Canvas.html#ga1ea2217e8a4abc28a35d8273949d4444">evas_object_smart_clipped_clipper_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the clipper object for the given clipped smart object. </p>
<p>Use this function if you want to change any of this clipper's properties, like colors. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a43">evas-smart-interface.c</a>, and <a class="el" href="evas-smart-object_8c-example.html#a42">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4049c0eb448d6d7e16a47a5acbd09fee"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_data_get" ref="ga4049c0eb448d6d7e16a47a5acbd09fee" args="(const Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Evas__Canvas.html#ga4049c0eb448d6d7e16a47a5acbd09fee">evas_object_smart_data_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b3a3bfd4da40289cc36c9a94c06d10a"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_data_set" ref="ga0b3a3bfd4da40289cc36c9a94c06d10a" args="(Evas_Object *obj, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga0b3a3bfd4da40289cc36c9a94c06d10a">evas_object_smart_data_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Store a pointer to user data for a given smart object. </p>
<p>This data is stored independently of the one set by <a class="el" href="group__Evas__Object__Group__Extras.html#ga70134a7068c9bff4107a761abe0a2ad4">evas_object_data_set()</a>, naturally.</p>
<p>See also <a class="el" href="group__Evas__Canvas.html#ga4049c0eb448d6d7e16a47a5acbd09fee">evas_object_smart_data_get</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gaed3359faaae2d7cffd3e24441591da04"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_interface_data_get" ref="gaed3359faaae2d7cffd3e24441591da04" args="(const Evas_Object *obj, const Evas_Smart_Interface *iface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Evas__Canvas.html#gaed3359faaae2d7cffd3e24441591da04">evas_object_smart_interface_data_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Evas__Smart__Group.html#gaef9b6443e1fdb6ffd3acd39981e91fee">Evas_Smart_Interface</a> *&#160;</td>
          <td class="paramname"><em>iface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve an Evas smart object interface's <b>private data</b>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>An Evas smart object. </td></tr>
    <tr><td class="paramname">iface</td><td>The given object's interface handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The object interface's private data blob pointer, if found, <code>NULL</code> otherwise. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a3">evas-smart-interface.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga726849e13d3bbc0c7ce182e3f82ce07f"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_interface_get" ref="ga726849e13d3bbc0c7ce182e3f82ce07f" args="(const Evas_Object *obj, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="group__Evas__Canvas.html#ga726849e13d3bbc0c7ce182e3f82ce07f">evas_object_smart_interface_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve an Evas smart object's interface, by name string pointer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>An Evas smart object. </td></tr>
    <tr><td class="paramname">name</td><td>Name string of the desired interface, which must be the same pointer used at the interface's declarion, when creating the smart object <em>obj</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The interface's handle pointer, if found, <code>NULL</code> otherwise. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a47">evas-smart-interface.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga38ba3b22ec79e4c72d83917959537c5c"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_iterator_new" ref="ga38ba3b22ec79e4c72d83917959537c5c" args="(const Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Iterator__Group.html#ga15b975bb881d955249ce13d4ebc96948">Eina_Iterator</a>* <a class="el" href="group__Evas__Canvas.html#ga38ba3b22ec79e4c72d83917959537c5c">evas_object_smart_iterator_new</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an iterator of the member objects of a given Evas smart object. </p>
<p>See also Efl::Canvas::Group::group_member_add and Efl::Canvas::Group::group_member_remove</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the iterator of the member objects of <code>obj</code>.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga6845c17effe796430cb4fc5f2cfccef0"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_member_add" ref="ga6845c17effe796430cb4fc5f2cfccef0" args="(Evas_Object *obj, Evas_Object *smart_obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga6845c17effe796430cb4fc5f2cfccef0">evas_object_smart_member_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>smart_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set an Evas object as a member of a given smart object.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The member object </td></tr>
    <tr><td class="paramname">smart_obj</td><td>The smart object</td></tr>
  </table>
  </dd>
</dl>
<p>Members will automatically be stacked and layered together with the smart object. The various stacking functions will operate on members relative to the other members instead of the entire canvas, since they now live on an exclusive layer (see evas_object_stack_above(), for more details).</p>
<p>Any <code>smart_obj</code> object's specific implementation of the <code>member_add()</code> smart function will take place too, naturally.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Canvas.html#ga12034359ab780a3a0e8b20b83475ed15">evas_object_smart_member_del()</a> </dd>
<dd>
<a class="el" href="group__Evas__Canvas.html#ga97233734c49c93a258315bff9dfc85f5" title="Retrieves the list of the member objects of a given Evas smart object.">evas_object_smart_members_get()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a17">evas-smart-interface.c</a>, and <a class="el" href="evas-smart-object_8c-example.html#a15">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga12034359ab780a3a0e8b20b83475ed15"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_member_del" ref="ga12034359ab780a3a0e8b20b83475ed15" args="(Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga12034359ab780a3a0e8b20b83475ed15">evas_object_smart_member_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes a member object from a given smart object.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the member object</td></tr>
  </table>
  </dd>
</dl>
<p>This removes a member object from a smart object, if it was added to any. The object will still be on the canvas, but no longer associated with whichever smart object it was associated with.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Canvas.html#ga6845c17effe796430cb4fc5f2cfccef0">evas_object_smart_member_add()</a> for more details </dd>
<dd>
<a class="el" href="group__Evas__Canvas.html#ga97233734c49c93a258315bff9dfc85f5" title="Retrieves the list of the member objects of a given Evas smart object.">evas_object_smart_members_get()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a11">evas-smart-interface.c</a>, and <a class="el" href="evas-smart-object_8c-example.html#a8">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga97233734c49c93a258315bff9dfc85f5"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_members_get" ref="ga97233734c49c93a258315bff9dfc85f5" args="(const Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Evas__Canvas.html#ga97233734c49c93a258315bff9dfc85f5">evas_object_smart_members_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the list of the member objects of a given Evas smart object. </p>
<p>The returned list should be freed with <code><a class="el" href="group__Eina__List__Group.html#ga608bd2fbf06293a1b794648990703ab4" title="Frees an entire list and all the nodes, ignoring the data contained.">eina_list_free()</a></code> when you no longer need it.</p>
<p>This function will return <code>null</code> when a non-smart object is passed.</p>
<p>See also Efl::Canvas::Group::group_member_add, Efl::Canvas::Group::group_member_remove and <a class="el" href="group__Evas__Canvas.html#ga38ba3b22ec79e4c72d83917959537c5c">evas_object_smart_iterator_new</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the list of the member objects of <code>obj</code>.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5697d5752d7ae9eab433e7928758a9e7"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_move_children_relative" ref="ga5697d5752d7ae9eab433e7928758a9e7" args="(Evas_Object *obj, Evas_Coord dx, Evas_Coord dy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga5697d5752d7ae9eab433e7928758a9e7">evas_object_smart_move_children_relative</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves all children objects of a given smart object relative to a given offset. </p>
<p>This will make each of <code>obj</code> object's children to move, from where they before, with those delta values (offsets) on both directions.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is most useful on custom smart <code>move</code> functions.</dd>
<dd>
Clipped smart objects already make use of this function on their <code>move</code> smart function definition.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dx</td><td>Horizontal offset (delta). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dy</td><td>Vertical offset (delta). </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gaa590979740ee1bef6217665ac71f2ed6"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_need_recalculate_get" ref="gaa590979740ee1bef6217665ac71f2ed6" args="(const Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Canvas.html#gaa590979740ee1bef6217665ac71f2ed6">evas_object_smart_need_recalculate_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the value of the flag signalling that a given smart object needs to get recalculated. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>this flag will be unset during the rendering phase, when the <code>calculate()</code> smart function is called, if one is provided. If it's not provided, then the flag will be left unchanged after the rendering phase.</dd></dl>
<p>See also <a class="el" href="group__Evas__Canvas.html#ga4d51b8dce4c65e45e3ff0b692dc0bf83">evas_object_smart_need_recalculate_set</a>, for more details.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether one wants to set ($true) or to unset ($false) the flag. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d51b8dce4c65e45e3ff0b692dc0bf83"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_need_recalculate_set" ref="ga4d51b8dce4c65e45e3ff0b692dc0bf83" args="(Evas_Object *obj, Eina_Bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga4d51b8dce4c65e45e3ff0b692dc0bf83">evas_object_smart_need_recalculate_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set or unset the flag signalling that a given smart object needs to get recalculated. </p>
<p>If this flag is set, then the <code>calculate()</code> smart function of <code>obj</code> will be called, if one is provided, during rendering phase of Evas (see evas_render()), after which this flag will be automatically unset.</p>
<p>If that smart function is not provided for the given object, this flag will be left unchanged.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>just setting this flag will not make the canvas' whole scene dirty, by itself, and evas_render() will have no effect. To force that, use <a class="el" href="group__Evas__Canvas.html#ga4f08aefaa29ea4bfc5b3f5c89c85dd59" title="Mark smart object as changed, dirty.">evas_object_smart_changed()</a>, that will also call this function automatically, with <code>true</code> as parameter.</dd></dl>
<p>See also <a class="el" href="group__Evas__Canvas.html#gaa590979740ee1bef6217665ac71f2ed6">evas_object_smart_need_recalculate_get</a>, <a class="el" href="group__Evas__Canvas.html#ga75e5d730482af584eb161bbb6edd551c">evas_object_smart_calculate</a> and <a class="el" href="group__Evas__Canvas.html#ga0cfa7df81a1c781997f7cdcb8aa4f69e">evas_smart_objects_calculate()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>whether one wants to set ($true) or to unset ($false) the flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga66a058d42f85d91bee636e2d5fa508ec"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_smart_get" ref="ga66a058d42f85d91bee636e2d5fa508ec" args="(const Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Evas_Smart* <a class="el" href="group__Evas__Canvas.html#ga66a058d42f85d91bee636e2d5fa508ec">evas_object_smart_smart_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Evas_Smart from which <code>obj</code> smart object was created. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the Evas_Smart handle or <code>null</code>, on errors. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga257a2651b93de714211d4205c0e70bb9"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_type_check" ref="ga257a2651b93de714211d4205c0e70bb9" args="(const Evas_Object *obj, const char *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Canvas.html#ga257a2651b93de714211d4205c0e70bb9">evas_object_smart_type_check</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a given smart object or any of its smart object parents is of a given smart class. </p>
<p>If <code>obj</code> is not a smart object, this call will fail immediately.</p>
<p>This function supports Eo and legacy inheritance mechanisms. However, it is recommended to use efl_isa instead if your object is using Eo from top to bottom.</p>
<p>The checks use smart classes names and string comparison. There is a version of this same check using pointer comparison, since a smart class' name is a single string in Evas.</p>
<p>See also <a class="el" href="group__Evas__Canvas.html#ga164c21f7e780bdf48caaa4147975d456">evas_object_smart_type_check_ptr</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The name (type) of the smart class to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a42">evas-smart-interface.c</a>, and <a class="el" href="evas-smart-object_8c-example.html#a41">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga164c21f7e780bdf48caaa4147975d456"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_smart_type_check_ptr" ref="ga164c21f7e780bdf48caaa4147975d456" args="(const Evas_Object *obj, const char *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Canvas.html#ga164c21f7e780bdf48caaa4147975d456">evas_object_smart_type_check_ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a given smart object or any of its smart object parents is of a given smart class, using pointer comparison. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type (name string) to check for. Must be the name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if <code>obj</code> or any of its parents is of type <code>type</code>, <code>false</code> otherwise. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gaf014b1591398720a6452d5a5308534ab"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_top_in_rectangle_get" ref="gaf014b1591398720a6452d5a5308534ab" args="(const Eo *obj, int x, int y, int w, int h, Eina_Bool include_pass_events_objects, Eina_Bool include_hidden_objects)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a>* <a class="el" href="group__Evas__Canvas.html#gaf014b1591398720a6452d5a5308534ab">evas_object_top_in_rectangle_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Eo *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>include_pass_events_objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>include_hidden_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the Evas object stacked at the top of a given rectangular region in a canvas. </p>
<p>This function will traverse all the layers of the given canvas, from top to bottom, querying for objects with areas overlapping with the given rectangular region inside <code>e</code>. The user can remove from the query objects which are hidden and/or which are set to pass events.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function will skip objects parented by smart objects, acting only on the ones at the "top level", with regard to object parenting.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The top left corner's horizontal coordinate for the rectangular region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The top left corner's vertical coordinate for the rectangular region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The width of the rectangular region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The height of the rectangular region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">include_pass_events_objects</td><td>Boolean flag to include or not objects which pass events in this calculation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">include_hidden_objects</td><td>Boolean flag to include or not hidden objects in this calculation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Evas object that is over all other objects at the given rectangular region.  3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga4db30a34668013944c30131c7bf5ecb1"></a><!-- doxytag: member="Evas_Legacy.h::evas_output_framespace_get" ref="ga4db30a34668013944c30131c7bf5ecb1" args="(const Evas *e, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga4db30a34668013944c30131c7bf5ecb1">evas_output_framespace_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the render engine's output framespace coordinates in canvas units. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>The left coordinate in output units, usually pixels. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>The top coordinate in output units, usually pixels. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>The width in output units, usually pixels. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>The height in output units, usually pixels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6903b6e66c61568175046288c51ea32"></a><!-- doxytag: member="Evas_Legacy.h::evas_output_framespace_set" ref="gaa6903b6e66c61568175046288c51ea32" args="(Evas *e, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#gaa6903b6e66c61568175046288c51ea32">evas_output_framespace_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the output framespace size of the render engine of the given evas. </p>
<p>The framespace size is used in the Wayland engines to denote space in the viewport which is occupied by the window frame. This is mainly used in ecore_evas to draw borders.</p>
<p>The units used for <code>w</code> and <code>h</code> depend on the engine used by the evas.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The left coordinate in output units, usually pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The top coordinate in output units, usually pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The width in output units, usually pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The height in output units, usually pixels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9448841c72f804fd1533b6dcceeabd1a"></a><!-- doxytag: member="Evas_Legacy.h::evas_output_method_get" ref="ga9448841c72f804fd1533b6dcceeabd1a" args="(const Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Canvas.html#ga9448841c72f804fd1533b6dcceeabd1a">evas_output_method_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the number of the output engine used for the given evas. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The numeric engine value to use. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga15b85dc673baa6aa40f91f8bfcd3cbaa"></a><!-- doxytag: member="Evas_Legacy.h::evas_output_method_set" ref="ga15b85dc673baa6aa40f91f8bfcd3cbaa" args="(Evas *e, int render_method)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga15b85dc673baa6aa40f91f8bfcd3cbaa">evas_output_method_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>render_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the output engine for the given evas. </p>
<p>Once the output engine for an evas is set, any attempt to change it will be ignored. The value for <code>render_method</code> can be found using <a class="el" href="group__Evas__Output__Method.html#ga9f9871fdcc40ce1062d6565308020eb8">evas_render_method_lookup</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>it is mandatory that one calls <a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8">evas_init</a> before setting the output method.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">render_method</td><td>The numeric engine value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-buffer-simple_8c-example.html#a7">evas-buffer-simple.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gadd22b11c786b3b00448ef58550aa55c4"></a><!-- doxytag: member="Evas_Legacy.h::evas_output_size_get" ref="gadd22b11c786b3b00448ef58550aa55c4" args="(const Evas *e, int *w, int *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#gadd22b11c786b3b00448ef58550aa55c4">evas_output_size_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the output size of the render engine of the given evas. </p>
<p>The output size is given in whatever the output units are for the engine.</p>
<p>If either <code>w</code> or <code>h</code> is <code>null</code>, then it is ignored. If <code>e</code> is invalid, the returned results are undefined.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>The width in output units, usually pixels. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>The height in output units, usually pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_evas_buffer_example_01_8c-example.html#a0">ecore_evas_buffer_example_01.c</a>, <a class="el" href="evas-buffer-simple_8c-example.html#a17">evas-buffer-simple.c</a>, and <a class="el" href="evas-map-utils_8c-example.html#a0">evas-map-utils.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaf6478cb249ed09fa0fe961085773fe1e"></a><!-- doxytag: member="Evas_Legacy.h::evas_output_size_set" ref="gaf6478cb249ed09fa0fe961085773fe1e" args="(Evas *e, int w, int h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#gaf6478cb249ed09fa0fe961085773fe1e">evas_output_size_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the output size of the render engine of the given evas. </p>
<p>The evas will render to a rectangle of the given size once this function is called. The output size is independent of the viewport size. The viewport will be stretched to fill the given rectangle.</p>
<p>The units used for <code>w</code> and <code>h</code> depend on the engine used by the evas.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The width in output units, usually pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The height in output units, usually pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-buffer-simple_8c-example.html#a8">evas-buffer-simple.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4fd01f00dea7c4877d887d3c65816b60"></a><!-- doxytag: member="Evas_Legacy.h::evas_output_view_get" ref="ga4fd01f00dea7c4877d887d3c65816b60" args="(const Evas_Out *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h) EINA_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga4fd01f00dea7c4877d887d3c65816b60">evas_output_view_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Out *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the viewport region of the canvas that the output display. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000348">Deprecated:</a></b></dt><dd>evas_output_view_set </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000349">Deprecated:</a></b></dt><dd>evas_output_view_get </dd></dl>

</div>
</div>
<a class="anchor" id="ga346bb724a254e8681c382b84886045b4"></a><!-- doxytag: member="Evas_Legacy.h::evas_output_viewport_get" ref="ga346bb724a254e8681c382b84886045b4" args="(const Evas *e, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga346bb724a254e8681c382b84886045b4">evas_output_viewport_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the render engine's output viewport coordinates in canvas units. </p>
<p>Calling this function writes the current canvas output viewport size and location values into the variables pointed to by <code>x</code>, <code>y</code>, <code>w</code> and <code>h</code>. On success the variables have the output location and size values written to them in canvas units. Any of <code>x</code>, <code>y</code>, <code>w</code> or <code>h</code> that are <code>null</code> will not be written to. If <code>e</code> is invalid, the results are undefined.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>The top-left corner x value of the viewport. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>The top-left corner y value of the viewport. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>The width of the viewport. Must be greater than 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>The height of the viewport. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-events_8c-example.html#a22">evas-events.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6dcd13997f7825f03807dc0ec38dd38e"></a><!-- doxytag: member="Evas_Legacy.h::evas_output_viewport_set" ref="ga6dcd13997f7825f03807dc0ec38dd38e" args="(Evas *e, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga6dcd13997f7825f03807dc0ec38dd38e">evas_output_viewport_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the output viewport of the given evas in evas units. </p>
<p>The output viewport is the area of the evas that will be visible to the viewer. The viewport will be stretched to fit the output target of the evas when rendering is performed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The coordinate values do not have to map 1-to-1 with the output target. However, it is generally advised that it is done for ease of use.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The top-left corner x value of the viewport. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The top-left corner y value of the viewport. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The width of the viewport. Must be greater than 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The height of the viewport. Must be greater than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-buffer-simple_8c-example.html#a9">evas-buffer-simple.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga65ae9005097b7131b8c9d20f1c0e991a"></a><!-- doxytag: member="Evas_Legacy.h::evas_pointer_inside_get" ref="ga65ae9005097b7131b8c9d20f1c0e991a" args="(const Evas *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Canvas.html#ga65ae9005097b7131b8c9d20f1c0e991a">evas_pointer_inside_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the mouse pointer is logically inside the canvas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The pointer device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the pointer is inside, <code>false</code> otherwise.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Returns whether the default mouse pointer is logically inside the canvas.</dd></dl>
<p>When this function is called it will return a value of either <code>false</code> or <code>true</code>, depending on if event_feed_mouse_in or event_feed_mouse_out have been called to feed in a mouse enter event into the canvas.</p>
<p>A return value of <code>true</code> indicates the mouse is logically inside the canvas, and <code>false</code> implies it is logically outside the canvas.</p>
<p>A canvas begins with the mouse being assumed outside ($false).</p>
<p>If <code>e</code> is not a valid canvas, the return value is undefined.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the mouse pointer is inside the canvas, <code>false</code> otherwise </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga038d98c7c13a86b6ba4de51f8aba3595"></a><!-- doxytag: member="Evas_Common.h::evas_render_updates_free" ref="ga038d98c7c13a86b6ba4de51f8aba3595" args="(Eina_List *updates)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga038d98c7c13a86b6ba4de51f8aba3595">evas_render_updates_free</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>updates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free the rectangles returned by evas_render_updates().</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">updates</td><td>The list of updated rectangles of the canvas.</td></tr>
  </table>
  </dd>
</dl>
<p>This function removes the region from the render updates list. It makes the region doesn't be render updated anymore.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>evas_render_updates() for an example </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-buffer-simple_8c-example.html#a16">evas-buffer-simple.c</a>, and <a class="el" href="evas-events_8c-example.html#a25">evas-events.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga0cfa7df81a1c781997f7cdcb8aa4f69e"></a><!-- doxytag: member="Evas_Legacy.h::evas_smart_objects_calculate" ref="ga0cfa7df81a1c781997f7cdcb8aa4f69e" args="(Eo *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Canvas.html#ga0cfa7df81a1c781997f7cdcb8aa4f69e">evas_smart_objects_calculate</a> </td>
          <td>(</td>
          <td class="paramtype">Eo *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call user-provided <code>calculate</code> smart functions and unset the flag signalling that the object needs to get recalculated to all smart objects in the canvas. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="map_example_01_8c-example.html#a7">map_example_01.c</a>, <a class="el" href="map_example_02_8c-example.html#a18">map_example_02.c</a>, and <a class="el" href="map_example_03_8c-example.html#a11">map_example_03.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
