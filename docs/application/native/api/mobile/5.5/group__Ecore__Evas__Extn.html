<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: External plug/socket infrastructure for remote canvases</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.5</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Ecore__Evas__Extn.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">External plug/socket infrastructure for remote canvases</div>  </div>
<div class="ingroups"><a class="el" href="group__Ecore__Evas__Group.html">Ecore_Evas wrapper/helper set of functions</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>These functions allow 1 process to create a "socket" was pluged into which another process can create a "plug" remotely to plug into. Socket can provide content for several plugs. This is best for small sized objects (about the size range of a small icon up to a few large icons). Since the plug is actually an image object, you can fetch the pixel data</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2 </dd></dl>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Ecore_Evas *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#gae1e73d6b5093135d6a672139692b254d">ecore_evas_extn_socket_new</a> (int w, int h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Ecore_Evas canvas for the new external ecore evas socket.  <a href="#gae1e73d6b5093135d6a672139692b254d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#gaa0319ad5830dc464e8d83708b9158830">ecore_evas_extn_socket_listen</a> (Ecore_Evas *ee, const char *svcname, int svcnum, <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> svcsys)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a socket to provide the service for external ecore evas socket.  <a href="#gaa0319ad5830dc464e8d83708b9158830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#gaefb9aa8be25ef61b084adc7d07e6b5c4">ecore_evas_extn_socket_events_block_set</a> (Ecore_Evas *ee, <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> events_block)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the blocking about mouse events to Ecore Evas.  <a href="#gaefb9aa8be25ef61b084adc7d07e6b5c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#ga911978ab5d5f93976f717349f8775837">ecore_evas_extn_socket_events_block_get</a> (Ecore_Evas *ee)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blocking about mouse events to Ecore Evas.  <a href="#ga911978ab5d5f93976f717349f8775837"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#ga4712ba3c3b6abc99328df350c94805f1">ecore_evas_extn_plug_object_data_lock</a> (<a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the pixel data so the socket cannot change it.  <a href="#ga4712ba3c3b6abc99328df350c94805f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#gac4901fce411947a016d088ebcf4b2eb1">ecore_evas_extn_plug_object_data_unlock</a> (<a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the pixel data so the socket can change it again.  <a href="#gac4901fce411947a016d088ebcf4b2eb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd">ecore_evas_extn_plug_new</a> (Ecore_Evas *ee_target)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new external ecore evas plug.  <a href="#ga43099d8b735779aa6f16c38ddd2704fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#ga76fc66f074181b8bde6dce189d15bde1">ecore_evas_extn_plug_connect</a> (<a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *obj, const char *svcname, int svcnum, <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> svcsys)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects an external ecore evas plug to service provided by external ecore evas socket.  <a href="#ga76fc66f074181b8bde6dce189d15bde1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#gadd0a1d64b1f973f00a8ca871dbf941cd">ecore_evas_obscured_get</a> (const Ecore_Evas *ee)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the ecore evas is obscured or unobscured.  <a href="#gadd0a1d64b1f973f00a8ca871dbf941cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#ga31f1845bb968727b195da44d41aface9">ecore_evas_pointer_xy_get</a> (const Ecore_Evas *ee, Evas_Coord *x, Evas_Coord *y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the coordinates of the default mouse pointer.  <a href="#ga31f1845bb968727b195da44d41aface9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#gaa8012e6eb8c7ed0edb929c403c222eb8">ecore_evas_pointer_warp</a> (const Ecore_Evas *ee, Evas_Coord x, Evas_Coord y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the coordinates of the mouse pointer.  <a href="#gaa8012e6eb8c7ed0edb929c403c222eb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#gae200e55fd2250714a98af30854ac634e">ecore_evas_pointer_device_xy_get</a> (const Ecore_Evas *ee, const Efl_Input_Device *pointer, Evas_Coord *x, Evas_Coord *y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the coordinates of the mouse pointer.  <a href="#gae200e55fd2250714a98af30854ac634e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#ga80a58570553d8a6a6a9a9ff436d884ab">ecore_evas_pixmap_visual_get</a> (const Ecore_Evas *ee)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the Visual used for pixmap creation.  <a href="#ga80a58570553d8a6a6a9a9ff436d884ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#gae3ede621f9aad43e903273683562b4dd">ecore_evas_pixmap_colormap_get</a> (const Ecore_Evas *ee)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the Colormap used for pixmap creation.  <a href="#gae3ede621f9aad43e903273683562b4dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Evas__Extn.html#gaa27b0990d5117be1ac96a13991cfd86a">ecore_evas_pixmap_depth_get</a> (const Ecore_Evas *ee)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the depth used for pixmap creation.  <a href="#gaa27b0990d5117be1ac96a13991cfd86a"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga76fc66f074181b8bde6dce189d15bde1"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_extn_plug_connect" ref="ga76fc66f074181b8bde6dce189d15bde1" args="(Evas_Object *obj, const char *svcname, int svcnum, Eina_Bool svcsys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Evas__Extn.html#ga76fc66f074181b8bde6dce189d15bde1">ecore_evas_extn_plug_connect</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>svcname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>svcnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>svcsys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects an external ecore evas plug to service provided by external ecore evas socket. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The Ecore_Evas containing the canvas in which the new image object will live. </td></tr>
    <tr><td class="paramname">svcname</td><td>The service name to connect to set up by the socket. </td></tr>
    <tr><td class="paramname">svcnum</td><td>The service number to connect to (set up by socket). </td></tr>
    <tr><td class="paramname">svcsys</td><td>Boolean to set if the service is a system one or not (set up by socket). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> if creation is successful, <code>EINA_FALSE</code> if it does not.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd" title="Creates a new external ecore evas plug.">ecore_evas_extn_plug_new()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga43099d8b735779aa6f16c38ddd2704fd"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_extn_plug_new" ref="ga43099d8b735779aa6f16c38ddd2704fd" args="(Ecore_Evas *ee_target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a>* <a class="el" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd">ecore_evas_extn_plug_new</a> </td>
          <td>(</td>
          <td class="paramtype">Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee_target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new external ecore evas plug. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee_target</td><td>The Ecore_Evas containing the canvas in which the new image object will live. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An evas image object that will contain the image output of a socket.</dd></dl>
<p>This creates an image object that will contain the output of another processes socket canvas when it connects. All input will be sent back to this process as well, effectively swallowing or placing the socket process in the canvas of the plug process in place of the image object. The image object by default is created to be filled (equivalent of evas_object_image_filled_add() on creation) so image content will scale to fill the image unless otherwise reconfigured. The Ecore_Evas size of the plug is the master size and determines size in pixels of the plug canvas. You can change the size with something like:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> res = <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>;
 <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *obj = <a class="code" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd" title="Creates a new external ecore evas plug.">ecore_evas_extn_plug_new</a>(ee);

 res = <a class="code" href="group__Ecore__Evas__Extn.html#ga76fc66f074181b8bde6dce189d15bde1" title="Connects an external ecore evas plug to service provided by external ecore evas socket.">ecore_evas_extn_plug_connect</a>(<span class="stringliteral">&quot;svcname&quot;</span>, 1, <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>);
 <span class="keywordflow">if</span> (!res) <span class="keywordflow">return</span>;
 <a class="code" href="group__Ecore__Evas__Group.html#gaab5a6884e3e253bb0de6e9d760f3f9b8" title="Resizes an Ecore_Evas.">ecore_evas_resize</a>(ee, 240, 400);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Evas__Extn.html#gae1e73d6b5093135d6a672139692b254d" title="Creates a new Ecore_Evas canvas for the new external ecore evas socket.">ecore_evas_extn_socket_new()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Evas__Extn.html#ga76fc66f074181b8bde6dce189d15bde1" title="Connects an external ecore evas plug to service provided by external ecore evas socket.">ecore_evas_extn_plug_connect()</a> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4712ba3c3b6abc99328df350c94805f1"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_extn_plug_object_data_lock" ref="ga4712ba3c3b6abc99328df350c94805f1" args="(Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Evas__Extn.html#ga4712ba3c3b6abc99328df350c94805f1">ecore_evas_extn_plug_object_data_lock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks the pixel data so the socket cannot change it. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The image object returned by <a class="el" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd" title="Creates a new external ecore evas plug.">ecore_evas_extn_plug_new()</a> to lock</td></tr>
  </table>
  </dd>
</dl>
<p>You may need to get the image pixel data with evas_object_image_data_get() from the image object, but need to ensure that it does not change while you are using the data. This function lets you set an advisory lock on the image data so the external plug process will not render to it or alter it.</p>
<p>You should only hold the lock for just as long as you need to read out the image data or otherwise deal with it, and then unlock it with <a class="el" href="group__Ecore__Evas__Extn.html#gac4901fce411947a016d088ebcf4b2eb1" title="Unlocks the pixel data so the socket can change it again.">ecore_evas_extn_plug_object_data_unlock()</a>. Keeping a lock over more than 1 iteration of the main ecore loop will be problematic, so avoid it. Also forgetting to unlock may cause the socket process to freeze and thus create odd behaviors.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd" title="Creates a new external ecore evas plug.">ecore_evas_extn_plug_new()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Evas__Extn.html#gac4901fce411947a016d088ebcf4b2eb1" title="Unlocks the pixel data so the socket can change it again.">ecore_evas_extn_plug_object_data_unlock()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2 </dd></dl>

</div>
</div>
<a class="anchor" id="gac4901fce411947a016d088ebcf4b2eb1"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_extn_plug_object_data_unlock" ref="gac4901fce411947a016d088ebcf4b2eb1" args="(Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Evas__Extn.html#gac4901fce411947a016d088ebcf4b2eb1">ecore_evas_extn_plug_object_data_unlock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks the pixel data so the socket can change it again. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The image object returned by <a class="el" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd" title="Creates a new external ecore evas plug.">ecore_evas_extn_plug_new()</a> to unlock</td></tr>
  </table>
  </dd>
</dl>
<p>This unlocks after an advisor lock has been taken by <a class="el" href="group__Ecore__Evas__Extn.html#ga4712ba3c3b6abc99328df350c94805f1" title="Locks the pixel data so the socket cannot change it.">ecore_evas_extn_plug_object_data_lock()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd" title="Creates a new external ecore evas plug.">ecore_evas_extn_plug_new()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Evas__Extn.html#ga4712ba3c3b6abc99328df350c94805f1" title="Locks the pixel data so the socket cannot change it.">ecore_evas_extn_plug_object_data_lock()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga911978ab5d5f93976f717349f8775837"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_extn_socket_events_block_get" ref="ga911978ab5d5f93976f717349f8775837" args="(Ecore_Evas *ee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Evas__Extn.html#ga911978ab5d5f93976f717349f8775837">ecore_evas_extn_socket_events_block_get</a> </td>
          <td>(</td>
          <td class="paramtype">Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the blocking about mouse events to Ecore Evas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The blocking about mouse events.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Evas__Extn.html#gaefb9aa8be25ef61b084adc7d07e6b5c4" title="Sets the blocking about mouse events to Ecore Evas.">ecore_evas_extn_socket_events_block_set()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.15 </dd></dl>

</div>
</div>
<a class="anchor" id="gaefb9aa8be25ef61b084adc7d07e6b5c4"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_extn_socket_events_block_set" ref="gaefb9aa8be25ef61b084adc7d07e6b5c4" args="(Ecore_Evas *ee, Eina_Bool events_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Evas__Extn.html#gaefb9aa8be25ef61b084adc7d07e6b5c4">ecore_evas_extn_socket_events_block_set</a> </td>
          <td>(</td>
          <td class="paramtype">Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>events_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the blocking about mouse events to Ecore Evas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas. </td></tr>
    <tr><td class="paramname">events_block</td><td>The blocking about mouse events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Evas__Extn.html#ga911978ab5d5f93976f717349f8775837" title="Gets the blocking about mouse events to Ecore Evas.">ecore_evas_extn_socket_events_block_get()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.15 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa0319ad5830dc464e8d83708b9158830"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_extn_socket_listen" ref="gaa0319ad5830dc464e8d83708b9158830" args="(Ecore_Evas *ee, const char *svcname, int svcnum, Eina_Bool svcsys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Evas__Extn.html#gaa0319ad5830dc464e8d83708b9158830">ecore_evas_extn_socket_listen</a> </td>
          <td>(</td>
          <td class="paramtype">Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>svcname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>svcnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>svcsys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a socket to provide the service for external ecore evas socket. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas. </td></tr>
    <tr><td class="paramname">svcname</td><td>The name of the service to be advertised. ensure that it is unique (when combined with <code>svcnum</code>) otherwise creation may fail. </td></tr>
    <tr><td class="paramname">svcnum</td><td>A number (any value, <code>0</code> being the common default) to differentiate multiple instances of services with the same name. </td></tr>
    <tr><td class="paramname">svcsys</td><td>A boolean that if true, specifies to create a system-wide service all users can connect to, otherwise the service is private to the user ide that created the service. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> if creation is successful, <code>EINA_FALSE</code> if it does not.</dd></dl>
<p>This creates socket specified by <code>svcname</code>, <code>svcnum</code> and <code>svcsys</code>. If creation is successful, <code>EINA_TRUE</code> is returned or <code>EINA_FALSE</code> if creation fails.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Evas__Extn.html#gae1e73d6b5093135d6a672139692b254d" title="Creates a new Ecore_Evas canvas for the new external ecore evas socket.">ecore_evas_extn_socket_new()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd" title="Creates a new external ecore evas plug.">ecore_evas_extn_plug_new()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Evas__Extn.html#ga4712ba3c3b6abc99328df350c94805f1" title="Locks the pixel data so the socket cannot change it.">ecore_evas_extn_plug_object_data_lock()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Evas__Extn.html#gac4901fce411947a016d088ebcf4b2eb1" title="Unlocks the pixel data so the socket can change it again.">ecore_evas_extn_plug_object_data_unlock()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2 </dd></dl>

</div>
</div>
<a class="anchor" id="gae1e73d6b5093135d6a672139692b254d"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_extn_socket_new" ref="gae1e73d6b5093135d6a672139692b254d" args="(int w, int h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ecore_Evas* <a class="el" href="group__Ecore__Evas__Extn.html#gae1e73d6b5093135d6a672139692b254d">ecore_evas_extn_socket_new</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new Ecore_Evas canvas for the new external ecore evas socket. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The width of the canvas, in pixels </td></tr>
    <tr><td class="paramname">h</td><td>The height of the canvas, in pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new <code>Ecore_Evas</code> instance, or <code>NULL</code> on failure</dd></dl>
<p>This creates a new extn_socket canvas wrapper, with image data array <b>bound</b> to the ARGB format, 8 bits per pixel.</p>
<p>If creation is successful, an Ecore_Evas handle is returned or <code>NULL</code> if creation fails. Also focus, show, hide etc. callbacks will also be called if the plug object is shown, or already visible on connect, or if it is hidden later, focused or unfocused.</p>
<p>This function has to be followed by <a class="el" href="group__Ecore__Evas__Extn.html#gaa0319ad5830dc464e8d83708b9158830" title="Creates a socket to provide the service for external ecore evas socket.">ecore_evas_extn_socket_listen()</a>, for starting ecore ipc service.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> res = <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>;
 Ecore_Evas *ee = <a class="code" href="group__Ecore__Evas__Extn.html#gae1e73d6b5093135d6a672139692b254d" title="Creates a new Ecore_Evas canvas for the new external ecore evas socket.">ecore_evas_extn_socket_new</a>(1, 1);

 res = <a class="code" href="group__Ecore__Evas__Extn.html#gaa0319ad5830dc464e8d83708b9158830" title="Creates a socket to provide the service for external ecore evas socket.">ecore_evas_extn_socket_listen</a>(<span class="stringliteral">&quot;svcname&quot;</span>, 1, <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>);
 <span class="keywordflow">if</span> (!res) <span class="keywordflow">return</span>;
 <a class="code" href="group__Ecore__Evas__Group.html#gaab5a6884e3e253bb0de6e9d760f3f9b8" title="Resizes an Ecore_Evas.">ecore_evas_resize</a>(ee, 240, 400);
</pre></div><p>or</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> res = <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>;
 Ecore_Evas *ee = <a class="code" href="group__Ecore__Evas__Extn.html#gae1e73d6b5093135d6a672139692b254d" title="Creates a new Ecore_Evas canvas for the new external ecore evas socket.">ecore_evas_extn_socket_new</a>(240, 400);

 res = <a class="code" href="group__Ecore__Evas__Extn.html#gaa0319ad5830dc464e8d83708b9158830" title="Creates a socket to provide the service for external ecore evas socket.">ecore_evas_extn_socket_listen</a>(<span class="stringliteral">&quot;svcname&quot;</span>, 1, <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>);
 <span class="keywordflow">if</span> (!res) <span class="keywordflow">return</span>;
</pre></div><p>When a client(plug) connects, you will get the ECORE_EVAS_EXTN_CLIENT_ADD event in the ecore event queue, with event_info being the image object pointer passed as a void pointer. When a client disconnects you will get the ECORE_EVAS_EXTN_CLIENT_DEL event.</p>
<p>You can set up event handles for these events as follows:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> client_add_cb(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> event, <span class="keywordtype">void</span> *event_info)
 {
    Ecore_Evas *ee = event_info;
    printf(<span class="stringliteral">&quot;client is connected to external socket %p\n&quot;</span>, ee);
    <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga6a2922b8aa10c60f27c8ab49d84d75f2">ECORE_CALLBACK_PASS_ON</a>;
 }

 <span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> client_del_cb(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> event, <span class="keywordtype">void</span> *event_info)
 {
    Ecore_Evas *ee = event_info;
    printf(<span class="stringliteral">&quot;client is disconnected from external socket %p\n&quot;</span>, ee);
    <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga6a2922b8aa10c60f27c8ab49d84d75f2">ECORE_CALLBACK_PASS_ON</a>;
 }

 <span class="keywordtype">void</span> setup(<span class="keywordtype">void</span>)
 {
    <a class="code" href="group__Ecore__Event__Group.html#gae75b0b1b2c50e73b8e42afc628b00a62" title="Adds an event handler.">ecore_event_handler_add</a>(<a class="code" href="group__Ecore__Evas__Extn.html#ga3b3e12d2f8273a05662e97475fba9824">ECORE_EVAS_EXTN_CLIENT_ADD</a>,
                           client_add_cb, NULL);
    <a class="code" href="group__Ecore__Event__Group.html#gae75b0b1b2c50e73b8e42afc628b00a62" title="Adds an event handler.">ecore_event_handler_add</a>(<a class="code" href="group__Ecore__Evas__Extn.html#ga64f52548432484d5257c00bd83617fef">ECORE_EVAS_EXTN_CLIENT_DEL</a>,
                           client_del_cb, NULL);
 }
</pre></div><p>Note that events come in later after the event happened. You may want to be careful as data structures you had associated with the image object may have been freed after deletion, but the object may still be around awaiting cleanup and thus still be valid.You can change the size with something like:</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Evas__Extn.html#gaa0319ad5830dc464e8d83708b9158830" title="Creates a socket to provide the service for external ecore evas socket.">ecore_evas_extn_socket_listen()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Evas__Extn.html#ga43099d8b735779aa6f16c38ddd2704fd" title="Creates a new external ecore evas plug.">ecore_evas_extn_plug_new()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Evas__Extn.html#ga4712ba3c3b6abc99328df350c94805f1" title="Locks the pixel data so the socket cannot change it.">ecore_evas_extn_plug_object_data_lock()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Evas__Extn.html#gac4901fce411947a016d088ebcf4b2eb1" title="Unlocks the pixel data so the socket can change it again.">ecore_evas_extn_plug_object_data_unlock()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2 </dd></dl>

</div>
</div>
<a class="anchor" id="gadd0a1d64b1f973f00a8ca871dbf941cd"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_obscured_get" ref="gadd0a1d64b1f973f00a8ca871dbf941cd" args="(const Ecore_Evas *ee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Evas__Extn.html#gadd0a1d64b1f973f00a8ca871dbf941cd">ecore_evas_obscured_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query if the ecore evas is obscured or unobscured. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EINA_TRUE if the ecore evas is obscured, EINA_FALSE unobscured. </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Support for this depends on the underlying windowing system.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.16 </dd></dl>

</div>
</div>
<a class="anchor" id="gae3ede621f9aad43e903273683562b4dd"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_pixmap_colormap_get" ref="gae3ede621f9aad43e903273683562b4dd" args="(const Ecore_Evas *ee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="group__Ecore__Evas__Extn.html#gae3ede621f9aad43e903273683562b4dd">ecore_evas_pixmap_colormap_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the Colormap used for pixmap creation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas containing the pixmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Colormap which was used when creating the pixmap</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If and when this function is called depends on the underlying windowing system. This function should only be called if the Ecore_Evas was created using <code>ecore_evas_software_x11_pixmap_new</code> or <code>ecore_evas_gl_x11_pixmap_new</code> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa27b0990d5117be1ac96a13991cfd86a"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_pixmap_depth_get" ref="gaa27b0990d5117be1ac96a13991cfd86a" args="(const Ecore_Evas *ee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Evas__Extn.html#gaa27b0990d5117be1ac96a13991cfd86a">ecore_evas_pixmap_depth_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the depth used for pixmap creation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas containing the pixmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The depth which was used when creating the pixmap</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If and when this function is called depends on the underlying windowing system. This function should only be called if the Ecore_Evas was created using <code>ecore_evas_software_x11_pixmap_new</code> or <code>ecore_evas_gl_x11_pixmap_new</code> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8 </dd></dl>

</div>
</div>
<a class="anchor" id="ga80a58570553d8a6a6a9a9ff436d884ab"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_pixmap_visual_get" ref="ga80a58570553d8a6a6a9a9ff436d884ab" args="(const Ecore_Evas *ee)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Evas__Extn.html#ga80a58570553d8a6a6a9a9ff436d884ab">ecore_evas_pixmap_visual_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the Visual used for pixmap creation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas containing the pixmap </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Visual which was used when creating the pixmap</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If and when this function is called depends on the underlying windowing system. This function should only be called if the Ecore_Evas was created using <code>ecore_evas_software_x11_pixmap_new</code> or <code>ecore_evas_gl_x11_pixmap_new</code> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8 </dd></dl>

</div>
</div>
<a class="anchor" id="gae200e55fd2250714a98af30854ac634e"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_pointer_device_xy_get" ref="gae200e55fd2250714a98af30854ac634e" args="(const Ecore_Evas *ee, const Efl_Input_Device *pointer, Evas_Coord *x, Evas_Coord *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Evas__Extn.html#gae200e55fd2250714a98af30854ac634e">ecore_evas_pointer_device_xy_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Efl_Input_Device *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the coordinates of the mouse pointer. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas containing the pointer </td></tr>
    <tr><td class="paramname">pointer</td><td>The pointer device, use <code>NULL</code> for the default pointer. </td></tr>
    <tr><td class="paramname">x</td><td>Pointer to integer to store horizontal coordinate. May be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">y</td><td>Pointer to integer to store vertical coordinate. May be <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8012e6eb8c7ed0edb929c403c222eb8"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_pointer_warp" ref="gaa8012e6eb8c7ed0edb929c403c222eb8" args="(const Ecore_Evas *ee, Evas_Coord x, Evas_Coord y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Evas__Extn.html#gaa8012e6eb8c7ed0edb929c403c222eb8">ecore_evas_pointer_warp</a> </td>
          <td>(</td>
          <td class="paramtype">const Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the coordinates of the mouse pointer. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas containing the pointer </td></tr>
    <tr><td class="paramname">x</td><td>The horizontal coordinate to move the pointer to </td></tr>
    <tr><td class="paramname">y</td><td>The vertical coordinate to move the pointer to</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> on success, EINA_FALSE on failure.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga31f1845bb968727b195da44d41aface9"></a><!-- doxytag: member="Ecore_Evas.h::ecore_evas_pointer_xy_get" ref="ga31f1845bb968727b195da44d41aface9" args="(const Ecore_Evas *ee, Evas_Coord *x, Evas_Coord *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Evas__Extn.html#ga31f1845bb968727b195da44d41aface9">ecore_evas_pointer_xy_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Ecore_Evas *&#160;</td>
          <td class="paramname"><em>ee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Coord *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the coordinates of the default mouse pointer. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ee</td><td>The Ecore_Evas containing the pointer </td></tr>
    <tr><td class="paramname">x</td><td>Pointer to integer to store horizontal coordinate. May be <code>NULL</code>. </td></tr>
    <tr><td class="paramname">y</td><td>Pointer to integer to store vertical coordinate. May be <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Evas__Extn.html#gae200e55fd2250714a98af30854ac634e" title="Retrieves the coordinates of the mouse pointer.">ecore_evas_pointer_device_xy_get</a> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga3b3e12d2f8273a05662e97475fba9824"></a><!-- doxytag: member="Ecore_Evas.h::ECORE_EVAS_EXTN_CLIENT_ADD" ref="ga3b3e12d2f8273a05662e97475fba9824" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Evas__Extn.html#ga3b3e12d2f8273a05662e97475fba9824">ECORE_EVAS_EXTN_CLIENT_ADD</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>this event is received when a plug has connected to an extn socket </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga64f52548432484d5257c00bd83617fef"></a><!-- doxytag: member="Ecore_Evas.h::ECORE_EVAS_EXTN_CLIENT_DEL" ref="ga64f52548432484d5257c00bd83617fef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Evas__Extn.html#ga64f52548432484d5257c00bd83617fef">ECORE_EVAS_EXTN_CLIENT_DEL</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>this event is received when a plug has disconnected from an extn socket </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.2 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
