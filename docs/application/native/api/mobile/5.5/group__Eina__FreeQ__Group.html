<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Free Queue Group</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.5</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Eina__FreeQ__Group.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<div class="title">Free Queue Group</div>  </div>
<div class="ingroups"><a class="el" href="group__Eina.html">Eina</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>This provides a mechanism to defer actual freeing of memory data at some time in the future. The main free queue will be driven by the EFL main loop and ensure data is eventually freed. </p>
<p>For debugging and tuning you may set the following environment variables, applicable only to free queues of the default type:</p>
<p>EINA_FREEQ_BYPASS=1/0</p>
<p>Set this environment variable to 1 to immediately bypass the free queue and have all items submitted free with their free function immediately. Set it to 0 to force the free queue to work and delay freeing of items. Note that you can override this by setting count or mem max by eina_freeq_count_max_set() or eina_freeq_mem_max_set() which will disable bypass for that specific free queue. Once bypass is disabled it cannot be re-enabled.</p>
<p>EINA_FREEQ_FILL_MAX=N</p>
<p>This sets the maximum number of bytes to N an item in the free queue may be in size for the free queue to fill it with debugging values like 0x55 in every byte, to ensure you can see what memory has been freed or not when debugging in tools like gdb. Note that this value is actually one greater than the actual maximum, so if this is set to 100 a memory blob of 100 bytes will not be filled but one of 99 bytes in size will be.</p>
<p>EINA_FREEQ_TOTAL_MAX=N</p>
<p>This sets the maximum number of items allowed to N on a free queue by default before it starts emptying the free queue out to make room.</p>
<p>EINA_FREEQ_MEM_MAX=N</p>
<p>This sets the maximum total number of Kb (Kilobytes) of memory allowed on a free queue by default to N Kb worth of data.</p>
<p>EINA_FREEQ_FILL=N</p>
<p>This sets the byte value to write to every byte of an allocation that is added to the free queue when it is added to mark the data as invalid. The default value is 0x55 (85). Memory is only filled if the size of the allocation is less than the max that you can adjust with EINA_FREEQ_FILL_MAX.</p>
<p>EINA_FREEQ_FILL_FREED=N</p>
<p>Memory just before it is actually passed to the free function to be freed will be filled with this pattern value in every byte. The default value is 0x77 (119). Memory is only filled if the size of the allocation is less than the max that you can adjust with EINA_FREEQ_FILL_MAX.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__FreeQ__Group.html#gaa950e27974a73908ef81a2bb20cf94c7">Eina_FreeQ</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__FreeQ__Group.html#ga11585a5f2b77a18bcb87b0587e91953d">eina_freeq_main_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new free queue to defer freeing of data with.  <a href="#ga11585a5f2b77a18bcb87b0587e91953d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__FreeQ__Group.html#gaacfa4ac2eee628ec39fdbeac7d5f7ad2">eina_freeq_ptr_add</a> (<a class="el" href="group__Eina__FreeQ__Group.html#gaa950e27974a73908ef81a2bb20cf94c7">Eina_FreeQ</a> *fq, void *ptr, void(*free_func)(void *ptr), size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of free pointers this queue is allowed.  <a href="#gaacfa4ac2eee628ec39fdbeac7d5f7ad2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__FreeQ__Group.html#gafe655be65cbf4f01310c2147c22f2c92">eina_freeq_ptr_main_add</a> (void *ptr, void(*free_func)(void *ptr), size_t size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pointer to the main free queue.  <a href="#gafe655be65cbf4f01310c2147c22f2c92"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct _Eina_FreeQ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__FreeQ__Group.html#gaa950e27974a73908ef81a2bb20cf94c7">Eina_FreeQ</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__Eina__FreeQ__Group.html#ga52c4eb7c091de64d45dc7a97c650eff4">_Eina_FreeQ_Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__FreeQ__Group.html#ga44f16e906e526dfb536faa5a5239d6b1">Eina_FreeQ_Type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of free queues.  <a href="#ga44f16e906e526dfb536faa5a5239d6b1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__FreeQ__Group.html#ga1219f0559445ed399a931163736e0a4f">EINA_FREEQ_FREE</a>(ptr)&#160;&#160;&#160;<a class="el" href="group__Eina__FreeQ__Group.html#gafe655be65cbf4f01310c2147c22f2c92">eina_freeq_ptr_main_add</a>(ptr, NULL, sizeof(*(ptr)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for well known structures and types.  <a href="#ga1219f0559445ed399a931163736e0a4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__FreeQ__Group.html#ga7997c740db6b46e562ff053b49912188">EINA_FREEQ_N_FREE</a>(ptr, n)&#160;&#160;&#160;<a class="el" href="group__Eina__FreeQ__Group.html#gafe655be65cbf4f01310c2147c22f2c92">eina_freeq_ptr_main_add</a>(ptr, NULL, sizeof(*(ptr)) * n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro for well known structures and types.  <a href="#ga7997c740db6b46e562ff053b49912188"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga1219f0559445ed399a931163736e0a4f"></a><!-- doxytag: member="eina_freeq.h::EINA_FREEQ_FREE" ref="ga1219f0559445ed399a931163736e0a4f" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Eina__FreeQ__Group.html#ga1219f0559445ed399a931163736e0a4f">EINA_FREEQ_FREE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__Eina__FreeQ__Group.html#gafe655be65cbf4f01310c2147c22f2c92">eina_freeq_ptr_main_add</a>(ptr, NULL, sizeof(*(ptr)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience macro for well known structures and types. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer to free</td></tr>
  </table>
  </dd>
</dl>
<p>This is the same as <a class="el" href="group__Eina__FreeQ__Group.html#gafe655be65cbf4f01310c2147c22f2c92" title="Add a pointer to the main free queue.">eina_freeq_ptr_main_add()</a> but the free function is assumed to be the libc free() function, and size is provided by sizeof(*ptr), so it will not work on void pointers or will be inaccurate for pointers to arrays. For arrays please use EINA_FREEQ_ARRAY_FREE()</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7997c740db6b46e562ff053b49912188"></a><!-- doxytag: member="eina_freeq.h::EINA_FREEQ_N_FREE" ref="ga7997c740db6b46e562ff053b49912188" args="(ptr, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Eina__FreeQ__Group.html#ga7997c740db6b46e562ff053b49912188">EINA_FREEQ_N_FREE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__Eina__FreeQ__Group.html#gafe655be65cbf4f01310c2147c22f2c92">eina_freeq_ptr_main_add</a>(ptr, NULL, sizeof(*(ptr)) * n)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience macro for well known structures and types. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer to free</td></tr>
  </table>
  </dd>
</dl>
<p>This is the same as <a class="el" href="group__Eina__FreeQ__Group.html#gafe655be65cbf4f01310c2147c22f2c92" title="Add a pointer to the main free queue.">eina_freeq_ptr_main_add()</a> but the free function is assumed to be the libc free() function, and size is provided by sizeof(*ptr), so it will not work on void pointers. Total size is multiplied by the count <code>n</code> so it should work well for arrays of types.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaa950e27974a73908ef81a2bb20cf94c7"></a><!-- doxytag: member="eina_freeq.h::Eina_FreeQ" ref="gaa950e27974a73908ef81a2bb20cf94c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__FreeQ__Group.html#gaa950e27974a73908ef81a2bb20cf94c7">Eina_FreeQ</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A queue of pointers to free in the future. You may create custom free queues of your own to defer freeing, use the main free queue where the mainloop will free things as it iterates, or eina will free everything on shut down. </p>

</div>
</div>
<a class="anchor" id="ga44f16e906e526dfb536faa5a5239d6b1"></a><!-- doxytag: member="eina_freeq.h::Eina_FreeQ_Type" ref="ga44f16e906e526dfb536faa5a5239d6b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__Eina__FreeQ__Group.html#ga52c4eb7c091de64d45dc7a97c650eff4">_Eina_FreeQ_Type</a>  <a class="el" href="group__Eina__FreeQ__Group.html#ga44f16e906e526dfb536faa5a5239d6b1">Eina_FreeQ_Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of free queues. </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga52c4eb7c091de64d45dc7a97c650eff4"></a><!-- doxytag: member="eina_freeq.h::_Eina_FreeQ_Type" ref="ga52c4eb7c091de64d45dc7a97c650eff4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Eina__FreeQ__Group.html#ga52c4eb7c091de64d45dc7a97c650eff4">_Eina_FreeQ_Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of free queues. </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga52c4eb7c091de64d45dc7a97c650eff4a38a3a01f7a20cb8102d7747998118372"></a><!-- doxytag: member="EINA_FREEQ_DEFAULT" ref="gga52c4eb7c091de64d45dc7a97c650eff4a38a3a01f7a20cb8102d7747998118372" args="" -->EINA_FREEQ_DEFAULT</em>&nbsp;</td><td>
<p>Default type of free queue. </p>
<p>Default free queue, any object added to it should be considered freed immediately. Use this kind of freeq for debugging and additional memory safety purposes only.</p>
<p>As this type of free queue is thread-safe, the free functions used must also be thread-safe (e.g.. libc free()).</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga52c4eb7c091de64d45dc7a97c650eff4ad991b1175049f0befd977324e79e73cd"></a><!-- doxytag: member="EINA_FREEQ_POSTPONED" ref="gga52c4eb7c091de64d45dc7a97c650eff4ad991b1175049f0befd977324e79e73cd" args="" -->EINA_FREEQ_POSTPONED</em>&nbsp;</td><td>
<p>Postponed type of free queue. </p>
<p>Postponed free queues behave differently in that objects added to it are not to be considered freed immediately, but rather they are short-lived. Use this to return temporary objects that may be used only in the local scope. The queued objects lifetime ends as soon as the execution comes back to the loop. Objects added to this kind of free queue should be accessed exclusively from the same thread that adds them.</p>
<p>If a thread does not have a loop attached, the application may leak all those objects. At the moment of writing this means only the main loop should use such a free queue.</p>
<p>By default those queues have no memory limit, and will be entirely flushed when the execution comes back to the loop.</p>
<p>This type of free queue is not thread-safe and should be considered local to a single thread.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga11585a5f2b77a18bcb87b0587e91953d"></a><!-- doxytag: member="eina_freeq.h::eina_freeq_main_get" ref="ga11585a5f2b77a18bcb87b0587e91953d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__FreeQ__Group.html#gaa950e27974a73908ef81a2bb20cf94c7">Eina_FreeQ</a>* <a class="el" href="group__Eina__FreeQ__Group.html#ga11585a5f2b77a18bcb87b0587e91953d">eina_freeq_main_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new free queue to defer freeing of data with. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new free queue </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Free a free queue and anything that is queued in it.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fq</td><td>The free queue to free and clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Query the type of a free queue.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fq</td><td>The free queue to inspect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Get the main loop free queue.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The main loop free queue.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gaacfa4ac2eee628ec39fdbeac7d5f7ad2"></a><!-- doxytag: member="eina_freeq.h::eina_freeq_ptr_add" ref="gaacfa4ac2eee628ec39fdbeac7d5f7ad2" args="(Eina_FreeQ *fq, void *ptr, void(*free_func)(void *ptr), size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Eina__FreeQ__Group.html#gaacfa4ac2eee628ec39fdbeac7d5f7ad2">eina_freeq_ptr_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__FreeQ__Group.html#gaa950e27974a73908ef81a2bb20cf94c7">Eina_FreeQ</a> *&#160;</td>
          <td class="paramname"><em>fq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *ptr)&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum number of free pointers this queue is allowed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fq</td><td>The free queue to alter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of items allowed, negative values mean no limit</td></tr>
  </table>
  </dd>
</dl>
<p>This will alter the maximum number of pointers allowed in the given free queue. If more items are added to the free queue than are allowed, excess items will be freed to make room for the new items. If count is changed, then excess items may be cleaned out at the time this API is called.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Setting a maximum count on a postponed free queue leads to undefined behavior.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Get the maximum number of free pointers this queue is allowed</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fq</td><td>The free queue to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum number of free items allowed or -1 for infinity</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Set the maximum amount of memory allowed</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fq</td><td>The free queue to alter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem</td><td>The maximum memory in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>This will alter the maximum amount of memory allowed for pointers stored in the free queue. The size used is the size give, so items given that are 0 sized will not contribute to this limit. If items with a total memory footprint are added to the free queue, items will be cleaned out until the total is below this limit. Changing the limit may involve cleaning out excess items from the free queue until the total amount of memory used by items in the queue is below or at the limit.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Setting a memory limit on a postponed free queue leads to undefined behavior.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Get the maximum amount of memory allowed</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fq</td><td>The free queue to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum amount of memory in bytes</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Clear out all queued items to be freed by freeing them</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fq</td><td>The free queue to clear</td></tr>
  </table>
  </dd>
</dl>
<p>This will free and thus remove all queued items from the free queue when this function is called. When it returns the free queue should be empty.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Reduce the number of items in the free queue by up to <code>count</code> </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fq</td><td>The free queue to reduce in item count </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of items to try and free</td></tr>
  </table>
  </dd>
</dl>
<p>This will attempt to free up to <code>count</code> items from the given free queue and thus reduce the amount of memory it is holding on to. This function will return once it has removed <code>count</code> items or there are no more items to remove from the queue.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Return if there are any items pending a free in the free queue</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fq</td><td>The free queue to query  EINA_TRUE if there are items to free, EINA_FALSE otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>Add a pointer with free function and size to the free queue</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fq</td><td>The free queue to add the pointer to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer to free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_func</td><td>The function used to free the pointer with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the data the pointer points to</td></tr>
  </table>
  </dd>
</dl>
<p>This adds the given <code>ptr</code> pointer to the queue to be freed later on. The function <code>free_func</code> will be used, or if this is NULL, it is assumed the libc free() function will be used then instead. The <code>size</code> parameter determines the size of the data pointed to, but if this is 0 then no assumptions are made about size and the pointer is considered opaque. A zero sized pointer will not contribute to the total memory usage of items in the queue as well. If <code>size</code> is supplied it must be correct as the memory may be written to for debugging purposes or otherwise inspected or checksummed. Once a pointer is added to the free queue with this API the memory should be considered freed as if the real <code>free_func</code> was called immediately (and it may actually be called immediately if certain environment variables are set). A free queue exists to move the cost of freeing to another point in time when it is more convenient to do so as well as provide some robustness for badly written code that may access memory after freeing. Note that when using tools like valgrind, eina detects this and will also immediately free the data so valgrind's own memory checkers can detect use after free as normal.</p>
<p>Note: The free function must not access the CONTENT of the memory to be freed, or at least consider it invalid and full of garbage. It is already invalid at the moment it is added to the free queue. Just the actual free function may be delayed. The free function may also not access other memory already freed before being added to the free queue. They may do tricks like use memory headers that are outside the memory region to be freed (pass in pointer char *x, then char *header_address = x - 16 to get header information) as this header is not considered part of the free data. This note does not apply if you use a size of 0 for the pointer, but then you lose canary debugging ability when using 0 sized pointers on the free queue.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gafe655be65cbf4f01310c2147c22f2c92"></a><!-- doxytag: member="eina_freeq.h::eina_freeq_ptr_main_add" ref="gafe655be65cbf4f01310c2147c22f2c92" args="(void *ptr, void(*free_func)(void *ptr), size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__Eina__FreeQ__Group.html#gafe655be65cbf4f01310c2147c22f2c92">eina_freeq_ptr_main_add</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *ptr)&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a pointer to the main free queue. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer to free </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_func</td><td>The function used to free the pointer with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the data the pointer points to</td></tr>
  </table>
  </dd>
</dl>
<p>This is the same as <a class="el" href="group__Eina__FreeQ__Group.html#gaacfa4ac2eee628ec39fdbeac7d5f7ad2" title="Set the maximum number of free pointers this queue is allowed.">eina_freeq_ptr_add()</a> but the main free queue is fetched by <a class="el" href="group__Eina__FreeQ__Group.html#ga11585a5f2b77a18bcb87b0587e91953d" title="Create a new free queue to defer freeing of data with.">eina_freeq_main_get()</a>.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.19 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd></dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
