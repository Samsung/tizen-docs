<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Evas</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.5</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('evas_main.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Evas </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="date"><dt><b>Date:</b></dt><dd>2000 (created)</dd></dl>
<h2><a class="anchor" id="toc"></a>
Table of Contents</h2>
<ul>
<li><a class="el" href="evas_main.html#evas_main_intro">Introduction</a> </li>
<li><a class="el" href="evas_main.html#evas_main_work">How does Evas work?</a> </li>
<li><a class="el" href="evas_main.html#evas_main_compiling">How to compile the library</a> </li>
<li><a class="el" href="evas_main.html#evas_main_next_steps">Recommended reading</a> </li>
<li><a class="el" href="evas_main.html#evas_main_intro_example">Introductory Example</a></li>
</ul>
<h2><a class="anchor" id="evas_main_intro"></a>
Introduction</h2>
<p>Evas is a clean display canvas API for several target display systems that can draw anti-aliased text, smooth super- and sub-sampled scaled images, alpha-blend objects and more.</p>
<p>It abstracts the graphics drawing characteristics of the display system by implementing a canvas where graphical objects can be created, manipulated, and modified. It then handles the rendering pipeline in an optimal way for the underlying device in order to minimize redraws, via a programmatically efficient API.</p>
<p>A design goal for the system is to run well at both small and large scale, and be portable from embedded systems to multi-CPU workstations. Architecturally, this is achieved via 'backends' that provide the specialized display logic for specific devices. As well, there are various compile options to exclude feature support not required for a target platform to help minimize disk and memory requirements.</p>
<p>Evas can serve as a base for widget sets or toolkits (e.g. Elementary, <a href="http://docs.enlightenment.org/auto/elementary/">http://docs.enlightenment.org/auto/elementary/</a>) by handling pixel drawing and regional change reporting, but does not manage windows itself, nor deal with input or window update event propagation. In other words, it is intended for use in drawing scrollbars, sliders, and push buttons but not for high-level logic of how the widget operates and behaves. Under Enlightenment, window and widget management is handled by other software components, including <a class="el" href="group__Ecore.html">Ecore</a> (see <a class="el" href="group__Ecore__Evas__Group.html">Ecore_Evas wrapper/helper set of functions</a> in particular); however Evas is designed to not be dependent on any particular main loop architecture, and also strives to be input and output system agnostic.</p>
<p>Evas can be seen as a display system that stands somewhere between a widget set and an immediate mode display system. It retains basic display logic, but does very little high-level logic such as scrollbars, sliders, and push buttons.</p>
<h2><a class="anchor" id="evas_main_work"></a>
How does Evas work?</h2>
<p>The Evas canvas is a 'retained mode' renderer, which differs from the more traditional 'immediate mode' display and windowing systems by tracking drawing state information of its contained objects.</p>
<p>In an immediate mode rendering system, each frame is drawn from scratch by having each drawing element redraw itself. Once the commands are executed, the display system blits the frame to the screen but has no idea how to reproduce the image again, so the application has to run through the same sequence of drawing commands again. Very little or no state is kept from one frame draw to the next; while this is simple it forces each application to manually optimize their graphics code.</p>
<p>With retained mode systems like Evas, the application does not need to implement the display rendering code and associated logic, but merely updates the list of objects maintained in the canvas. Evas is then able to optimize the processing and rendering of the visible elements, and is better able to avoid redraws due to occlusion or opacity.</p>
<p>Evas is a structural system in which the programmer creates and manages display objects and their properties, and as a result of this higher level state management, the canvas is able to redraw the set of objects when needed to represent the current state of the canvas.</p>
<p>For example, consider the pseudo code:</p>
<div class="fragment"><pre class="fragment">
   line_handle = create_line();
   set line_handle from position (0, 0) to position (100, 200);
   show line_handle;

   rectangle_handle = create_rectangle();
   move rectangle_handle to position (10, 30);
   resize rectangle_handle to size 40 x 470;
   show rectangle_handle;

   bitmap_handle = create_bitmap();
   scale bitmap_handle to size 100 x 100;
   move bitmap_handle to position (10, 30);
   show bitmap_handle;

   render scene;
   </pre></div><p>By expressing the drawing as a set of drawable objects, Evas is able to internally handle refreshing, updating, moving, resizing, showing, and hiding the objects, and to determine to most efficiently redraw the canvas and its contents to reflect the current state. This permits the application to focus on the higher level logic, which both reduces the amount of coding and allows a more natural way of dealing with the display. Importantly, abstracting the display logic like this also simplifies porting the application to different display systems, since its own code is less tied into how that system works.</p>
<h2><a class="anchor" id="evas_main_compiling"></a>
How to compile the library</h2>
<p>Evas compiles automatically within EFL's build system, and is automatically linked with <a class="el" href="group__Ecore.html">Ecore</a> and other components that need it. But it can also be built and used standalone, by compiling and linking your application with the compiler flags indicated by <code>pkg-config</code>. For example:</p>
<div class="fragment"><pre class="fragment">
   gcc -c -o my_main.o my_main.c `pkg-config --cflags evas`

   gcc -o my_application my_main.o `pkg-config --libs evas`
   </pre></div><p>See <a class="el" href="pkgconfig.html">pkgconfig</a></p>
<h2><a class="anchor" id="evas_main_next_steps"></a>
Recommended reading</h2>
<ul>
<li><a class="el" href="group__Ecore.html">Ecore</a>, <a class="el" href="group__Edje.html">Edje</a>, and <a class="el" href="group__Elementary.html">Elementary</a> that provide higher level infrastructure and components for real world usage. </li>
<li><a class="el" href="group__Evas__Object__Group.html">Generic Object Functions</a> for how to manipulate generic objects on an Evas canvas and handle the associated events. </li>
<li><a class="el" href="group__Evas__Object__Rectangle.html">Rectangle Object Functions</a>, to learn about the most basic object type on Evas -- the rectangle. </li>
<li><a class="el" href="group__Evas__Object__Polygon.html">Polygon Object Functions</a>, to learn how to create polygon elements on the canvas. </li>
<li><a class="el" href="group__Evas__Line__Group.html">Line Object Functions</a>, to learn how to create line elements on the canvas. </li>
<li><a class="el" href="group__Evas__Object__Image.html">Image Object Functions</a>, to learn about image objects, over which Evas can do a plethora of operations. </li>
<li><a class="el" href="group__Evas__Object__Text.html">Text Object Functions</a>, to learn how to create textual elements on the canvas. </li>
<li><a class="el" href="group__Evas__Object__Textblock.html">Textblock Object Functions</a>, to learn how to create multiline textual elements on the canvas.</li>
</ul>
<ul>
<li><a class="el" href="group__Evas__Smart__Object__Group.html">Smart Object Functions</a> and <a class="el" href="group__Evas__Smart__Group.html">Smart Functions</a>, to define new objects that provide <b>custom</b> functions to handle clipping, hiding, moving, resizing, color setting and more. This includes simple grouping of objects that move together (see <a class="el" href="group__Evas__Smart__Object__Clipped.html">Clipped Smart Object</a>) and more complex widget-like intelligent behaviors such as buttons and check boxes.</li>
</ul>
<h2><a class="anchor" id="evas_main_intro_example"></a>
Introductory Example</h2>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;Evas.h&gt;</span>
<span class="preprocessor">#include &lt;Evas_Engine_Buffer.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;errno.h&gt;</span>

<span class="preprocessor">#define WIDTH (320)</span>
<span class="preprocessor"></span><span class="preprocessor">#define HEIGHT (240)</span>
<span class="preprocessor"></span>
<span class="keyword">static</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *create_canvas(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height);
<span class="keyword">static</span> <span class="keywordtype">void</span> destroy_canvas(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas);
<span class="keyword">static</span> <span class="keywordtype">void</span> draw_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas);
<span class="keyword">static</span> <span class="keywordtype">void</span> save_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas, <span class="keyword">const</span> <span class="keywordtype">char</span> *dest);

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *bg, *r1, *r2, *r3;

   <a class="code" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init</a>();

   <span class="comment">/* After turning Evas on, we create an Evas canvas to work in.</span>
<span class="comment">    * Canvases are graphical workspaces used for placing and organizing</span>
<span class="comment">    * graphical objects.  Normally we&#39;d be using Ecore-Evas to create</span>
<span class="comment">    * the canvas, but for this example we&#39;ll hide the details in a</span>
<span class="comment">    * separate routine for convenience.</span>
<span class="comment">    */</span>
   canvas = create_canvas(WIDTH, HEIGHT);
   <span class="keywordflow">if</span> (!canvas)
     <span class="keywordflow">return</span> -1;

   <span class="comment">/* Next set the background to solid white.  This is typically done by</span>
<span class="comment">    * creating a rectangle sized to the canvas, placed at the canvas</span>
<span class="comment">    * origin.</span>
<span class="comment">    *</span>
<span class="comment">    * Note that if the canvas were to change size, our background</span>
<span class="comment">    * rectangle will not automatically resize itself; we&#39;d need to do</span>
<span class="comment">    * that manually with another evas_object_resize() call.  In a real</span>
<span class="comment">    * application using Ecore-Evas, functionality in Ecore will take</span>
<span class="comment">    * care of resizing things.  For this example, we&#39;ll just keep the</span>
<span class="comment">    * canvas dimensions fixed to avoid the problem.</span>
<span class="comment">    */</span>
   bg = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(bg, 255, 255, 255, 255); <span class="comment">// white bg, no transparency</span>
   evas_object_move(bg, 0, 0);                    <span class="comment">// at origin</span>
   evas_object_resize(bg, WIDTH, HEIGHT);         <span class="comment">// covers full canvas</span>
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(bg);

   puts(<span class="stringliteral">&quot;initial scene, with just background:&quot;</span>);
   draw_scene(canvas);

   <span class="comment">/* To make the scene interesting let&#39;s add a few more rectangles of</span>
<span class="comment">    * various sizes and colors, starting with a big red one.</span>
<span class="comment">    *</span>
<span class="comment">    * By default all Evas objects are created in a &#39;hidden&#39; state,</span>
<span class="comment">    * meaning they are not visible, won&#39;t be checked for changes during</span>
<span class="comment">    * canvas rendering, and won&#39;t receive input events.  Thus, like we</span>
<span class="comment">    * did for the background object we must call evas_object_show() to</span>
<span class="comment">    * make our graphics objects usable.</span>
<span class="comment">    */</span>
   r1 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r1, 255, 0, 0, 255); <span class="comment">// 100% opaque red</span>
   evas_object_move(r1, 10, 10);
   evas_object_resize(r1, 100, 100);
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r1);

   <span class="comment">/* Let&#39;s add a partly transparent rectangle on top of the red one.</span>
<span class="comment">    *</span>
<span class="comment">    * Graphics objects are treated as a stack in the canvas for drawing</span>
<span class="comment">    * purposes, so subsequent objects are drawn above the ones we&#39;ve</span>
<span class="comment">    * already added to the canvas.  This is important in objects that</span>
<span class="comment">    * have partially transparent fill coloring since we&#39;ll see part of</span>
<span class="comment">    * what&#39;s &quot;behind&quot; our object.</span>
<span class="comment">    *</span>
<span class="comment">    * In Evas, color values are pre-multiplied by their alpha.  This means</span>
<span class="comment">    * that if we want a green rectangle that&#39;s half transparent, we&#39;d have:</span>
<span class="comment">    *</span>
<span class="comment">    * non-premul: r=0, g=255, b=0    a=128 (50% alpha)</span>
<span class="comment">    * premul:</span>
<span class="comment">    *         r_premul = r * a / 255 =      0 * 128 / 255 =      0</span>
<span class="comment">    *         g_premul = g * a / 255 =    255 * 128 / 255 =    128</span>
<span class="comment">    *         b_premul = b * a / 255 =      0 * 128 / 255 =      0</span>
<span class="comment">    *</span>
<span class="comment">    * Since we&#39;re placing our half transparent green rectangle on top of</span>
<span class="comment">    * a red one, in the final output we will actually see a yellow square</span>
<span class="comment">    * (since in RGBA color green + red = yellow).</span>
<span class="comment">    */</span>
   r2 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r2, 0, 128, 0, 128); <span class="comment">// 50% opaque green</span>
   evas_object_move(r2, 10, 10);
   evas_object_resize(r2, 50, 50);
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r2);

   <span class="comment">/* Lastly, for comparison add a dark green rectangle with no</span>
<span class="comment">    * transparency. */</span>
   r3 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r3, 0, 128, 0, 255); <span class="comment">// 100% opaque dark green</span>
   evas_object_move(r3, 60, 60);
   evas_object_resize(r3, 50, 50);
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r3);

   puts(<span class="stringliteral">&quot;final scene (note updates):&quot;</span>);
   draw_scene(canvas);

   <span class="comment">/* In addition to displaying the canvas to the screen, let&#39;s also</span>
<span class="comment">    * output the buffer to a graphics file, for comparison.  Evas</span>
<span class="comment">    * supports a range of graphics file formats, but PPM is particularly</span>
<span class="comment">    * trivial to write, so our save_scene routine will output as PPM.</span>
<span class="comment">    */</span>
   save_scene(canvas, <span class="stringliteral">&quot;/tmp/evas-buffer-simple-render.ppm&quot;</span>);

   destroy_canvas(canvas);

   <a class="code" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09" title="Directly shutdown Evas.">evas_shutdown</a>();

   <span class="keywordflow">return</span> 0;
}

<span class="comment">/* Convenience routine to allocate and initialize the canvas.</span>
<span class="comment"> * In a real application we&#39;d be using ecore_evas_buffer_new() instead.</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *create_canvas(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   Evas_Engine_Info_Buffer *einfo;
   <span class="keywordtype">int</span> method;
   <span class="keywordtype">void</span> *pixels;

   <span class="comment">/* Request a handle for the &#39;buffer&#39; type of rendering engine. */</span>
   method = <a class="code" href="group__Evas__Output__Method.html#ga9f9871fdcc40ce1062d6565308020eb8">evas_render_method_lookup</a>(<span class="stringliteral">&quot;buffer&quot;</span>);
   <span class="keywordflow">if</span> (method &lt;= 0)
     {
    fputs(<span class="stringliteral">&quot;ERROR: evas was not compiled with &#39;buffer&#39; engine!\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Create a general canvas object.</span>
<span class="comment">    * Note that we are responsible for freeing the canvas when we&#39;re done. */</span>
   canvas = <a class="code" href="group__Evas__Canvas.html#ga67e8eb17d2a676bfdfb8794fc5f72bc0">evas_new</a>();
   <span class="keywordflow">if</span> (!canvas)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not instantiate new evas canvas.\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Specify that the canvas will be rendering using the buffer engine method.</span>
<span class="comment">    * We also size the canvas and viewport to the same width and height, with</span>
<span class="comment">    * the viewport set to the origin of the canvas.</span>
<span class="comment">    */</span>
   <a class="code" href="group__Evas__Canvas.html#ga15b85dc673baa6aa40f91f8bfcd3cbaa" title="Sets the output engine for the given evas.">evas_output_method_set</a>(canvas, method);
   <a class="code" href="group__Evas__Canvas.html#gaf6478cb249ed09fa0fe961085773fe1e" title="Sets the output size of the render engine of the given evas.">evas_output_size_set</a>(canvas, width, height);
   <a class="code" href="group__Evas__Canvas.html#ga6dcd13997f7825f03807dc0ec38dd38e" title="Sets the output viewport of the given evas in evas units.">evas_output_viewport_set</a>(canvas, 0, 0, width, height);

   <span class="comment">/* Before we can use the engine, we *must* set its configuration</span>
<span class="comment">    * parameters.  The available parameters are kept in a struct</span>
<span class="comment">    * named Evas_Engine_Info which is internal to Evas.  Thus to set</span>
<span class="comment">    * parameters we must first request the current info object from</span>
<span class="comment">    * our canvas:</span>
<span class="comment">    */</span>
   einfo = (Evas_Engine_Info_Buffer *)<a class="code" href="group__Evas__Canvas.html#gaf396b44e1b97ec0d9dce49fcf9ad54b7" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Create the underlying data buffer that our canvas will use.  This</span>
<span class="comment">    * is a simple array of ARGB32 pixels.  Each color component</span>
<span class="comment">    * (including alpha) is one byte, resulting in 4 bytes per pixel (or</span>
<span class="comment">    * 32 bits).  We can thus store each pixel in an integer data type,</span>
<span class="comment">    * thus calculating our data buffer as W x H x sizeof(int) bytes in</span>
<span class="comment">    * length.</span>
<span class="comment">    */</span>
   pixels = malloc(width * height * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
   <span class="keywordflow">if</span> (!pixels)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not allocate canvas pixels!\n&quot;</span>, stderr);
    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Next set the various configuration parameters.  We</span>
<span class="comment">    * register the pixel buffer that the canvas will use,</span>
<span class="comment">    * indicate the pixel format as ARGB32, and the size of</span>
<span class="comment">    * each row of data. */</span>
   einfo-&gt;info.depth_type = EVAS_ENGINE_BUFFER_DEPTH_ARGB32;
   einfo-&gt;info.dest_buffer = pixels;
   einfo-&gt;info.dest_buffer_row_bytes = width * <span class="keyword">sizeof</span>(int);
   einfo-&gt;info.use_color_key = 0;
   einfo-&gt;info.alpha_threshold = 0;
   einfo-&gt;info.func.new_update_region = NULL;
   einfo-&gt;info.func.free_update_region = NULL;

   <span class="comment">/* Finally, we configure the canvas with our chosen parameters. */</span>
   <a class="code" href="group__Evas__Canvas.html#gae917a8b0d52df622498bbf55357c1af3" title="Applies the engine settings for the given evas from the given Evas_Engine_Info structure.">evas_engine_info_set</a>(canvas, (<a class="code" href="struct__Evas__Engine__Info.html">Evas_Engine_Info</a> *)einfo);

   <span class="keywordflow">return</span> canvas;
}

<span class="comment">/* Convenience routine to shut down the canvas.</span>
<span class="comment"> * In a real application we&#39;d be using ecore_evas_free() instead</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <span class="keywordtype">void</span> destroy_canvas(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas)
{
   Evas_Engine_Info_Buffer *einfo;

   einfo = (Evas_Engine_Info_Buffer *)<a class="code" href="group__Evas__Canvas.html#gaf396b44e1b97ec0d9dce49fcf9ad54b7" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
    <span class="keywordflow">return</span>;
     }

   <span class="comment">/* Free the data buffer we allocated in create_buffer() */</span>
   free(einfo-&gt;info.dest_buffer);

   <span class="comment">/* Finally, free the canvas itself. */</span>
   <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
}

<span class="comment">/* Convenience routine to update the scene.</span>
<span class="comment"> * In a real application Ecore Evas would be doing this for us.</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <span class="keywordtype">void</span> draw_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas)
{
   <a class="code" href="struct__Eina__List.html">Eina_List</a> *updates, *n;
   <a class="code" href="group__Eina__Rectangle__Group.html#gad1f49db9be2cd747f458ebf4718b6228">Eina_Rectangle</a> *update;

   <span class="comment">/* Render the canvas, and get a list of the updated rectangles. */</span>
   updates = evas_render_updates(canvas);

   <span class="comment">/* Just for informative purposes, print out the areas being updated: */</span>
   <a class="code" href="group__Eina__List__Group.html#gad02f746a08ee0b12b7ed66d4bc0d71d8" title="Definition for the macro to iterate over a list.">EINA_LIST_FOREACH</a>(updates, n, update)
     printf(&quot;UPDATED REGION: pos: %3d, %3d    size: %3dx%3d\n&quot;,
        update-&gt;x, update-&gt;y, update-&gt;w, update-&gt;h);

   <span class="comment">/* Free the list of update rectangles */</span>
   <a class="code" href="group__Evas__Canvas.html#ga038d98c7c13a86b6ba4de51f8aba3595">evas_render_updates_free</a>(updates);
}

<span class="comment">/* Output the canvas buffer to a Portable Pixel Map (PPM) file */</span>
static <span class="keywordtype">void</span> save_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas, const <span class="keywordtype">char</span> *dest)
{
   Evas_Engine_Info_Buffer *einfo;
   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *pixels, *pixels_end;
   <span class="keywordtype">int</span> width, height;
   FILE *f;

   <span class="comment">/* Retrieve the current data buffer. */</span>
   einfo = (Evas_Engine_Info_Buffer *)<a class="code" href="group__Evas__Canvas.html#gaf396b44e1b97ec0d9dce49fcf9ad54b7" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <span class="keywordflow">return</span>;
     }

   <span class="comment">/* Retrieve the canvas dimensions */</span>
   <a class="code" href="group__Evas__Canvas.html#gadd22b11c786b3b00448ef58550aa55c4" title="Retrieve the output size of the render engine of the given evas.">evas_output_size_get</a>(canvas, &amp;width, &amp;height);

   <span class="comment">/* Open our output PPM file for writing */</span>
   f = fopen(dest, <span class="stringliteral">&quot;wb+&quot;</span>);
   <span class="keywordflow">if</span> (!f)
     {
    fprintf(stderr, <span class="stringliteral">&quot;ERROR: could not open for writing &#39;%s&#39;: %s\n&quot;</span>,
        dest, strerror(errno));
    <span class="keywordflow">return</span>;
     }

   <span class="comment">/* Write out the pixel data to the PPM file */</span>
   pixels = einfo-&gt;info.dest_buffer;
   pixels_end = pixels + (width * height);

   <span class="comment">/* PPM P6 format is dead simple to write.  First we output a magic</span>
<span class="comment">    * number &#39;P6&#39; to designate the file as PPM, then the width and</span>
<span class="comment">    * height on their own line in ASCII decimal, followed by the maximum</span>
<span class="comment">    * color value (255) on its own line in ASCII decimal, and finally a</span>
<span class="comment">    * the pixel data in RGB order with each color component written as</span>
<span class="comment">    * a char (byte).  No alpha information is stored.</span>
<span class="comment">    */</span>
   fprintf(f, <span class="stringliteral">&quot;P6\n%d %d\n255\n&quot;</span>,  width, height);
   <span class="keywordflow">for</span> (; pixels &lt; pixels_end; pixels++)
     {
    <span class="keywordtype">int</span> r, g, b;

    r = ((*pixels) &amp; 0xff0000) &gt;&gt; 16;
    g = ((*pixels) &amp; 0x00ff00) &gt;&gt; 8;
    b = (*pixels) &amp; 0x0000ff;

    fprintf(f, <span class="stringliteral">&quot;%c%c%c&quot;</span>, r, g, b);
     }

   fclose(f);
   printf(<span class="stringliteral">&quot;saved scene as &#39;%s&#39;\n&quot;</span>, dest);
}
</pre></div><p>More examples can be found at <a class="el" href="evas_examples.html">Evas Examples</a>. </p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
