<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Advanced use of Eet Data Descriptors</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">4.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('eet_data_file_descriptor.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Advanced use of Eet Data Descriptors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A real life example is usually the best way to see how things are used, but they also involve a lot more code than what needs to be shown, so instead of going that way, we'll be borrowing some pieces from one in the following example. It's been slightly modified from the original source to show more of the varied ways in which Eet can handle our data.</p>
<p>This example shows a cache of user accounts and messages received, and it's a bit more interactive than previous examples.</p>
<p>Let's begin by looking at the structures we'll be using. First we have one to define the messages the user receives and one for the one he posts. Straight forward and nothing new here.  <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct</span>
{
   <span class="keyword">const</span> <span class="keywordtype">char</span>  *screen_name;
   <span class="keyword">const</span> <span class="keywordtype">char</span>  *name;
   <span class="keyword">const</span> <span class="keywordtype">char</span>  *message;
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id;
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> status_id;
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> date;
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timeline;
} My_Message;

<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
   <span class="keyword">const</span> <span class="keywordtype">char</span> *dm_to;
   <span class="keyword">const</span> <span class="keywordtype">char</span> *message;
} My_Post;
</pre></div></p>
<p>One more to declare the account itself. This one will contain a list of all messages received, and the posts we make ourselves will be kept in an array. No special reason other than to show how to use arrays with Eet. <div class="fragment"><pre class="fragment">
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id;
   <span class="keyword">const</span> <span class="keywordtype">char</span>  *name;
   <a class="code" href="struct__Eina__List.html">Eina_List</a>   *messages;
   My_Post     *posts;
   <span class="keywordtype">int</span>          posts_count;
} My_Account;
</pre></div></p>
<p>Finally, the main structure to hold our cache of accounts. We'll be looking for these accounts by their names, so let's keep them in a hash, using that name as the key. <div class="fragment"><pre class="fragment">
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> version; <span class="comment">// it is recommended to use versioned configuration!</span>
   <a class="code" href="group__Eina__Hash__Group.html#ga9a89d7d3ee260d3a60572ebf651b07e0">Eina_Hash</a>   *accounts;
} My_Cache;
</pre></div></p>
<p>As explained before, we need one descriptor for each struct we want Eet to handle, but this time we also want to keep around our Eet file and its string dictionary. You will see why in a moment. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="group__Eet__Data__Group.html#ga4baec0e840012480a0958c5c3bca276d">Eet_Data_Descriptor</a> *_my_cache_descriptor;
<span class="keyword">static</span> <a class="code" href="group__Eet__Data__Group.html#ga4baec0e840012480a0958c5c3bca276d">Eet_Data_Descriptor</a> *_my_account_descriptor;
<span class="keyword">static</span> <a class="code" href="group__Eet__Data__Group.html#ga4baec0e840012480a0958c5c3bca276d">Eet_Data_Descriptor</a> *_my_message_descriptor;
<span class="keyword">static</span> <a class="code" href="group__Eet__Data__Group.html#ga4baec0e840012480a0958c5c3bca276d">Eet_Data_Descriptor</a> *_my_post_descriptor;
<span class="keyword">static</span> <a class="code" href="group__Eet__File__Group.html#ga8d9779184a9870c1a225f1f40c76e8a7">Eet_File</a> *_my_cache_file = NULL;
<span class="keyword">static</span> <a class="code" href="group__Eet__File__Group.html#gaf0984c8280699ca5a3c4966f5580324c">Eet_Dictionary</a> *_my_cache_dict = NULL;
</pre></div></p>
<p>The differences begin now. They aren't much, but we'll be creating our descriptors differently. Things can be added to our cache, but we won't be modifying the current contents, so we can consider the data read from it to be read-only, and thus allow Eet to save time and memory by not duplicating thins unnecessary. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
_my_cache_descriptor_init(<span class="keywordtype">void</span>)
{
   <a class="code" href="struct__Eet__Data__Descriptor__Class.html">Eet_Data_Descriptor_Class</a> eddc;

   <span class="comment">// The FILE variant is good for caches and things that are just</span>
   <span class="comment">// appended, but needs to take care when changing strings and files must</span>
   <span class="comment">// be kept open so mmap()ed strings will be kept alive.</span>
   <a class="code" href="group__Eet__Data__Group.html#ga0bf94c07d8e69cfaac8dd2d615d7542c">EET_EINA_FILE_DATA_DESCRIPTOR_CLASS_SET</a>(&amp;eddc, My_Cache);
   _my_cache_descriptor = <a class="code" href="group__Eet__Data__Group.html#ga4fedba15a4c27e7e75db9d92e538321a">eet_data_descriptor_file_new</a>(&amp;eddc);

   <a class="code" href="group__Eet__Data__Group.html#ga0bf94c07d8e69cfaac8dd2d615d7542c">EET_EINA_FILE_DATA_DESCRIPTOR_CLASS_SET</a>(&amp;eddc, My_Account);
   _my_account_descriptor = <a class="code" href="group__Eet__Data__Group.html#ga4fedba15a4c27e7e75db9d92e538321a">eet_data_descriptor_file_new</a>(&amp;eddc);

   <a class="code" href="group__Eet__Data__Group.html#ga0bf94c07d8e69cfaac8dd2d615d7542c">EET_EINA_FILE_DATA_DESCRIPTOR_CLASS_SET</a>(&amp;eddc, My_Message);
   _my_message_descriptor = <a class="code" href="group__Eet__Data__Group.html#ga4fedba15a4c27e7e75db9d92e538321a">eet_data_descriptor_file_new</a>(&amp;eddc);

   <a class="code" href="group__Eet__Data__Group.html#ga0bf94c07d8e69cfaac8dd2d615d7542c">EET_EINA_FILE_DATA_DESCRIPTOR_CLASS_SET</a>(&amp;eddc, My_Post);
   _my_post_descriptor = <a class="code" href="group__Eet__Data__Group.html#ga4fedba15a4c27e7e75db9d92e538321a">eet_data_descriptor_file_new</a>(&amp;eddc);
</pre></div></p>
<p>As the comment in the code explains, we are asking Eet to give us strings directly from the mapped file, which avoids having to load it in memory and data duplication. Of course, there are things to take into account when doing things this way, and they will be mentioned as we encounter those special cases.</p>
<p>Next comes the actual description of our data, just like we did in the previous examples. <div class="fragment"><pre class="fragment"><span class="preprocessor">#define ADD_BASIC(member, eet_type) \</span>
<span class="preprocessor">  EET_DATA_DESCRIPTOR_ADD_BASIC     \</span>
<span class="preprocessor">    (_my_message_descriptor, My_Message, # member, member, eet_type)</span>
<span class="preprocessor"></span>   ADD_BASIC(screen_name, <a class="code" href="group__Eet__Data__Group.html#ga0d2cf409bf3f151156d74d18ac59e3d1">EET_T_STRING</a>);
   ADD_BASIC(name, <a class="code" href="group__Eet__Data__Group.html#ga0d2cf409bf3f151156d74d18ac59e3d1">EET_T_STRING</a>);
   ADD_BASIC(message, <a class="code" href="group__Eet__Data__Group.html#ga0d2cf409bf3f151156d74d18ac59e3d1">EET_T_STRING</a>);
   ADD_BASIC(<span class="keywordtype">id</span>, <a class="code" href="group__Eet__Data__Group.html#gacf6a3c9f06e10e20be5b02cd8c6a220b">EET_T_UINT</a>);
   ADD_BASIC(status_id, <a class="code" href="group__Eet__Data__Group.html#gacf6a3c9f06e10e20be5b02cd8c6a220b">EET_T_UINT</a>);
   ADD_BASIC(date, <a class="code" href="group__Eet__Data__Group.html#gacf6a3c9f06e10e20be5b02cd8c6a220b">EET_T_UINT</a>);
   ADD_BASIC(timeline, <a class="code" href="group__Eet__Data__Group.html#gacf6a3c9f06e10e20be5b02cd8c6a220b">EET_T_UINT</a>);
<span class="preprocessor">#undef ADD_BASIC</span>

<span class="preprocessor">#define ADD_BASIC(member, eet_type) \</span>
  <a class="code" href="group__Eet__Data__Group.html#gac38ce778d7eba37cfca8a19efb7a9b3a" title="Adds a basic data element to a data descriptor.">EET_DATA_DESCRIPTOR_ADD_BASIC</a>     \
    (_my_post_descriptor, My_Post, # member, member, eet_type)
   ADD_BASIC(dm_to, <a class="code" href="group__Eet__Data__Group.html#ga0d2cf409bf3f151156d74d18ac59e3d1">EET_T_STRING</a>);
   ADD_BASIC(message, <a class="code" href="group__Eet__Data__Group.html#ga0d2cf409bf3f151156d74d18ac59e3d1">EET_T_STRING</a>);
<span class="preprocessor">#undef ADD_BASIC</span>
</pre></div></p>
<p>And the account struct's description doesn't add much new, but it's worth commenting on it. <div class="fragment"><pre class="fragment"><span class="preprocessor">#define ADD_BASIC(member, eet_type) \</span>
<span class="preprocessor">  EET_DATA_DESCRIPTOR_ADD_BASIC     \</span>
<span class="preprocessor">    (_my_account_descriptor, My_Account, # member, member, eet_type)</span>
<span class="preprocessor"></span>   ADD_BASIC(name, <a class="code" href="group__Eet__Data__Group.html#ga0d2cf409bf3f151156d74d18ac59e3d1">EET_T_STRING</a>);
   ADD_BASIC(<span class="keywordtype">id</span>, <a class="code" href="group__Eet__Data__Group.html#gacf6a3c9f06e10e20be5b02cd8c6a220b">EET_T_UINT</a>);
<span class="preprocessor">#undef ADD_BASIC</span>
<span class="preprocessor"></span>
   <a class="code" href="group__Eet__Data__Group.html#gabb4c7833ba053f2322e6b667a9ec7f04" title="Adds a linked list type to a data descriptor.">EET_DATA_DESCRIPTOR_ADD_LIST</a>
     (_my_account_descriptor, My_Account, <span class="stringliteral">&quot;messages&quot;</span>, messages,
     _my_message_descriptor);
   <a class="code" href="group__Eet__Data__Group.html#ga7adad32d2eba76566533353632f00ae4" title="Adds a variable size array type to a data descriptor.">EET_DATA_DESCRIPTOR_ADD_VAR_ARRAY</a>
     (_my_account_descriptor, My_Account, <span class="stringliteral">&quot;posts&quot;</span>, posts,
     _my_post_descriptor);
</pre></div></p>
<p>How to add a list we've seen before, but now we are also adding an array. There's nothing really special about it, but it's important to note that the EET_DATA_DESCRIPTOR_ADD_VAR_ARRAY is used to add arrays of variable length to a descriptor. That is, arrays just like the one we defined. Since there's no way in C to know how long they are, we need to keep track of the count ourselves and Eet needs to know how to do so as well. That's what the <code>posts_count</code> member of our struct is for. When adding our array member, this macro will look for another variable in the struct named just like the array, but with <code>_count</code> attached to the end. When saving our data, Eet will know how many elements the array contains by looking into this count variable. When loading back from a file, this variable will be set to the right number of elements.</p>
<p>Another option for arrays is to use EET_DATA_DESCRIPTOR_ADD_ARRAY, which takes care of fixed sized arrays. For example, let's suppose that we want to keep track of only the last ten posts the user sent, and we declare our account struct as follows </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> <span class="keyword">struct</span>
 {
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> id;
    <span class="keyword">const</span> <span class="keywordtype">char</span>  *name;
    <a class="code" href="struct__Eina__List.html">Eina_List</a>   *messages;
    My_Post      posts[10];
 } My_Account;
</pre></div><p> Then we would add the array to our descriptor with </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__Eet__Data__Group.html#gabc903baa4d5dc50a98f5e1a68d66fd2b" title="Adds a fixed size array type to a data descriptor.">EET_DATA_DESCRIPTOR_ADD_ARRAY</a>(_my_account_descriptor, My_Account, <span class="stringliteral">&quot;posts&quot;</span>,
                               posts, _my_post_descriptor);
</pre></div><p>Notice how this time we don't have a <code>posts_count</code> variable in our struct. We could have it for the program to keep track of how many posts the array actually contains, but Eet no longer needs it. Being defined that way the array is already taking up all the memory needed for the ten elements, and it is possible in C to determine how much it is in code. When saving our data, Eet will just dump the entire memory blob into the file, regardless of how much of it is really used. So it's important to take into consideration this kind of things when defining your data types. Each has its uses, its advantages and disadvantages and it's up to you to decide which to use.</p>
<p>Now, going back to our example, we have to finish adding our data to the descriptors. We are only missing the main one for the cache, which contains our hash of accounts. Unless you are using your own hash functions when setting the descriptor class, always use hashes with string type keys. <div class="fragment"><pre class="fragment"><span class="preprocessor">#define ADD_BASIC(member, eet_type) \</span>
<span class="preprocessor">  EET_DATA_DESCRIPTOR_ADD_BASIC     \</span>
<span class="preprocessor">    (_my_cache_descriptor, My_Cache, # member, member, eet_type)</span>
<span class="preprocessor"></span>   ADD_BASIC(version, <a class="code" href="group__Eet__Data__Group.html#gacf6a3c9f06e10e20be5b02cd8c6a220b">EET_T_UINT</a>);
<span class="preprocessor">#undef ADD_BASIC</span>
<span class="preprocessor"></span>
   <a class="code" href="group__Eet__Data__Group.html#gad5e348ead4ba0b441c1e020f9bf23365" title="Adds a hash type to a data descriptor.">EET_DATA_DESCRIPTOR_ADD_HASH</a>
     (_my_cache_descriptor, My_Cache, <span class="stringliteral">&quot;accounts&quot;</span>, accounts,
     _my_account_descriptor);
} <span class="comment">/* _my_cache_descriptor_init */</span>
</pre></div></p>
<p>If you remember, we told Eet not to duplicate memory when possible at the time of loading back our data. But this doesn't mean everything will be loaded straight from disk and we don't have to worry about freeing it. Data in the Eet file is compressed and encoded, so it still needs to be decoded and memory will be allocated to convert it back into something we can use. We also need to take care of anything we add in the current instance of the program. To summarize, any string we get from Eet is likely to be a pointer to the internal dictionary, and trying to free it will, in the best case, crash our application right away.</p>
<p>So how do we know if we have to free a string? We check if it's part of the dictionary, and if it's not there we can be sure it's safe to get rid of it. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
_eet_string_free(<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
{
   <span class="keywordflow">if</span> (!str)
     <span class="keywordflow">return</span>;

   <span class="keywordflow">if</span> ((_my_cache_dict) &amp;&amp; (<a class="code" href="group__Eet__File__Group.html#gaafc8deb871cabb7dcdeb086d29c500ca" title="Checks if a given string comes from a given dictionary.">eet_dictionary_string_check</a>(_my_cache_dict, str)))
     <span class="keywordflow">return</span>;

   <a class="code" href="group__Eina__Stringshare__Group.html#ga495411b0bc85b9c0d59ec7255a025260" title="Notes that the given string has lost an instance.">eina_stringshare_del</a>(str);
} <span class="comment">/* _eet_string_free */</span>
</pre></div></p>
<p>See how this is used when adding a new message to our cache. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> My_Message *
_my_message_new(<span class="keyword">const</span> <span class="keywordtype">char</span> *message)
{
   My_Message *msg = calloc(1, <span class="keyword">sizeof</span>(My_Message));
   <span class="keywordflow">if</span> (!msg)
     {
        fprintf(stderr, <span class="stringliteral">&quot;ERROR: could not calloc My_Message\n&quot;</span>);
        <span class="keywordflow">return</span> NULL;
     }

   msg-&gt;message = <a class="code" href="group__Eina__Stringshare__Group.html#ga5293082680141132ffcacc28866ef0ef" title="Retrieves an instance of a string for use in a program.">eina_stringshare_add</a>(message);
   <span class="keywordflow">return</span> msg;
} <span class="comment">/* _my_message_new */</span>

<span class="keyword">static</span> <span class="keywordtype">void</span>
_my_message_free(My_Message *msg)
{
   _eet_string_free(msg-&gt;screen_name);
   _eet_string_free(msg-&gt;name);
   _eet_string_free(msg-&gt;message);
   free(msg);
} <span class="comment">/* _my_message_free */</span>
</pre></div></p>
<p>Skipping all the utility functions used by our program (remember you can look at the full example here) we get to our cache loading code. Nothing out of the ordinary at first, just the same old open file, read data using our main descriptor to decode it into something we can use and check version of loaded data and if it doesn't match, do something accordingly. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> My_Cache *
_my_cache_new(<span class="keywordtype">void</span>)
{
   My_Cache *my_cache = calloc(1, <span class="keyword">sizeof</span>(My_Cache));
   <span class="keywordflow">if</span> (!my_cache)
     {
        fprintf(stderr, <span class="stringliteral">&quot;ERROR: could not calloc My_Cache\n&quot;</span>);
        <span class="keywordflow">return</span> NULL;
     }

   my_cache-&gt;accounts = <a class="code" href="group__Eina__Hash__Group.html#gaad2e43204f79ee5a8f19470ff5ba4ac8" title="Creates a new hash table for use with strings with small bucket size.">eina_hash_string_small_new</a>(NULL);

   my_cache-&gt;version = 1;
   <span class="keywordflow">return</span> my_cache;
} <span class="comment">/* _my_cache_new */</span>

<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_my_cache_account_free_cb(<span class="keyword">const</span> <a class="code" href="group__Eina__Hash__Group.html#ga9a89d7d3ee260d3a60572ebf651b07e0">Eina_Hash</a> *hash EINA_UNUSED,
                          <span class="keyword">const</span> <span class="keywordtype">void</span>      *key EINA_UNUSED,
                          <span class="keywordtype">void</span>            *data,
                          <span class="keywordtype">void</span>            *fdata EINA_UNUSED)
{
   _my_account_free(data);
   <span class="keywordflow">return</span> <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>;
}
</pre></div></p>
<p>Then comes the interesting part. Remember how we kept two more global variables with our descriptors? One of them we already used to check if it was right to free a string or not, but we didn't know where it came from. Loading our data straight from the mmapped file means that we can't close it until we are done using it, so we need to keep its handler around until then. It also means that any changes done to the file can, and will, invalidate all our pointers to the file backed data, so if we add something and save the file, we need to reload our cache.</p>
<p>Thus our load function checks if we had an open file, if there is it gets closed and our variable is updated to the new handler. Then we get the string dictionary we use to check if a string is part of it or not. Updating any references to the cache data is up you as a programmer to handle properly, there's nothing Eet can do in this situation. <div class="fragment"><pre class="fragment">
<span class="keyword">static</span> <span class="keywordtype">void</span>
_my_cache_free(My_Cache *my_cache)
{
   <a class="code" href="group__Eina__Hash__Group.html#ga2c23f8425d3afcc61827ab67b46d7190" title="Calls a function on every member stored in the hash table.">eina_hash_foreach</a>(my_cache-&gt;accounts, _my_cache_account_free_cb, NULL);
   <a class="code" href="group__Eina__Hash__Group.html#gadb6acb720ce267cc1cd4f51893539f59" title="Frees the given hash table resources.">eina_hash_free</a>(my_cache-&gt;accounts);
   free(my_cache);
} <span class="comment">/* _my_cache_free */</span>
</pre></div></p>
<p>The save function doesn't have anything new, and all that's left after it is the main program, which doesn't really have anything of interest within the scope of what we are learning. </p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
