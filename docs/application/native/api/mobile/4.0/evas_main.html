<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Evas</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">4.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('evas_main.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Evas </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="date"><dt><b>Date:</b></dt><dd>2000 (created)</dd></dl>
<h2><a class="anchor" id="toc"></a>
Table of Contents</h2>
<ul>
<li><a class="el" href="evas_main.html#evas_main_intro">Introduction</a> </li>
<li><a class="el" href="evas_main.html#evas_main_work">How does Evas work?</a> </li>
<li><a class="el" href="evas_main.html#evas_main_compiling">How to compile</a> </li>
<li><a class="el" href="evas_main.html#evas_main_next_steps">Next Steps</a> </li>
<li><a class="el" href="evas_main.html#evas_main_intro_example">Introductory Example</a></li>
</ul>
<h2><a class="anchor" id="evas_main_intro"></a>
Introduction</h2>
<p>Evas is a clean display canvas API for several target display systems that can draw anti-aliased text, smooth super and sub-sampled scaled images, alpha-blend objects and much more.</p>
<p>It abstracts any need to know much about what the characteristics of your display system are or what graphics calls are used to draw them and how. It deals on an object level where all you do is create and manipulate objects in a canvas, set their properties, and the rest is done for you.</p>
<p>Evas optimises the rendering pipeline to minimise effort in redrawing changes made to the canvas and so takes this work out of the programmers hand, saving a lot of time and energy.</p>
<p>It is small and lean, and is designed to work on embedded systems all the way to large and powerful multi-CPU workstations. It can be compiled to only have the features you need for your target platform if you so wish, thus keeping it small and lean. It has several display back-ends, letting it display on several display systems, making it portable for cross-device and cross-platform development.</p>
<h3><a class="anchor" id="evas_main_intro_not_evas"></a>
What Evas is not?</h3>
<p>Evas is not a widget set or widget toolkit, however it is their base. See Elementary (<a href="http://docs.enlightenment.org/auto/elementary/">http://docs.enlightenment.org/auto/elementary/</a>) for a toolkit based on <a class="el" href="group__Evas.html">Evas</a>, <a class="el" href="group__Edje.html">Edje</a>, <a class="el" href="group__Ecore.html">Ecore</a> and other Enlightenment technologies.</p>
<p>It is not dependent or aware of main loops, input or output systems. Input should be polled from various sources and fed to Evas. Similarly, it does not create windows or report windows updates to your system, but just draws the pixels and report to the user the areas that were changed. Of course these operations are quite common and thus they are ready to use in <a class="el" href="group__Ecore.html">Ecore</a>, particularly in <a class="el" href="group__Ecore__Evas__Group.html">Ecore_Evas wrapper/helper set of functions</a>.</p>
<h2><a class="anchor" id="evas_main_work"></a>
How does Evas work?</h2>
<p>Evas is a canvas display library. This is markedly different from most display and windowing systems as a canvas is structural and is also a state engine, whereas most display and windowing systems are immediate mode display targets. Evas handles the logic between a structural display via its state engine, and controls the target windowing system in order to produce rendered results of the current canvas' state on the display.</p>
<p>Immediate mode display systems retain very little, or no state. A program executes a series of commands, as in the pseudo code:</p>
<div class="fragment"><pre class="fragment">
   draw line from position (0, 0) to position (100, 200);

   draw rectangle from position (10, 30) to position (50, 500);

   bitmap_handle = create_bitmap();
   scale bitmap_handle to size 100 x 100;
   draw image bitmap_handle at position (10, 30);
   </pre></div><p>The series of commands is executed by the windowing system and the results are displayed on the screen (normally). Once the commands are executed the display system has little or no idea of how to reproduce this image again, and so has to be instructed by the application on how to redraw sections of the screen whenever needed. Each successive command is executed as instructed by the application and either emulated by software or sent to the graphics hardware on the device to be performed.</p>
<p>The advantage of such a system is that it is simple, and gives a program tight control over how something looks and is drawn. Given the increasing complexity of displays and demands by users to have better looking interfaces, more and more work is needing to be done at this level by the internals of widget sets, custom display widgets and other programs. This means that more and more logic and display rendering code needs to be written each time the application needs to figure out how to minimise redraws so that display is fast and interactive, and keeps track of redraw logic. The power comes at a high-price with lots of extra code and work. Programmers not very familiar with graphics programming often make mistakes at this level and produce code that is sub optimal. Those familiar with this kind of programming simply get bored by writing the same code again and again.</p>
<p>For example, if in the above scene, the windowing system requires the application to redraw the area from 0, 0 to 50, 50 (also referred as "expose event"), then the programmer must calculate manually the updates and repaint it again:</p>
<div class="fragment"><pre class="fragment">
   Redraw from position (0, 0) to position (50, 50):

   // what is in area (0, 0, 50, 50)?

   // 1. intersection part of line (0, 0) to (100, 200)?
      draw line from position (0, 0) to position (25, 50);

   // 2. intersection part of rectangle (10, 30) to (50, 500)?
      draw rectangle from position (10, 30) to position (50, 50)

   // 3. intersection part of image at (10, 30), size 100 x 100?
      bitmap_subimage = subregion from position (0, 0) to position (40, 20)
      draw image bitmap_subimage at position (10, 30);
   </pre></div><p>You might have noticed that, if all elements in the above scene are opaque, then the system is doing useless paints: part of the line is behind the rectangle, and part of the rectangle is behind the image. These useless paints tend to be very costly, as pixels tend to be 4 bytes in size; thus an overlapping region of 100 x 100 pixels is around 40000 useless writes! You could write code to calculate the overlapping areas and avoid painting then, but then it should be mixed with the "expose event" handling mentioned above and you quickly realize that the initially simpler method became really complex.</p>
<p>Evas is a structural system in which the programmer creates and manages display objects and their properties, and as a result of this higher level state management, the canvas is able to redraw the set of objects when needed to represent the current state of the canvas.</p>
<p>For example, the pseudo code:</p>
<div class="fragment"><pre class="fragment">
   line_handle = create_line();
   set line_handle from position (0, 0) to position (100, 200);
   show line_handle;

   rectangle_handle = create_rectangle();
   move rectangle_handle to position (10, 30);
   resize rectangle_handle to size 40 x 470;
   show rectangle_handle;

   bitmap_handle = create_bitmap();
   scale bitmap_handle to size 100 x 100;
   move bitmap_handle to position (10, 30);
   show bitmap_handle;

   render scene;
   </pre></div><p>This may look longer, but when the display needs to be refreshed or updated, you move, resize, show, or hide the objects that need to change. You can simply think at the object logic level, and the canvas software does the rest of the work for you, figuring out what actually changed in the canvas since it had been last drawn, how to most efficiently redraw the canvas and its contents to reflect the current state, and then it can go off and do the actual drawing of the canvas.</p>
<p>This lets you think in a more natural way when dealing with a display, and saves time and effort of working out how to load and display images, render given the current display system, and so on. Since Evas also is portable across different display systems, this also gives you the ability to have their code ported and displayed on different display systems with very little work.</p>
<p>Evas can be seen as a display system that stands somewhere between a widget set and an immediate mode display system. It retains basic display logic, but does very little high-level logic such as scrollbars, sliders, and push buttons.</p>
<h2><a class="anchor" id="evas_main_compiling"></a>
How to compile</h2>
<p>Evas is a library your application links to. The procedure for this is very simple. You simply have to compile your application with the appropriate compiler flags that the <code>pkg-config</code> script outputs. For example:</p>
<p>Compiling C or C++ files into object files:</p>
<div class="fragment"><pre class="fragment">
   gcc -c -o main.o main.c `pkg-config --cflags evas`
   </pre></div><p>Linking object files into a binary executable:</p>
<div class="fragment"><pre class="fragment">
   gcc -o my_application main.o `pkg-config --libs evas`
   </pre></div><p>See <a class="el" href="pkgconfig.html">pkgconfig</a></p>
<h2><a class="anchor" id="evas_main_next_steps"></a>
Next Steps</h2>
<p>After you understood what Evas is and installed it in your system you should proceed understanding the programming interface for all objects, then see the specific for the most used elements. We'd recommend you to take a while to learn <a class="el" href="group__Ecore.html">Ecore</a>, <a class="el" href="group__Edje.html">Edje</a> and Elementary (<a href="http://docs.enlightenment.org/auto/elementary/">http://docs.enlightenment.org/auto/elementary/</a>) as they will likely save you tons of work compared to using just Evas directly.</p>
<p>Recommended reading:</p>
<ul>
<li><a class="el" href="group__Evas__Object__Group.html">Generic Object Functions</a>, where you'll get how to basically manipulate generic objects lying on an Evas canvas, handle canvas and object events, etc. </li>
<li><a class="el" href="group__Evas__Object__Rectangle.html">Rectangle Object Functions</a>, to learn about the most basic object type on Evas -- the rectangle. </li>
<li><a class="el" href="group__Evas__Object__Polygon.html">Polygon Object Functions</a>, to learn how to create polygon elements on the canvas. </li>
<li><a class="el" href="group__Evas__Line__Group.html">Line Object Functions</a>, to learn how to create line elements on the canvas. </li>
<li><a class="el" href="group__Evas__Object__Image.html">Image Object Functions</a>, to learn about image objects, over which Evas can do a plethora of operations. </li>
<li><a class="el" href="group__Evas__Object__Text.html">Text Object Functions</a>, to learn how to create textual elements on the canvas. </li>
<li><a class="el" href="group__Evas__Object__Textblock.html">Textblock Object Functions</a>, to learn how to create multiline textual elements on the canvas. </li>
<li><a class="el" href="group__Evas__Smart__Object__Group.html">Smart Object Functions</a> and <a class="el" href="group__Evas__Smart__Group.html">Smart Functions</a>, to define new objects that provide <b>custom</b> functions to handle clipping, hiding, moving, resizing, color setting and more. These could be as simple as a group of objects that move together (see <a class="el" href="group__Evas__Smart__Object__Clipped.html">Clipped Smart Object</a>) up to implementations of what ends to be a widget, providing some intelligence (thus the name) to Evas objects -- like a button or check box, for example.</li>
</ul>
<h2><a class="anchor" id="evas_main_intro_example"></a>
Introductory Example</h2>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;Evas.h&gt;</span>
<span class="preprocessor">#include &lt;Evas_Engine_Buffer.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;errno.h&gt;</span>

<span class="preprocessor">#define WIDTH (320)</span>
<span class="preprocessor"></span><span class="preprocessor">#define HEIGHT (240)</span>
<span class="preprocessor"></span>
<span class="comment">/*</span>
<span class="comment"> * create_canvas(), destroy_canvas() and draw_scene() are support functions.</span>
<span class="comment"> *</span>
<span class="comment"> * They are only required to use raw Evas, but for real world usage,</span>
<span class="comment"> * it is recommended to use ecore and its ecore-evas submodule, that</span>
<span class="comment"> * provide convenience canvas creators, integration with main loop and</span>
<span class="comment"> * automatic render of updates (draw_scene()) when system goes back to</span>
<span class="comment"> * main loop.</span>
<span class="comment"> */</span>

<span class="keyword">static</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *create_canvas(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height);
<span class="keyword">static</span> <span class="keywordtype">void</span> destroy_canvas(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas);
<span class="keyword">static</span> <span class="keywordtype">void</span> draw_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas);

<span class="comment">// support function to save scene as PPM image</span>
<span class="keyword">static</span> <span class="keywordtype">void</span> save_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas, <span class="keyword">const</span> <span class="keywordtype">char</span> *dest);

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *bg, *r1, *r2, *r3;

   <a class="code" href="group__Evas__Main__Group.html#ga65b3f060b6dd9e488afd0b8cbe101869">evas_init</a>();

   <span class="comment">// create your canvas</span>
   <span class="comment">// NOTE: consider using ecore_evas_buffer_new() instead!</span>
   canvas = create_canvas(WIDTH, HEIGHT);
   <span class="keywordflow">if</span> (!canvas)
     <span class="keywordflow">return</span> -1;

   bg = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Font__Group.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(bg, 255, 255, 255, 255); <span class="comment">// white bg</span>
   <a class="code" href="group__Evas__Font__Group.html#ga02da8091bbac768b8e86c7b74b2a94f9">evas_object_move</a>(bg, 0, 0);                    <span class="comment">// at origin</span>
   <a class="code" href="group__Evas__Font__Group.html#ga21e8604c0e4a93e469bff4bd069e82b5">evas_object_resize</a>(bg, WIDTH, HEIGHT);         <span class="comment">// covers full canvas</span>
   <a class="code" href="group__Evas__Font__Group.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(bg);

   puts(<span class="stringliteral">&quot;initial scene, with just background:&quot;</span>);
   draw_scene(canvas);

   r1 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Font__Group.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r1, 255, 0, 0, 255); <span class="comment">// 100% opaque red</span>
   <a class="code" href="group__Evas__Font__Group.html#ga02da8091bbac768b8e86c7b74b2a94f9">evas_object_move</a>(r1, 10, 10);
   <a class="code" href="group__Evas__Font__Group.html#ga21e8604c0e4a93e469bff4bd069e82b5">evas_object_resize</a>(r1, 100, 100);
   <a class="code" href="group__Evas__Font__Group.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r1);

   <span class="comment">// pay attention to transparency! Evas color values are pre-multiplied by</span>
   <span class="comment">// alpha, so 50% opaque green is:</span>
   <span class="comment">// non-premul: r=0, g=255, b=0    a=128 (50% alpha)</span>
   <span class="comment">// premul:</span>
   <span class="comment">//         r_premul = r * a / 255 =      0 * 128 / 255 =      0</span>
   <span class="comment">//         g_premul = g * a / 255 =    255 * 128 / 255 =    128</span>
   <span class="comment">//         b_premul = b * a / 255 =      0 * 128 / 255 =      0</span>
   <span class="comment">//</span>
   <span class="comment">// this 50% green is over a red background, so it will show in the</span>
   <span class="comment">// final output as yellow (green + red = yellow)</span>
   r2 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Font__Group.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r2, 0, 128, 0, 128); <span class="comment">// 50% opaque green</span>
   <a class="code" href="group__Evas__Font__Group.html#ga02da8091bbac768b8e86c7b74b2a94f9">evas_object_move</a>(r2, 10, 10);
   <a class="code" href="group__Evas__Font__Group.html#ga21e8604c0e4a93e469bff4bd069e82b5">evas_object_resize</a>(r2, 50, 50);
   <a class="code" href="group__Evas__Font__Group.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r2);

   r3 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Font__Group.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r3, 0, 128, 0, 255); <span class="comment">// 100% opaque dark green</span>
   <a class="code" href="group__Evas__Font__Group.html#ga02da8091bbac768b8e86c7b74b2a94f9">evas_object_move</a>(r3, 60, 60);
   <a class="code" href="group__Evas__Font__Group.html#ga21e8604c0e4a93e469bff4bd069e82b5">evas_object_resize</a>(r3, 50, 50);
   <a class="code" href="group__Evas__Font__Group.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r3);

   puts(<span class="stringliteral">&quot;final scene (note updates):&quot;</span>);
   draw_scene(canvas);
   save_scene(canvas, <span class="stringliteral">&quot;/tmp/evas-buffer-simple-render.ppm&quot;</span>);

   <span class="comment">// NOTE: use ecore_evas_buffer_new() and here ecore_evas_free()</span>
   destroy_canvas(canvas);

   <a class="code" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09">evas_shutdown</a>();

   <span class="keywordflow">return</span> 0;
}

<span class="keyword">static</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *create_canvas(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   Evas_Engine_Info_Buffer *einfo;
   <span class="keywordtype">int</span> method;
   <span class="keywordtype">void</span> *pixels;

   method = <a class="code" href="group__Evas__Output__Method.html#ga9f9871fdcc40ce1062d6565308020eb8">evas_render_method_lookup</a>(<span class="stringliteral">&quot;buffer&quot;</span>);
   <span class="keywordflow">if</span> (method &lt;= 0)
     {
    fputs(<span class="stringliteral">&quot;ERROR: evas was not compiled with &#39;buffer&#39; engine!\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   canvas = <a class="code" href="group__Evas__Canvas.html#ga67e8eb17d2a676bfdfb8794fc5f72bc0">evas_new</a>();
   <span class="keywordflow">if</span> (!canvas)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not instantiate new evas canvas.\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <a class="code" href="group__Evas__Canvas.html#ga17f2ac9f3bef135cd825774c33762ef2" title="Sets the output engine for the given evas.">evas_output_method_set</a>(canvas, method);
   <a class="code" href="group__Evas__Canvas.html#ga681f2af7d325735af201e18f56f6ef61" title="Sets the output size of the render engine of the given evas.">evas_output_size_set</a>(canvas, width, height);
   <a class="code" href="group__Evas__Canvas.html#ga0a14db31aa30b701688caf67a4649239" title="Sets the output viewport of the given evas in evas units.">evas_output_viewport_set</a>(canvas, 0, 0, width, height);

   einfo = (Evas_Engine_Info_Buffer *)<a class="code" href="group__Evas__Canvas.html#ga33a6cd095bc7499dbfcb39ad253607b1" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">// ARGB32 is sizeof(int), that is 4 bytes, per pixel</span>
   pixels = malloc(width * height * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
   <span class="keywordflow">if</span> (!pixels)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not allocate canvas pixels!\n&quot;</span>, stderr);
    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
    <span class="keywordflow">return</span> NULL;
     }

   einfo-&gt;info.depth_type = EVAS_ENGINE_BUFFER_DEPTH_ARGB32;
   einfo-&gt;info.dest_buffer = pixels;
   einfo-&gt;info.dest_buffer_row_bytes = width * <span class="keyword">sizeof</span>(int);
   einfo-&gt;info.use_color_key = 0;
   einfo-&gt;info.alpha_threshold = 0;
   einfo-&gt;info.func.new_update_region = NULL;
   einfo-&gt;info.func.free_update_region = NULL;
   <a class="code" href="group__Evas__Canvas.html#ga7244385cf5bad0591ab82e4437c4694b" title="Applies the engine settings for the given evas from the given Evas_Engine_Info structure.">evas_engine_info_set</a>(canvas, (<a class="code" href="struct__Evas__Engine__Info.html">Evas_Engine_Info</a> *)einfo);

   <span class="keywordflow">return</span> canvas;
}

<span class="keyword">static</span> <span class="keywordtype">void</span> destroy_canvas(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas)
{
   Evas_Engine_Info_Buffer *einfo;

   einfo = (Evas_Engine_Info_Buffer *)<a class="code" href="group__Evas__Canvas.html#ga33a6cd095bc7499dbfcb39ad253607b1" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
    <span class="keywordflow">return</span>;
     }

   free(einfo-&gt;info.dest_buffer);
   <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
}

<span class="keyword">static</span> <span class="keywordtype">void</span> draw_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas)
{
   <a class="code" href="struct__Eina__List.html">Eina_List</a> *updates, *n;
   <a class="code" href="group__Eina__Rectangle__Group.html#gad1f49db9be2cd747f458ebf4718b6228">Eina_Rectangle</a> *update;

   <span class="comment">// render and get the updated rectangles:</span>
   updates = <a class="code" href="group__Evas__Canvas.html#ga1867d9f5f97545418598496af93e4c71" title="Force immediate renderization of the given Evas canvas.">evas_render_updates</a>(canvas);

   <span class="comment">// informative only here, just print the updated areas:</span>
   <a class="code" href="group__Eina__List__Group.html#gad02f746a08ee0b12b7ed66d4bc0d71d8" title="Definition for the macro to iterate over a list.">EINA_LIST_FOREACH</a>(updates, n, update)
     printf(&quot;UPDATED REGION: pos: %3d, %3d    size: %3dx%3d\n&quot;,
        update-&gt;x, update-&gt;y, update-&gt;w, update-&gt;h);

   <span class="comment">// free list of updates</span>
   <a class="code" href="group__Evas__Canvas.html#ga038d98c7c13a86b6ba4de51f8aba3595">evas_render_updates_free</a>(updates);
}

static <span class="keywordtype">void</span> save_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas, const <span class="keywordtype">char</span> *dest)
{
   Evas_Engine_Info_Buffer *einfo;
   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *pixels, *pixels_end;
   <span class="keywordtype">int</span> width, height;
   FILE *f;

   einfo = (Evas_Engine_Info_Buffer *)<a class="code" href="group__Evas__Canvas.html#ga33a6cd095bc7499dbfcb39ad253607b1" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <span class="keywordflow">return</span>;
     }
   <a class="code" href="group__Evas__Canvas.html#gab2bf31509c58449bc94473f81b1e5ed5" title="Retrieve the output size of the render engine of the given evas.">evas_output_size_get</a>(canvas, &amp;width, &amp;height);

   f = fopen(dest, <span class="stringliteral">&quot;wb+&quot;</span>);
   <span class="keywordflow">if</span> (!f)
     {
    fprintf(stderr, <span class="stringliteral">&quot;ERROR: could not open for writing &#39;%s&#39;: %s\n&quot;</span>,
        dest, strerror(errno));
    <span class="keywordflow">return</span>;
     }

   pixels = einfo-&gt;info.dest_buffer;
   pixels_end = pixels + (width * height);

   <span class="comment">// PPM P6 format is dead simple to write:</span>
   fprintf(f, <span class="stringliteral">&quot;P6\n%d %d\n255\n&quot;</span>,  width, height);
   <span class="keywordflow">for</span> (; pixels &lt; pixels_end; pixels++)
     {
    <span class="keywordtype">int</span> r, g, b;

    r = ((*pixels) &amp; 0xff0000) &gt;&gt; 16;
    g = ((*pixels) &amp; 0x00ff00) &gt;&gt; 8;
    b = (*pixels) &amp; 0x0000ff;

    fprintf(f, <span class="stringliteral">&quot;%c%c%c&quot;</span>, r, g, b);
     }

   fclose(f);
   printf(<span class="stringliteral">&quot;saved scene as &#39;%s&#39;\n&quot;</span>, dest);
}
</pre></div><p>More examples can be found at <a class="el" href="evas_examples.html">Evas Examples</a>. </p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
