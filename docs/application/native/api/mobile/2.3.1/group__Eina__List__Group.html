<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: List</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Mobile&#160;Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<div class="title">List</div>  </div>
<div class="ingroups"><a class="el" href="group__Eina__Containers__Group.html">Containers</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga92ec14d1a1040a361c4d8cd0ab7b0ecc">eina_list_append</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the given data to the given linked list.  <a href="#ga92ec14d1a1040a361c4d8cd0ab7b0ecc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga9f35bfc7c5b798014c3e0a74bc6f39ad">eina_list_prepend</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the given data to the given linked list.  <a href="#ga9f35bfc7c5b798014c3e0a74bc6f39ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga4676c189ca4bcfa22d7ecfbcd00200ae">eina_list_append_relative</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data, const void *relative)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given data into the given linked list after the specified data.  <a href="#ga4676c189ca4bcfa22d7ecfbcd00200ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gafa705d4483487e53d1be93a30e43c66d">eina_list_append_relative_list</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *relative)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a list node to a linked list after the specified member.  <a href="#gafa705d4483487e53d1be93a30e43c66d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gad44370d18554ff250d2e9ddac4653caf">eina_list_prepend_relative</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data, const void *relative)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a data pointer to a linked list before the specified member.  <a href="#gad44370d18554ff250d2e9ddac4653caf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga03a77b1579ee83bcab4bc3d67375d4b1">eina_list_prepend_relative_list</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *relative)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a list node to a linked list before the specified member.  <a href="#ga03a77b1579ee83bcab4bc3d67375d4b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga00740e04bfb71ad5c9ac145f766de3a4">eina_list_sorted_insert</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new node into a sorted list.  <a href="#ga00740e04bfb71ad5c9ac145f766de3a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga7c0c6e07aa592a1cb2e010049a718035">eina_list_remove</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first instance of the specified data from the given list.  <a href="#ga7c0c6e07aa592a1cb2e010049a718035"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga7edefe0975beecc76c02525fb9200f5a">eina_list_remove_list</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *remove_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified list node.  <a href="#ga7edefe0975beecc76c02525fb9200f5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga1037e7ab9d39bece24d864526332828c">eina_list_promote_list</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *move_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specified data to the head of the list.  <a href="#ga1037e7ab9d39bece24d864526332828c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga082644881a2333bd16208c00931703cd">eina_list_demote_list</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *move_list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the specified data to the tail of the list.  <a href="#ga082644881a2333bd16208c00931703cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga48e7356e1e0975bcabfce6f5c4ec9160">eina_list_data_find</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a member of a list and returns the member.  <a href="#ga48e7356e1e0975bcabfce6f5c4ec9160"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga860144725b63d93b8f84cdf1d816bda8">eina_list_data_find_list</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a member of a list and returns the list node containing that member.  <a href="#ga860144725b63d93b8f84cdf1d816bda8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga46a38e2bf6b9a52b7a5dd17c63ca5f60">eina_list_move</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **to, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **from, void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a data pointer from one list to another.  <a href="#ga46a38e2bf6b9a52b7a5dd17c63ca5f60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga7e8227ff134ddf5c70fa0a0ede35fe64">eina_list_move_list</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **to, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **from, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a list node from one list to another.  <a href="#ga7e8227ff134ddf5c70fa0a0ede35fe64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga608bd2fbf06293a1b794648990703ab4">eina_list_free</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an entire list and all the nodes, ignoring the data contained.  <a href="#ga608bd2fbf06293a1b794648990703ab4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga4bd18d6ffc9920cd904bb7769f2fad8e">eina_list_nth</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, unsigned int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the nth member's data pointer in a list.  <a href="#ga4bd18d6ffc9920cd904bb7769f2fad8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gad4a1e3b0fdecd8ed4cb2ff592ceeb553">eina_list_nth_list</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, unsigned int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the nth member's list node in a list.  <a href="#gad4a1e3b0fdecd8ed4cb2ff592ceeb553"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga2f0c56af6f6ae8f149c317d4152b407d">eina_list_reverse</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses all the elements in the list.  <a href="#ga2f0c56af6f6ae8f149c317d4152b407d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga67cb29eef0bf0a3cb2cc160ae506a07f">eina_list_reverse_clone</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones (copies) all the elements in the list in the reverse order.  <a href="#ga67cb29eef0bf0a3cb2cc160ae506a07f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gae26360b939fc874e7ae4fab705bd3ac3">eina_list_clone</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones (copies) all the elements in the list in the exactly same order.  <a href="#gae26360b939fc874e7ae4fab705bd3ac3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gaa634ce6790e626fd057ecdcfdc841d47">eina_list_sort</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, unsigned int limit, <a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a> func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a list according to the ordering that <em>func</em> returns.  <a href="#gaa634ce6790e626fd057ecdcfdc841d47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga743c5a32e64f227059d2baa4dba63a6b">eina_list_merge</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *left, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *right)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two lists.  <a href="#ga743c5a32e64f227059d2baa4dba63a6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga66747ee5bad3c35ea268385f6c5e174b">eina_list_sorted_merge</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *left, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *right, <a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a> func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted lists according to the ordering that <em>func</em> returns.  <a href="#ga66747ee5bad3c35ea268385f6c5e174b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gaf45625cf0f450aae2a4e949539b22374">eina_list_split_list</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *relative, <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **right)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a list into 2 lists.  <a href="#gaf45625cf0f450aae2a4e949539b22374"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga44af3419fd1f66ffefc4998e54c4ca70">eina_list_search_sorted_near_list</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a> func, const void *data, int *result_cmp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node nearest to data in the sorted list.  <a href="#ga44af3419fd1f66ffefc4998e54c4ca70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga6a0564d119664930b3a41657c1551e09">eina_list_search_sorted_list</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node if data is in the sorted list.  <a href="#ga6a0564d119664930b3a41657c1551e09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gae18055abaafef1714bd9f2fd3fd0cc45">eina_list_search_sorted</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node data if it is in the sorted list.  <a href="#gae18055abaafef1714bd9f2fd3fd0cc45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga326ba1ce720272160559fcca1abb100d">eina_list_search_unsorted_list</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node if data is in the unsorted list.  <a href="#ga326ba1ce720272160559fcca1abb100d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga2c093bfd321df8f286fcfeb3d13d675f">eina_list_search_unsorted</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, <a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node data if it is in the unsorted list.  <a href="#ga2c093bfd321df8f286fcfeb3d13d675f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga4c3a9eb5062f3b44c5dcef845cc7a72a">eina_list_last</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the last list node in the list.  <a href="#ga4c3a9eb5062f3b44c5dcef845cc7a72a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gac264188a790dda0761d587578605bfd1">eina_list_next</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next list node after the specified list node.  <a href="#gac264188a790dda0761d587578605bfd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gacd8294cbab7b4e053bcf754a92dd68e3">eina_list_prev</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previous list node before the specified list node.  <a href="#gacd8294cbab7b4e053bcf754a92dd68e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c">eina_list_data_get</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the list node data member.  <a href="#gaec845f0bfb16a14e8d7f0cd508ca7e9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga213776ffa28b780440da26f673917687">eina_list_data_set</a> (<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the list node data member.  <a href="#ga213776ffa28b780440da26f673917687"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga301729054a498a2df09a5f1dd760697e">eina_list_count</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the count of the number of items in a list.  <a href="#ga301729054a498a2df09a5f1dd760697e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Iterator__Group.html#ga15b975bb881d955249ce13d4ebc96948">Eina_Iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gabcfb6a861aa7c0db0ee36252ac2a254d">eina_list_iterator_new</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new iterator associated to a list.  <a href="#gabcfb6a861aa7c0db0ee36252ac2a254d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Iterator__Group.html#ga15b975bb881d955249ce13d4ebc96948">Eina_Iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gaaa11ab61d3d86c9350cb0757468a9089">eina_list_iterator_reversed_new</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new reversed iterator associated to a list.  <a href="#gaaa11ab61d3d86c9350cb0757468a9089"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Accessor__Group.html#ga65199ea5201a1867471028477dc26744">Eina_Accessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga6901b2ea29c9bc34a486dae00d3cf608">eina_list_accessor_new</a> (const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new accessor associated to a list.  <a href="#ga6901b2ea29c9bc34a486dae00d3cf608"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3295e1210efea1fb0fd6acbf3cbc1f29"></a><!-- doxytag: member="Eina_List_Group::Eina_List" ref="ga3295e1210efea1fb0fd6acbf3cbc1f29" args="" -->
typedef struct <a class="el" href="struct__Eina__List.html">_Eina_List</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure type for a generic double linked list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae6fd9c3d1d8d2c9dd01ef647494f5862"></a><!-- doxytag: member="Eina_List_Group::Eina_List_Accounting" ref="gae6fd9c3d1d8d2c9dd01ef647494f5862" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="struct__Eina__List__Accounting.html">_Eina_List_Accounting</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gae6fd9c3d1d8d2c9dd01ef647494f5862">Eina_List_Accounting</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure type of the cache used to store the last element of a list and the number of elements, for fast access. <br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gad02f746a08ee0b12b7ed66d4bc0d71d8">EINA_LIST_FOREACH</a>(list, l, data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the macro to iterate over a list.  <a href="#gad02f746a08ee0b12b7ed66d4bc0d71d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga8a98f0f44dba13749d27337837b3cfb1">EINA_LIST_REVERSE_FOREACH</a>(list, l, data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the macro to iterate over a list in the reverse order.  <a href="#ga8a98f0f44dba13749d27337837b3cfb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#ga5b4d2aac696cd2558aaed03e3929d873">EINA_LIST_FOREACH_SAFE</a>(list, l, l_next, data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the macro to iterate over a list with support for node deletion.  <a href="#ga5b4d2aac696cd2558aaed03e3929d873"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gad1bdb753e4c9eca59a6da87094d516b0">EINA_LIST_REVERSE_FOREACH_SAFE</a>(list, l, l_prev, data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the macro to iterate over a list in the reverse order with support for deletion.  <a href="#gad1bdb753e4c9eca59a6da87094d516b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__List__Group.html#gae27a2c686a0a11693f9b06957c9bba83">EINA_LIST_FREE</a>(list, data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the macro to remove each list node while having access to each node's data.  <a href="#gae27a2c686a0a11693f9b06957c9bba83"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2> </h2>
<p>This group discusses the functions that provide double linked list management. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Eina_List is a doubly linked list. It can store data of any type in the form of void pointers. It has convenience functions to do all the common operations, which means it should rarely, if ever, be necessary to directly access the struct's fields. Nevertheless it can be useful to understand the inner workings of the data structure being used.</dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> nodes keep references to the previous node, the next node, its data, and to an accounting structure.</dd></dl>
<div class="image">
<img src="eina_list.png" alt="eina_list.png"/>
</div>
  
 <a href="eina_list.png">Full-size</a>
   <dl class="remark"><dt><b>Remarks:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#gae6fd9c3d1d8d2c9dd01ef647494f5862">Eina_List_Accounting</a> is used to improve the performance of some functions. It is private and <b>should not</b> be modified. It contains a reference to the end of the list and the number of elements in the list.</dd>
<dd>
Every function that modifies the contents of the list returns a pointer to the head of the list and it is essential that this pointer be used in any future references to the list.</dd>
<dd>
Most functions have two versions that have the same effect but operate on different arguments, the <em>plain</em> functions operate over data(eg.: <a class="el" href="group__Eina__List__Group.html#ga4676c189ca4bcfa22d7ecfbcd00200ae">eina_list_append_relative</a>, <a class="el" href="group__Eina__List__Group.html#ga7c0c6e07aa592a1cb2e010049a718035">eina_list_remove</a>, <a class="el" href="group__Eina__List__Group.html#ga48e7356e1e0975bcabfce6f5c4ec9160">eina_list_data_find</a>), the <em>list</em> versions of these functions operate on <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> nodes.</dd>
<dd>
You must <b>always</b> use the pointer to the first element of the list, as the list. </dd>
<dd>
You must <b>never</b> use a pointer to an element in the middle of the list, as the list. </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gad02f746a08ee0b12b7ed66d4bc0d71d8"></a><!-- doxytag: member="eina_list.h::EINA_LIST_FOREACH" ref="gad02f746a08ee0b12b7ed66d4bc0d71d8" args="(list, l, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Eina__List__Group.html#gad02f746a08ee0b12b7ed66d4bc0d71d8">EINA_LIST_FOREACH</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (l = list,                         \
       data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(l);     \
       l;                                \
       l = <a class="code" href="group__Eina__List__Group.html#gac264188a790dda0761d587578605bfd1" title="Gets the next list node after the specified list node.">eina_list_next</a>(l),            \
       data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(l))
</pre></div>
<p>Definition of the macro to iterate over a list. </p>
<p>This macro iterates over <em>list</em> from the first element to the last. <em>data</em> is the data related to the current element. <em>l</em> is an <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29" title="The structure type for a generic double linked list.">Eina_List</a> used as the list iterator.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The following diagram ilustrates this macro iterating over a list of four elements("one", "two", "three" and "four"):</dd></dl>
<div class="image">
<img src="eina-list-foreach.png" alt="eina-list-foreach.png"/>
</div>
  
 <a href="eina-list-foreach.png">Full-size</a>
  <p>It can be used to free list data, as in the following example:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;
 <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *l;
 <span class="keywordtype">char</span>      *data;

 <span class="comment">// list is already filled,</span>
 <span class="comment">// its elements are just duplicated strings,</span>
 <span class="comment">// EINA_LIST_FOREACH will be used to free those strings</span>

 <a class="code" href="group__Eina__List__Group.html#gad02f746a08ee0b12b7ed66d4bc0d71d8" title="Definition of the macro to iterate over a list.">EINA_LIST_FOREACH</a>(list, l, data)
   free(data);
 <a class="code" href="group__Eina__List__Group.html#ga608bd2fbf06293a1b794648990703ab4" title="Frees an entire list and all the nodes, ignoring the data contained.">eina_list_free</a>(list);
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd>This is not the optimal way to release memory allocated to a list, since it iterates over the list twice. For an optimized algorithm, use <a class="el" href="group__Eina__List__Group.html#gae27a2c686a0a11693f9b06957c9bba83" title="Definition of the macro to remove each list node while having access to each node&#39;s data...">EINA_LIST_FREE()</a>.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd>
<dd>
Be careful when deleting list nodes. If you remove the current node and continue iterating, the code fails because the macro is not able to get the next node. Notice that it's OK to remove any node if you stop the loop after that. For destructive operations such as this, consider using <a class="el" href="group__Eina__List__Group.html#ga5b4d2aac696cd2558aaed03e3929d873" title="Definition of the macro to iterate over a list with support for node deletion.">EINA_LIST_FOREACH_SAFE()</a>.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to iterate over </td></tr>
    <tr><td class="paramname">l</td><td>A list that is used as an iterator and points to the current node </td></tr>
    <tr><td class="paramname">data</td><td>The current item's data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b4d2aac696cd2558aaed03e3929d873"></a><!-- doxytag: member="eina_list.h::EINA_LIST_FOREACH_SAFE" ref="ga5b4d2aac696cd2558aaed03e3929d873" args="(list, l, l_next, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Eina__List__Group.html#ga5b4d2aac696cd2558aaed03e3929d873">EINA_LIST_FOREACH_SAFE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l_next, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (l = list,                                      \
       l_next = <a class="code" href="group__Eina__List__Group.html#gac264188a790dda0761d587578605bfd1" title="Gets the next list node after the specified list node.">eina_list_next</a>(l),                    \
       data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(l);                  \
       l;                                             \
       l = l_next,                                    \
       l_next = <a class="code" href="group__Eina__List__Group.html#gac264188a790dda0761d587578605bfd1" title="Gets the next list node after the specified list node.">eina_list_next</a>(l),                    \
       data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(l))
</pre></div>
<p>Definition of the macro to iterate over a list with support for node deletion. </p>
<p>This macro iterates over <em>list</em> from the first element to the last. <em>data</em> is the data related to the current element. <em>l</em> is an <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29" title="The structure type for a generic double linked list.">Eina_List</a> used as the list iterator.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Since this macro stores a pointer to the next list node in <em>l_next</em>, deleting the current node and continuing looping is safe.</dd>
<dd>
The following diagram ilustrates this macro iterating over a list of four elements("one", "two", "three" and "four"):</dd></dl>
<div class="image">
<img src="eina-list-foreach-safe.png" alt="eina-list-foreach-safe.png"/>
</div>
  
 <a href="eina-list-foreach-safe.png">Full-size</a>
  <p>This macro can be used to free list nodes, as in the following example:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;
 <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *l;
 <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *l_next;
 <span class="keywordtype">char</span>      *data;

 <span class="comment">// list is already filled,</span>
 <span class="comment">// its elements are just duplicated strings,</span>
 <span class="comment">// EINA_LIST_FOREACH_SAFE will be used to free elements that match &quot;key&quot;.</span>

 <a class="code" href="group__Eina__List__Group.html#ga5b4d2aac696cd2558aaed03e3929d873" title="Definition of the macro to iterate over a list with support for node deletion.">EINA_LIST_FOREACH_SAFE</a>(list, l, l_next, data)
   if (strcmp(data, &quot;key&quot;) == 0) {
      free(data);
      list = <a class="code" href="group__Eina__List__Group.html#ga7edefe0975beecc76c02525fb9200f5a" title="Removes the specified list node.">eina_list_remove_list</a>(list, l);
   }
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to iterate over </td></tr>
    <tr><td class="paramname">l</td><td>A list that is used as an iterator and points to the current node </td></tr>
    <tr><td class="paramname">l_next</td><td>A list that is used as an iterator and points to the next node </td></tr>
    <tr><td class="paramname">data</td><td>The current item's data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae27a2c686a0a11693f9b06957c9bba83"></a><!-- doxytag: member="eina_list.h::EINA_LIST_FREE" ref="gae27a2c686a0a11693f9b06957c9bba83" args="(list, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Eina__List__Group.html#gae27a2c686a0a11693f9b06957c9bba83">EINA_LIST_FREE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(list);          \
       list;                                     \
       list = <a class="code" href="group__Eina__List__Group.html#ga7edefe0975beecc76c02525fb9200f5a" title="Removes the specified list node.">eina_list_remove_list</a>(list, list), \
       data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(list))
</pre></div>
<p>Definition of the macro to remove each list node while having access to each node's data. </p>
<p>This macro calls <a class="el" href="group__Eina__List__Group.html#ga7edefe0975beecc76c02525fb9200f5a" title="Removes the specified list node.">eina_list_remove_list</a> for each list node and stores the data contained in the current node in <em>data</em>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The following diagram ilustrates this macro iterating over a list of four elements("one", "two", "three" and "four"):</dd></dl>
<div class="image">
<img src="eina-list-free.png" alt="eina-list-free.png"/>
</div>
  
 <a href="eina-list-free.png">Full-size</a>
  <p>If you do not need to release node data, it is easier to call <a class="el" href="group__Eina__List__Group.html#ga608bd2fbf06293a1b794648990703ab4" title="Frees an entire list and all the nodes, ignoring the data contained.">eina_list_free()</a>.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;
 <span class="keywordtype">char</span>      *data;

 <span class="comment">// list is already filled,</span>
 <span class="comment">// its elements are just duplicated strings,</span>

 <a class="code" href="group__Eina__List__Group.html#gae27a2c686a0a11693f9b06957c9bba83" title="Definition of the macro to remove each list node while having access to each node&#39;s data...">EINA_LIST_FREE</a>(list, data)
   free(data);
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list that is cleared </td></tr>
    <tr><td class="paramname">data</td><td>The current node's data</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#ga608bd2fbf06293a1b794648990703ab4" title="Frees an entire list and all the nodes, ignoring the data contained.">eina_list_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a98f0f44dba13749d27337837b3cfb1"></a><!-- doxytag: member="eina_list.h::EINA_LIST_REVERSE_FOREACH" ref="ga8a98f0f44dba13749d27337837b3cfb1" args="(list, l, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Eina__List__Group.html#ga8a98f0f44dba13749d27337837b3cfb1">EINA_LIST_REVERSE_FOREACH</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (l = <a class="code" href="group__Eina__List__Group.html#ga4c3a9eb5062f3b44c5dcef845cc7a72a" title="Gets the last list node in the list.">eina_list_last</a>(list),                 \
       data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(l);             \
       l;                                        \
       l = <a class="code" href="group__Eina__List__Group.html#gacd8294cbab7b4e053bcf754a92dd68e3" title="Gets the previous list node before the specified list node.">eina_list_prev</a>(l),                    \
       data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(l))
</pre></div>
<p>Definition of the macro to iterate over a list in the reverse order. </p>
<p>This macro works like EINA_LIST_FOREACH, but iterates from the last element of a list to the first. <em>data</em> is the data related to the current element, while <em>l</em> is an <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29" title="The structure type for a generic double linked list.">Eina_List</a> that is used as the list iterator.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The following diagram ilustrates this macro iterating over a list of four elements("one", "two", "three" and "four"):</dd></dl>
<div class="image">
<img src="eina-list-reverse-foreach.png" alt="eina-list-reverse-foreach.png"/>
</div>
  
 <a href="eina-list-reverse-foreach.png">Full-size</a>
  <p>It can be used to free list data, as in the following example:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;
 <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *l;
 <span class="keywordtype">char</span>      *data;

 <span class="comment">// list is already filled,</span>
 <span class="comment">// its elements are just duplicated strings,</span>
 <span class="comment">// EINA_LIST_REVERSE_FOREACH will be used to free those strings</span>

 <a class="code" href="group__Eina__List__Group.html#ga8a98f0f44dba13749d27337837b3cfb1" title="Definition of the macro to iterate over a list in the reverse order.">EINA_LIST_REVERSE_FOREACH</a>(list, l, data)
   free(data);
 <a class="code" href="group__Eina__List__Group.html#ga608bd2fbf06293a1b794648990703ab4" title="Frees an entire list and all the nodes, ignoring the data contained.">eina_list_free</a>(list);
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd>This is not the optimal way to release memory allocated to a list, since it iterates over the list twice. For an optimized algorithm, use <a class="el" href="group__Eina__List__Group.html#gae27a2c686a0a11693f9b06957c9bba83" title="Definition of the macro to remove each list node while having access to each node&#39;s data...">EINA_LIST_FREE()</a>.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd>
<dd>
Be careful when deleting list nodes. If you remove the current node and continue iterating, the code fails because the macro is not able to get the next node. Notice that it's OK to remove any node if you stop the loop after that. For destructive operations such as this, consider using <a class="el" href="group__Eina__List__Group.html#gad1bdb753e4c9eca59a6da87094d516b0" title="Definition of the macro to iterate over a list in the reverse order with support for deletion...">EINA_LIST_REVERSE_FOREACH_SAFE()</a>.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to iterate over </td></tr>
    <tr><td class="paramname">l</td><td>A list that is used as an iterator and points to the current node </td></tr>
    <tr><td class="paramname">data</td><td>The current item's data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1bdb753e4c9eca59a6da87094d516b0"></a><!-- doxytag: member="eina_list.h::EINA_LIST_REVERSE_FOREACH_SAFE" ref="gad1bdb753e4c9eca59a6da87094d516b0" args="(list, l, l_prev, data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Eina__List__Group.html#gad1bdb753e4c9eca59a6da87094d516b0">EINA_LIST_REVERSE_FOREACH_SAFE</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">list, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l_prev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">for</span> (l = <a class="code" href="group__Eina__List__Group.html#ga4c3a9eb5062f3b44c5dcef845cc7a72a" title="Gets the last list node in the list.">eina_list_last</a>(list),                              \
       l_prev = <a class="code" href="group__Eina__List__Group.html#gacd8294cbab7b4e053bcf754a92dd68e3" title="Gets the previous list node before the specified list node.">eina_list_prev</a>(l),                            \
       data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(l);                          \
       l;                                                     \
       l = l_prev,                                            \
       l_prev = <a class="code" href="group__Eina__List__Group.html#gacd8294cbab7b4e053bcf754a92dd68e3" title="Gets the previous list node before the specified list node.">eina_list_prev</a>(l),                            \
       data = <a class="code" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c" title="Gets the list node data member.">eina_list_data_get</a>(l))
</pre></div>
<p>Definition of the macro to iterate over a list in the reverse order with support for deletion. </p>
<p>This macro works like EINA_LIST_FOREACH_SAFE, but iterates from the last element of a list to the first. <em>data</em> is the data related to the current element, while <em>l</em> is an <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29" title="The structure type for a generic double linked list.">Eina_List</a> that is used as the list iterator.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Since this macro stores a pointer to the previous list node in <em>l_prev</em>, deleting the current node and continuing looping is safe.</dd>
<dd>
The following diagram ilustrates this macro iterating over a list of four elements("one", "two", "three" and "four"):</dd></dl>
<div class="image">
<img src="eina-list-reverse-foreach-safe.png" alt="eina-list-reverse-foreach-safe.png"/>
</div>
  
 <a href="eina-list-reverse-foreach-safe.png">Full-size</a>
  <p>This macro can be used to free list nodes, as in the following example:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;
 <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *l;
 <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *l_prev;
 <span class="keywordtype">char</span>       *data;

 <span class="comment">// list is already filled,</span>
 <span class="comment">// its elements are just duplicated strings,</span>
 <span class="comment">// EINA_LIST_REVERSE_FOREACH_SAFE will be used to free elements that match &quot;key&quot;.</span>

 <a class="code" href="group__Eina__List__Group.html#gad1bdb753e4c9eca59a6da87094d516b0" title="Definition of the macro to iterate over a list in the reverse order with support for deletion...">EINA_LIST_REVERSE_FOREACH_SAFE</a>(list, l, l_prev, data)
   if (strcmp(data, &quot;key&quot;) == 0) {
      free(data);
      list = <a class="code" href="group__Eina__List__Group.html#ga7edefe0975beecc76c02525fb9200f5a" title="Removes the specified list node.">eina_list_remove_list</a>(list, l);
   }
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to iterate over </td></tr>
    <tr><td class="paramname">l</td><td>A list that is used as an iterator and points to the current node </td></tr>
    <tr><td class="paramname">l_prev</td><td>A list that is used as an iterator and points to the previous node </td></tr>
    <tr><td class="paramname">data</td><td>The current item's data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6901b2ea29c9bc34a486dae00d3cf608"></a><!-- doxytag: member="eina_list.h::eina_list_accessor_new" ref="ga6901b2ea29c9bc34a486dae00d3cf608" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Accessor__Group.html#ga65199ea5201a1867471028477dc26744">Eina_Accessor</a>* <a class="el" href="group__Eina__List__Group.html#ga6901b2ea29c9bc34a486dae00d3cf608">eina_list_accessor_new</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new accessor associated to a list. </p>
<p>This function returns a newly allocated accessor associated to <em>list</em>. If <em>list</em> is <code>NULL</code> or the count member of <em>list</em> is less than or equal to 0, this function returns <code>NULL</code>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If the memory cannot be allocated, <code>NULL</code> is returned and <a class="el" href="group__Eina__Error__Group.html#gad5e9a56fa33593d588df95bf6413964a" title="The error identifier corresponding to lack of memory.">EINA_ERROR_OUT_OF_MEMORY</a> is set. Otherwise, a valid accessor is returned.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new accessor </dd></dl>

</div>
</div>
<a class="anchor" id="ga92ec14d1a1040a361c4d8cd0ab7b0ecc"></a><!-- doxytag: member="eina_list.h::eina_list_append" ref="ga92ec14d1a1040a361c4d8cd0ab7b0ecc" args="(Eina_List *list, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga92ec14d1a1040a361c4d8cd0ab7b0ecc">eina_list_append</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the given data to the given linked list. </p>
<p>This function appends <em>data</em> to <em>list</em>. If <em>list</em> is <code>NULL</code>, a new list is returned. On success, a new list pointer that should be used in place of the one given to this function is returned. Otherwise, the old pointer is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The following example code demonstrates how to ensure that the given data has been successfully appended.</dd></dl>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list = NULL;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *my_data;

 list = <a class="code" href="group__Eina__List__Group.html#ga92ec14d1a1040a361c4d8cd0ab7b0ecc" title="Appends the given data to the given linked list.">eina_list_append</a>(list, my_data);
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list(or NULL).</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The given list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to append </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga4676c189ca4bcfa22d7ecfbcd00200ae"></a><!-- doxytag: member="eina_list.h::eina_list_append_relative" ref="ga4676c189ca4bcfa22d7ecfbcd00200ae" args="(Eina_List *list, const void *data, const void *relative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga4676c189ca4bcfa22d7ecfbcd00200ae">eina_list_append_relative</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>relative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts the given data into the given linked list after the specified data. </p>
<p>This function inserts <em>data</em> to <em>list</em> after <em>relative</em>. If <em>relative</em> is not in the list, <em>data</em> is appended to the end of the list. If <em>list</em> is <code>NULL</code>, a new list is returned. If there are multiple instances of <em>relative</em> in the list, <em>data</em> is inserted after the first instance.On success, a new list pointer that should be used in place of the one given to this function is returned. Otherwise, the old pointer is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The following example code demonstrates how to ensure that the given data has been successfully inserted.</dd></dl>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list = NULL;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *my_data;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *relative_member;

 list = <a class="code" href="group__Eina__List__Group.html#ga92ec14d1a1040a361c4d8cd0ab7b0ecc" title="Appends the given data to the given linked list.">eina_list_append</a>(list, relative_member);
 list = <a class="code" href="group__Eina__List__Group.html#ga4676c189ca4bcfa22d7ecfbcd00200ae" title="Inserts the given data into the given linked list after the specified data.">eina_list_append_relative</a>(list, my_data, relative_member);
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The given linked list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relative</td><td>The data to insert after </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gafa705d4483487e53d1be93a30e43c66d"></a><!-- doxytag: member="eina_list.h::eina_list_append_relative_list" ref="gafa705d4483487e53d1be93a30e43c66d" args="(Eina_List *list, const void *data, Eina_List *relative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#gafa705d4483487e53d1be93a30e43c66d">eina_list_append_relative_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>relative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends a list node to a linked list after the specified member. </p>
<p>This function inserts <em>data</em> to <em>list</em> after the list node <em>relative</em>. If <em>list</em> or <em>relative</em> is <code>NULL</code>, <em>data</em> is just appended to <em>list</em> using <a class="el" href="group__Eina__List__Group.html#ga92ec14d1a1040a361c4d8cd0ab7b0ecc" title="Appends the given data to the given linked list.">eina_list_append()</a>. If <em>list</em> is <code>NULL</code>, a new list is returned. If there are multiple instances of <em>relative</em> in the list, <em>data</em> is inserted after the first instance. On success, a new list pointer that should be used in place of the one given to this function is returned. Otherwise, the old pointer is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The given linked list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relative</td><td>The list node to insert after </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gae26360b939fc874e7ae4fab705bd3ac3"></a><!-- doxytag: member="eina_list.h::eina_list_clone" ref="gae26360b939fc874e7ae4fab705bd3ac3" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#gae26360b939fc874e7ae4fab705bd3ac3">eina_list_clone</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clones (copies) all the elements in the list in the exactly same order. </p>
<p>This function clones in an order which is same as the order of all the elements in <em>list</em>. If <em>list</em> is <code>NULL</code>, this functon returns <code>NULL</code>. This returns a copy of the given list.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><b>copy:</b> This copies the list and you should then use <a class="el" href="group__Eina__List__Group.html#ga608bd2fbf06293a1b794648990703ab4" title="Frees an entire list and all the nodes, ignoring the data contained.">eina_list_free()</a> when it is not required anymore.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new list that has been cloned</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#ga67cb29eef0bf0a3cb2cc160ae506a07f" title="Clones (copies) all the elements in the list in the reverse order.">eina_list_reverse_clone()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga301729054a498a2df09a5f1dd760697e"></a><!-- doxytag: member="eina_list.h::eina_list_count" ref="ga301729054a498a2df09a5f1dd760697e" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int <a class="el" href="group__Eina__List__Group.html#ga301729054a498a2df09a5f1dd760697e">eina_list_count</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the count of the number of items in a list. </p>
<p>This function returns the number of members that <em>list</em> contains. If the <em>list</em> is <code>NULL</code>, <code>0</code> is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is an order-1 operation and takes the same time regardless of the length of the list.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list whose count to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of members in the list </dd></dl>

</div>
</div>
<a class="anchor" id="ga48e7356e1e0975bcabfce6f5c4ec9160"></a><!-- doxytag: member="eina_list.h::eina_list_data_find" ref="ga48e7356e1e0975bcabfce6f5c4ec9160" args="(const Eina_List *list, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Eina__List__Group.html#ga48e7356e1e0975bcabfce6f5c4ec9160">eina_list_data_find</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a member of a list and returns the member. </p>
<p>This function searches in <em>list</em> from beginning to end for the first member whose data pointer is <em>data</em>. If it is found, <em>data</em> is returned, otherwise <code>NULL</code> is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *my_data;

 <span class="keywordflow">if</span> (<a class="code" href="group__Eina__List__Group.html#ga48e7356e1e0975bcabfce6f5c4ec9160" title="Finds a member of a list and returns the member.">eina_list_data_find</a>(list, my_data) == my_data)
   {
      printf(<span class="stringliteral">&quot;Found member %p\n&quot;</span>, my_data);
   }
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to search for data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data pointer to find in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The found member data pointer, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga860144725b63d93b8f84cdf1d816bda8"></a><!-- doxytag: member="eina_list.h::eina_list_data_find_list" ref="ga860144725b63d93b8f84cdf1d816bda8" args="(const Eina_List *list, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga860144725b63d93b8f84cdf1d816bda8">eina_list_data_find_list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a member of a list and returns the list node containing that member. </p>
<p>This function searches in <em>list</em> from beginning to end for the first member whose data pointer is <em>data</em>. If it is found, the list node containing the specified member is returned, otherwise <code>NULL</code> is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to search for data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data pointer to find in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The found members list node on success, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaec845f0bfb16a14e8d7f0cd508ca7e9c"></a><!-- doxytag: member="eina_list.h::eina_list_data_get" ref="gaec845f0bfb16a14e8d7f0cd508ca7e9c" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* <a class="el" href="group__Eina__List__Group.html#gaec845f0bfb16a14e8d7f0cd508ca7e9c">eina_list_data_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the list node data member. </p>
<p>This function returns the data member of the specified list node <em>list</em>. It is equivalent to list-&gt;data. If <code>list</code> is <code>NULL</code>, this function returns <code>NULL</code>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list node to get the data member of </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data member from the list node </dd></dl>

</div>
</div>
<a class="anchor" id="ga213776ffa28b780440da26f673917687"></a><!-- doxytag: member="eina_list.h::eina_list_data_set" ref="ga213776ffa28b780440da26f673917687" args="(Eina_List *list, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* <a class="el" href="group__Eina__List__Group.html#ga213776ffa28b780440da26f673917687">eina_list_data_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the list node data member. </p>
<p>This function sets the data member <em>data</em> of the specified list node <em>list</em>. It returns the previous data of the node. If <em>list</em> is <code>NULL</code>, this function returns <code>NULL</code>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list node to get the data member of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data member for the list node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The previous data value </dd></dl>

</div>
</div>
<a class="anchor" id="ga082644881a2333bd16208c00931703cd"></a><!-- doxytag: member="eina_list.h::eina_list_demote_list" ref="ga082644881a2333bd16208c00931703cd" args="(Eina_List *list, Eina_List *move_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga082644881a2333bd16208c00931703cd">eina_list_demote_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>move_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the specified data to the tail of the list. </p>
<p>This function moves <em>move_list</em> to the back of <em>list</em>. If the list is <code>NULL</code>, <code>NULL</code> is returned. If <em>move_list</em> is <code>NULL</code>, <em>list</em> is returned. Otherwise, a new list pointer that should be used in place of the one passed to this function is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;
 <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *l;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *my_data;
 <span class="keywordtype">void</span> *data;

 <a class="code" href="group__Eina__List__Group.html#gad02f746a08ee0b12b7ed66d4bc0d71d8" title="Definition of the macro to iterate over a list.">EINA_LIST_FOREACH</a>(list, l, data)
   {
     <span class="keywordflow">if</span> (data == my_data)
       {
         list = <a class="code" href="group__Eina__List__Group.html#ga082644881a2333bd16208c00931703cd" title="Moves the specified data to the tail of the list.">eina_list_demote_list</a>(list, l);
         <span class="keywordflow">break</span>;
       }
   }
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list handle to move the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">move_list</td><td>The list node to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new list handle to replace the old one </dd></dl>

</div>
</div>
<a class="anchor" id="ga608bd2fbf06293a1b794648990703ab4"></a><!-- doxytag: member="eina_list.h::eina_list_free" ref="ga608bd2fbf06293a1b794648990703ab4" args="(Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga608bd2fbf06293a1b794648990703ab4">eina_list_free</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees an entire list and all the nodes, ignoring the data contained. </p>
<p>This function frees all the nodes of <em>list</em>. It does not free the data of the nodes. To free them, use <a class="el" href="group__Eina__List__Group.html#gae27a2c686a0a11693f9b06957c9bba83" title="Definition of the macro to remove each list node while having access to each node&#39;s data...">EINA_LIST_FREE</a>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <code>NULL</code> pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gabcfb6a861aa7c0db0ee36252ac2a254d"></a><!-- doxytag: member="eina_list.h::eina_list_iterator_new" ref="gabcfb6a861aa7c0db0ee36252ac2a254d" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Iterator__Group.html#ga15b975bb881d955249ce13d4ebc96948">Eina_Iterator</a>* <a class="el" href="group__Eina__List__Group.html#gabcfb6a861aa7c0db0ee36252ac2a254d">eina_list_iterator_new</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new iterator associated to a list. </p>
<p>This function returns a newly allocated iterator associated to <em>list</em>. If <em>list</em> is <code>NULL</code> or the count member of <em>list</em> is less than or equal to <code>0</code>, this function still returns a valid iterator that always returns <code>false</code> on <a class="el" href="group__Eina__Iterator__Group.html#ga83346e93c32dbebc8fd66e4f278140c5" title="Returns the value of the current element and goes to the next one.">eina_iterator_next()</a>, thus keeping the API sane.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If the memory cannot be allocated, <code>NULL</code> is returned and <a class="el" href="group__Eina__Error__Group.html#gad5e9a56fa33593d588df95bf6413964a" title="The error identifier corresponding to lack of memory.">EINA_ERROR_OUT_OF_MEMORY</a> is set. Otherwise, a valid iterator is returned.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd>
<dd>
If the list structure changes then the iterator becomes invalid. That is, if you add or remove nodes this iterator's behavior is undefined and your program may crash.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new iterator </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa11ab61d3d86c9350cb0757468a9089"></a><!-- doxytag: member="eina_list.h::eina_list_iterator_reversed_new" ref="gaaa11ab61d3d86c9350cb0757468a9089" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Iterator__Group.html#ga15b975bb881d955249ce13d4ebc96948">Eina_Iterator</a>* <a class="el" href="group__Eina__List__Group.html#gaaa11ab61d3d86c9350cb0757468a9089">eina_list_iterator_reversed_new</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new reversed iterator associated to a list. </p>
<p>This function returns a newly allocated iterator associated to <em>list</em>. If <em>list</em> is <code>NULL</code> or the count member of <em>list</em> is less than or equal to 0, this function still returns a valid iterator that always returns <code>false</code> on <a class="el" href="group__Eina__Iterator__Group.html#ga83346e93c32dbebc8fd66e4f278140c5" title="Returns the value of the current element and goes to the next one.">eina_iterator_next()</a>, thus keeping the API sane.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Unlike <a class="el" href="group__Eina__List__Group.html#gabcfb6a861aa7c0db0ee36252ac2a254d" title="Returns a new iterator associated to a list.">eina_list_iterator_new()</a>, this walks the list backwards.</dd>
<dd>
If the memory cannot be allocated, <code>NULL</code> is returned and <a class="el" href="group__Eina__Error__Group.html#gad5e9a56fa33593d588df95bf6413964a" title="The error identifier corresponding to lack of memory.">EINA_ERROR_OUT_OF_MEMORY</a> is set. Otherwise, a valid iterator is returned.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd>
<dd>
If the list structure changes then the iterator becomes invalid. That is, if you add or remove nodes this iterator's behavior is undefined and your program may crash.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new iterator </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c3a9eb5062f3b44c5dcef845cc7a72a"></a><!-- doxytag: member="eina_list.h::eina_list_last" ref="ga4c3a9eb5062f3b44c5dcef845cc7a72a" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga4c3a9eb5062f3b44c5dcef845cc7a72a">eina_list_last</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the last list node in the list. </p>
<p>This function returns the last list node in the list <em>list</em>. If <em>list</em> is <code>NULL</code> or empty, <code>NULL</code> is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is an order-1 operation (it takes the same short time regardless of the length of the list).</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to get the last list node from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The last list node in the list </dd></dl>

</div>
</div>
<a class="anchor" id="ga743c5a32e64f227059d2baa4dba63a6b"></a><!-- doxytag: member="eina_list.h::eina_list_merge" ref="ga743c5a32e64f227059d2baa4dba63a6b" args="(Eina_List *left, Eina_List *right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga743c5a32e64f227059d2baa4dba63a6b">eina_list_merge</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges two lists. </p>
<p>This function puts <em>right</em> at the end of <em>left</em> and returns the head. Both <em>left</em> and <em>right</em> do not exist anymore after the merge.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Merge cost is O(n), <b>n</b> being the size of the smallest list. This is due to the need to fix accounting of that segment, making count and last access O(1).</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The head list to merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The tail list to merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new merged list </dd></dl>

</div>
</div>
<a class="anchor" id="ga46a38e2bf6b9a52b7a5dd17c63ca5f60"></a><!-- doxytag: member="eina_list.h::eina_list_move" ref="ga46a38e2bf6b9a52b7a5dd17c63ca5f60" args="(Eina_List **to, Eina_List **from, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Eina__List__Group.html#ga46a38e2bf6b9a52b7a5dd17c63ca5f60">eina_list_move</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves a data pointer from one list to another. </p>
<p>This function is a shortcut for doing the following: to = eina_list_append(to, data); from = eina_list_remove(from, data);</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td>The list to move the data to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">from</td><td>The list to move from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> on success, otherwise <code>EINA_FALSE</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e8227ff134ddf5c70fa0a0ede35fe64"></a><!-- doxytag: member="eina_list.h::eina_list_move_list" ref="ga7e8227ff134ddf5c70fa0a0ede35fe64" args="(Eina_List **to, Eina_List **from, Eina_List *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Eina__List__Group.html#ga7e8227ff134ddf5c70fa0a0ede35fe64">eina_list_move_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves a list node from one list to another. </p>
<p>This function is a shortcut for doing the following: to = eina_list_append(to, data-&gt;data); from = eina_list_remove_list(from, data);</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td>The list to move the data to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">from</td><td>The list to move from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The list node containing the data to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> on success, otherwise <code>EINA_FALSE</code> </dd></dl>

</div>
</div>
<a class="anchor" id="gac264188a790dda0761d587578605bfd1"></a><!-- doxytag: member="eina_list.h::eina_list_next" ref="gac264188a790dda0761d587578605bfd1" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#gac264188a790dda0761d587578605bfd1">eina_list_next</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the next list node after the specified list node. </p>
<p>This function returns the next list node after the current one in <em>list</em>. It is equivalent to list-&gt;next. If <em>list</em> is <code>NULL</code> or if no next list node exists, it returns <code>NULL</code>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list node to get the next list node from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next list node on success, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bd18d6ffc9920cd904bb7769f2fad8e"></a><!-- doxytag: member="eina_list.h::eina_list_nth" ref="ga4bd18d6ffc9920cd904bb7769f2fad8e" args="(const Eina_List *list, unsigned int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Eina__List__Group.html#ga4bd18d6ffc9920cd904bb7769f2fad8e">eina_list_nth</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the nth member's data pointer in a list. </p>
<p>This function returns the data pointer of element number <em>n</em>, in the <em>list</em>. The first element in the array is element number 0. If the element number <em>n</em> does not exist, <code>NULL</code> is returned. Otherwise, the data of the found element is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Worst case is O(n).</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to get the specified member number from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of the element (0 being the first) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data pointer stored in the specified element </dd></dl>

</div>
</div>
<a class="anchor" id="gad4a1e3b0fdecd8ed4cb2ff592ceeb553"></a><!-- doxytag: member="eina_list.h::eina_list_nth_list" ref="gad4a1e3b0fdecd8ed4cb2ff592ceeb553" args="(const Eina_List *list, unsigned int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#gad4a1e3b0fdecd8ed4cb2ff592ceeb553">eina_list_nth_list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the nth member's list node in a list. </p>
<p>This function returns the list node of element number <em>n</em>, in <em>list</em>. The first element in the array is element number 0. If the element number <em>n</em> does not exist or <em>list</em> is <code>NULL</code>, or <em>n</em> is greater than the count of the elements in <em>list</em> minus 1, <code>NULL</code> is returned. Otherwise the list node stored in the numbered element is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Worst case is O(n).</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to get the specfied member number from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of the element (0 being the first) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The list node stored in the numbered element </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f35bfc7c5b798014c3e0a74bc6f39ad"></a><!-- doxytag: member="eina_list.h::eina_list_prepend" ref="ga9f35bfc7c5b798014c3e0a74bc6f39ad" args="(Eina_List *list, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga9f35bfc7c5b798014c3e0a74bc6f39ad">eina_list_prepend</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepends the given data to the given linked list. </p>
<p>This function prepends <em>data</em> to <em>list</em>. If <em>list</em> is <code>NULL</code>, a new list is returned. On success, a new list pointer that should be used in place of the one given to this function is returned. Otherwise, the old pointer is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The following example code demonstrates how to ensure that the given data has been successfully prepended.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list = NULL;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *my_data;

 list = <a class="code" href="group__Eina__List__Group.html#ga9f35bfc7c5b798014c3e0a74bc6f39ad" title="Prepends the given data to the given linked list.">eina_list_prepend</a>(list, my_data);
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The given list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to prepend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gad44370d18554ff250d2e9ddac4653caf"></a><!-- doxytag: member="eina_list.h::eina_list_prepend_relative" ref="gad44370d18554ff250d2e9ddac4653caf" args="(Eina_List *list, const void *data, const void *relative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#gad44370d18554ff250d2e9ddac4653caf">eina_list_prepend_relative</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>relative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepends a data pointer to a linked list before the specified member. </p>
<p>This function inserts <em>data</em> to <em>list</em> before <em>relative</em>. If <em>relative</em> is not in the list, <em>data</em> is prepended to the list with <a class="el" href="group__Eina__List__Group.html#ga9f35bfc7c5b798014c3e0a74bc6f39ad" title="Prepends the given data to the given linked list.">eina_list_prepend()</a>. If <em>list</em> is <code>NULL</code>, a new list is returned. If there are multiple instances of <em>relative</em> in the list, <em>data</em> is inserted before the first instance. On success, a new list pointer that should be used in place of the one given to this function is returned. Otherwise, the old pointer is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The following code example demonstrates how to ensure that the given data has been successfully inserted.</dd></dl>
<div class="fragment"><pre class="fragment"> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list = NULL;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *my_data;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *relative_member;

 list = <a class="code" href="group__Eina__List__Group.html#ga92ec14d1a1040a361c4d8cd0ab7b0ecc" title="Appends the given data to the given linked list.">eina_list_append</a>(list, relative_member);
 list = <a class="code" href="group__Eina__List__Group.html#gad44370d18554ff250d2e9ddac4653caf" title="Prepends a data pointer to a linked list before the specified member.">eina_list_prepend_relative</a>(list, my_data, relative_member);
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The given linked list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relative</td><td>The data to insert before </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga03a77b1579ee83bcab4bc3d67375d4b1"></a><!-- doxytag: member="eina_list.h::eina_list_prepend_relative_list" ref="ga03a77b1579ee83bcab4bc3d67375d4b1" args="(Eina_List *list, const void *data, Eina_List *relative)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga03a77b1579ee83bcab4bc3d67375d4b1">eina_list_prepend_relative_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>relative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepends a list node to a linked list before the specified member. </p>
<p>This function inserts <em>data</em> to <em>list</em> before the list node <em>relative</em>. If <em>list</em> or <em>relative</em> is <code>NULL</code>, <em>data</em> is just prepended to <em>list</em> using <a class="el" href="group__Eina__List__Group.html#ga9f35bfc7c5b798014c3e0a74bc6f39ad" title="Prepends the given data to the given linked list.">eina_list_prepend()</a>. If <em>list</em> is <code>NULL</code>, a new list is returned. If there are multiple instances of <em>relative</em> in the list, <em>data</em> is inserted before the first instance. On success, a new list pointer that should be used in place of the one given to this function is returned. Otherwise, the old pointer is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The given linked list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relative</td><td>The list node to insert before </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list pointer </dd></dl>

</div>
</div>
<a class="anchor" id="gacd8294cbab7b4e053bcf754a92dd68e3"></a><!-- doxytag: member="eina_list.h::eina_list_prev" ref="gacd8294cbab7b4e053bcf754a92dd68e3" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#gacd8294cbab7b4e053bcf754a92dd68e3">eina_list_prev</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the previous list node before the specified list node. </p>
<p>This function returns the previous list node before the current one in <em>list</em>. It is equivalent to list-&gt;prev. If <em>list</em> is <code>NULL</code> or if no previous list node exists, it returns <code>NULL</code>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list node to get the previous list node from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The previous list node on success, otherwise <code>NULL</code> if no previous list node exists </dd></dl>

</div>
</div>
<a class="anchor" id="ga1037e7ab9d39bece24d864526332828c"></a><!-- doxytag: member="eina_list.h::eina_list_promote_list" ref="ga1037e7ab9d39bece24d864526332828c" args="(Eina_List *list, Eina_List *move_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga1037e7ab9d39bece24d864526332828c">eina_list_promote_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>move_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the specified data to the head of the list. </p>
<p>This function moves <em>move_list</em> to the front of <em>list</em>. If the list is <code>NULL</code>, <code>NULL</code> is returned. If <em>move_list</em> is <code>NULL</code>, <em>list</em> is returned. Otherwise, a new list pointer that should be used in place of the one passed to this function is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;
 <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *l;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *my_data;
 <span class="keywordtype">void</span> *data;

 <a class="code" href="group__Eina__List__Group.html#gad02f746a08ee0b12b7ed66d4bc0d71d8" title="Definition of the macro to iterate over a list.">EINA_LIST_FOREACH</a>(list, l, data)
   {
     <span class="keywordflow">if</span> (data == my_data)
       {
         list = <a class="code" href="group__Eina__List__Group.html#ga1037e7ab9d39bece24d864526332828c" title="Moves the specified data to the head of the list.">eina_list_promote_list</a>(list, l);
         <span class="keywordflow">break</span>;
       }
   }
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list handle to move the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">move_list</td><td>The list node to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new list handle to replace the old one </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c0c6e07aa592a1cb2e010049a718035"></a><!-- doxytag: member="eina_list.h::eina_list_remove" ref="ga7c0c6e07aa592a1cb2e010049a718035" args="(Eina_List *list, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga7c0c6e07aa592a1cb2e010049a718035">eina_list_remove</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the first instance of the specified data from the given list. </p>
<p>This function removes the first instance of <em>data</em> from <em>list</em>. If the specified data is not in the given list (this includes the case where <em>data</em> is <code>NULL</code>), nothing is done and the specified <em>list</em> is returned. If <em>list</em> is <code>NULL</code>, <code>NULL</code> is returned, otherwise a new list pointer that should be used in place of the one passed to this function is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The given list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The specified data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga7edefe0975beecc76c02525fb9200f5a"></a><!-- doxytag: member="eina_list.h::eina_list_remove_list" ref="ga7edefe0975beecc76c02525fb9200f5a" args="(Eina_List *list, Eina_List *remove_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga7edefe0975beecc76c02525fb9200f5a">eina_list_remove_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>remove_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified list node. </p>
<p>This function removes the list node <em>remove_list</em> from <em>list</em> and frees the list node structure <em>remove_list</em>. If <em>list</em> is <code>NULL</code>, this function returns <code>NULL</code>. If <em>remove_list</em> is <code>NULL</code>, it returns <em>list</em>, otherwise, a new list pointer that should be used in place of the one passed to this function is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The following code gives an example (notice we use EINA_LIST_FOREACH instead of EINA_LIST_FOREACH_SAFE because we stop the loop after removing the current node).</dd></dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;
 <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *l;
 <span class="keyword">extern</span> <span class="keywordtype">void</span> *my_data;
 <span class="keywordtype">void</span> *data

 <a class="code" href="group__Eina__List__Group.html#gad02f746a08ee0b12b7ed66d4bc0d71d8" title="Definition of the macro to iterate over a list.">EINA_LIST_FOREACH</a>(list, l, data)
   {
     <span class="keywordflow">if</span> (data == my_data)
       {
         list = <a class="code" href="group__Eina__List__Group.html#ga7edefe0975beecc76c02525fb9200f5a" title="Removes the specified list node.">eina_list_remove_list</a>(list, l);
         <span class="keywordflow">break</span>;
       }
   }
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The given linked list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_list</td><td>The list node to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f0c56af6f6ae8f149c317d4152b407d"></a><!-- doxytag: member="eina_list.h::eina_list_reverse" ref="ga2f0c56af6f6ae8f149c317d4152b407d" args="(Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga2f0c56af6f6ae8f149c317d4152b407d">eina_list_reverse</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverses all the elements in the list. </p>
<p>This function reverses the order of all the elements in <em>list</em>, so the last member is now first, and so on. If <em>list</em> is <code>NULL</code>, this function returns <code>NULL</code>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><b>in-place</b>: This changes the given list, so you should now point to the new list head that is returned by this function.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to reverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The list head after it has been reversed</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#ga67cb29eef0bf0a3cb2cc160ae506a07f" title="Clones (copies) all the elements in the list in the reverse order.">eina_list_reverse_clone()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#gaaa11ab61d3d86c9350cb0757468a9089" title="Returns a new reversed iterator associated to a list.">eina_list_iterator_reversed_new()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga67cb29eef0bf0a3cb2cc160ae506a07f"></a><!-- doxytag: member="eina_list.h::eina_list_reverse_clone" ref="ga67cb29eef0bf0a3cb2cc160ae506a07f" args="(const Eina_List *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga67cb29eef0bf0a3cb2cc160ae506a07f">eina_list_reverse_clone</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clones (copies) all the elements in the list in the reverse order. </p>
<p>This function reverses the order of all the elements in <em>list</em>, so the last member is now first, and so on. If <em>list</em> is <code>NULL</code>, this function returns <code>NULL</code>. This returns a copy of the given list.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><b>copy:</b> This copies the list and you should then use <a class="el" href="group__Eina__List__Group.html#ga608bd2fbf06293a1b794648990703ab4" title="Frees an entire list and all the nodes, ignoring the data contained.">eina_list_free()</a> when it is not required anymore.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to reverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new list that has been reversed</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#ga2f0c56af6f6ae8f149c317d4152b407d" title="Reverses all the elements in the list.">eina_list_reverse()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#gae26360b939fc874e7ae4fab705bd3ac3" title="Clones (copies) all the elements in the list in the exactly same order.">eina_list_clone()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae18055abaafef1714bd9f2fd3fd0cc45"></a><!-- doxytag: member="eina_list.h::eina_list_search_sorted" ref="gae18055abaafef1714bd9f2fd3fd0cc45" args="(const Eina_List *list, Eina_Compare_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Eina__List__Group.html#gae18055abaafef1714bd9f2fd3fd0cc45">eina_list_search_sorted</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the node data if it is in the sorted list. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This can be used to check if some value is inside the list and get the existing instance in this case. It should be used when a list is known to be sorted as it does a binary search for results.</dd></dl>
<p>Example: Imagine a user gives a string, you check if it's in the list before duplicating its contents.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Average/worst case performance is O(log2(n)), for 1,000,000 elements it does a maximum of 20 comparisons. This is much faster than the 1,000,000 comparisons made by <a class="el" href="group__Eina__List__Group.html#ga2c093bfd321df8f286fcfeb3d13d675f" title="Returns the node data if it is in the unsorted list.">eina_list_search_unsorted()</a>, so depending on the number of searches and insertions, it may be better to <a class="el" href="group__Eina__List__Group.html#gaa634ce6790e626fd057ecdcfdc841d47" title="Sorts a list according to the ordering that func returns.">eina_list_sort()</a> the list and do the searches later. As said in <a class="el" href="group__Eina__List__Group.html#ga44af3419fd1f66ffefc4998e54c4ca70" title="Returns the node nearest to data in the sorted list.">eina_list_search_sorted_near_list()</a>, lists do not have O(1) access time, so walking to the correct node can be costly, consider worst case to be almost O(n) pointer dereference (list walk).</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to search for data, <b>must</b> be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A function pointer that can handle comparing the list data nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The reference value to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The node value (<code>node-&gt;data</code>) if func(node-&gt;data, data) == 0, otherwise <code>NULL</code> if not found</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#ga6a0564d119664930b3a41657c1551e09" title="Returns the node if data is in the sorted list.">eina_list_search_sorted_list()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#gaa634ce6790e626fd057ecdcfdc841d47" title="Sorts a list according to the ordering that func returns.">eina_list_sort()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#ga66747ee5bad3c35ea268385f6c5e174b" title="Merges two sorted lists according to the ordering that func returns.">eina_list_sorted_merge()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#ga326ba1ce720272160559fcca1abb100d" title="Returns the node if data is in the unsorted list.">eina_list_search_unsorted_list()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a0564d119664930b3a41657c1551e09"></a><!-- doxytag: member="eina_list.h::eina_list_search_sorted_list" ref="ga6a0564d119664930b3a41657c1551e09" args="(const Eina_List *list, Eina_Compare_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga6a0564d119664930b3a41657c1551e09">eina_list_search_sorted_list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the node if data is in the sorted list. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This can be used to check if some value is inside the list and get the container node in this case. It should be used when the list is known to be sorted as it does a binary search for results.</dd></dl>
<p>Example: Imagine a user gives a string, you check if it's in the list before duplicating its contents.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Average/worst case performance is O(log2(n)), for 1,000,000 elements it does a maximum of 20 comparisons. This is much faster than the 1,000,000 comparisons made by <a class="el" href="group__Eina__List__Group.html#ga326ba1ce720272160559fcca1abb100d" title="Returns the node if data is in the unsorted list.">eina_list_search_unsorted_list()</a>, so depending on the number of searches and insertions, it may be better to <a class="el" href="group__Eina__List__Group.html#gaa634ce6790e626fd057ecdcfdc841d47" title="Sorts a list according to the ordering that func returns.">eina_list_sort()</a> the list and do the searches later. As said in <a class="el" href="group__Eina__List__Group.html#ga44af3419fd1f66ffefc4998e54c4ca70" title="Returns the node nearest to data in the sorted list.">eina_list_search_sorted_near_list()</a>, lists do not have O(1) access time, so walking to the correct node can be costly, consider worst case to be almost O(n) pointer dereference (list walk).</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to search for data, <b>must</b> be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A function pointer that can handle comparing the list data nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The reference value to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The node if func(node-&gt;data, data) == 0, otherwise <code>NULL</code> if not found</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#gae18055abaafef1714bd9f2fd3fd0cc45" title="Returns the node data if it is in the sorted list.">eina_list_search_sorted()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#gaa634ce6790e626fd057ecdcfdc841d47" title="Sorts a list according to the ordering that func returns.">eina_list_sort()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#ga66747ee5bad3c35ea268385f6c5e174b" title="Merges two sorted lists according to the ordering that func returns.">eina_list_sorted_merge()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#ga326ba1ce720272160559fcca1abb100d" title="Returns the node if data is in the unsorted list.">eina_list_search_unsorted_list()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#ga44af3419fd1f66ffefc4998e54c4ca70" title="Returns the node nearest to data in the sorted list.">eina_list_search_sorted_near_list()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga44af3419fd1f66ffefc4998e54c4ca70"></a><!-- doxytag: member="eina_list.h::eina_list_search_sorted_near_list" ref="ga44af3419fd1f66ffefc4998e54c4ca70" args="(const Eina_List *list, Eina_Compare_Cb func, const void *data, int *result_cmp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga44af3419fd1f66ffefc4998e54c4ca70">eina_list_search_sorted_near_list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result_cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the node nearest to data in the sorted list. </p>
<p>This function searches for a node containing <em>data</em> as its data in <em>list</em>, if such a node exists it is returned and <em>result_cmp</em> is <code>0</code>. If the data of no node in <em>list</em> is equal to <em>data</em>, the node with the nearest value to that is returned and <em>result_cmp</em> is the return value of <em>func</em> with <em>data</em> and the returned node's data as arguments.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function is useful for inserting an element in the list only in case it isn't already present in the list, the naive way of doing this would be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> *ptr = <a class="code" href="group__Eina__List__Group.html#ga48e7356e1e0975bcabfce6f5c4ec9160" title="Finds a member of a list and returns the member.">eina_list_data_find</a>(list, <span class="stringliteral">&quot;my data&quot;</span>);
 <span class="keywordflow">if</span> (!ptr)
   <a class="code" href="group__Eina__List__Group.html#ga00740e04bfb71ad5c9ac145f766de3a4" title="Inserts a new node into a sorted list.">eina_list_sorted_insert</a>(list, <span class="stringliteral">&quot;my data&quot;</span>);
</pre></div></dd>
<dd>
However, this has the downside of walking through the list twice, once to check if the data is already present and another to insert the element in the correct position. This can be done more efficiently by: <div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> cmp_result;
 l = <a class="code" href="group__Eina__List__Group.html#ga44af3419fd1f66ffefc4998e54c4ca70" title="Returns the node nearest to data in the sorted list.">eina_list_search_sorted_near_list</a>(list, cmp_func, <span class="stringliteral">&quot;my data&quot;</span>,
                                       &amp;cmp_result);
 <span class="keywordflow">if</span> (cmp_result &gt; 0)
   list = <a class="code" href="group__Eina__List__Group.html#ga03a77b1579ee83bcab4bc3d67375d4b1" title="Prepends a list node to a linked list before the specified member.">eina_list_prepend_relative_list</a>(list, <span class="stringliteral">&quot;my data&quot;</span>, l);
 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmp_result &lt; 0)
   list = <a class="code" href="group__Eina__List__Group.html#gafa705d4483487e53d1be93a30e43c66d" title="Appends a list node to a linked list after the specified member.">eina_list_append_relative_list</a>(list, <span class="stringliteral">&quot;my data&quot;</span>, l);
</pre></div></dd></dl>
<p>If <em>cmp_result</em> is 0 the element is already in the list and we need not insert it, if <em>cmp_result</em> is greater than zero <em>"my @a data"</em> needs to come after <em>l(the nearest node present)</em>, if less than zero it needs to come before.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Average/worst case performance is O(log2(n)), for 1,000,000 elements it does a maximum of 20 comparisons. This is much faster than the 1,000,000 comparisons made naively by walking the list from head to tail, so depending on the number of searches and insertions, it may be better to <a class="el" href="group__Eina__List__Group.html#gaa634ce6790e626fd057ecdcfdc841d47" title="Sorts a list according to the ordering that func returns.">eina_list_sort()</a> the list and do the searches later. As lists do not have O(1) access time, walking to the correct node can be costly, consider worst case to be almost O(n) pointer dereference (list walk).</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to search for data, <b>must</b> be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A function pointer that can handle comparing the list data nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The reference value to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result_cmp</td><td>If provided it returns the result of the func(node-&gt;data, data) node being the last (returned) node. If node is found (exact match), then it is <code>0</code>. If the returned node is smaller than the requested data, it is less than <code>0</code> and if it's bigger it's greater than <code>0</code>. It is the last value returned by func(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The nearest node, otherwise <code>NULL</code> if not found</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#ga6a0564d119664930b3a41657c1551e09" title="Returns the node if data is in the sorted list.">eina_list_search_sorted_list()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#gaa634ce6790e626fd057ecdcfdc841d47" title="Sorts a list according to the ordering that func returns.">eina_list_sort()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#ga66747ee5bad3c35ea268385f6c5e174b" title="Merges two sorted lists according to the ordering that func returns.">eina_list_sorted_merge()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c093bfd321df8f286fcfeb3d13d675f"></a><!-- doxytag: member="eina_list.h::eina_list_search_unsorted" ref="ga2c093bfd321df8f286fcfeb3d13d675f" args="(const Eina_List *list, Eina_Compare_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Eina__List__Group.html#ga2c093bfd321df8f286fcfeb3d13d675f">eina_list_search_unsorted</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the node data if it is in the unsorted list. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This can be used to check if some value is inside the list and get the existing instance in this case.</dd></dl>
<p>Example: Imagine a user gives a string, you check if it's in the list before duplicating its contents.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is expensive and may walk the whole list, it's order-N, that is for 1,000,000 elements list it may walk and compare 1,000,000 nodes.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to search for data, may be unsorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A function pointer that can handle comparing the list data nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The reference value to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The node value (<code>node-&gt;data</code>) if func(node-&gt;data, data) == 0, otherwise <code>NULL</code> if not found</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#gae18055abaafef1714bd9f2fd3fd0cc45" title="Returns the node data if it is in the sorted list.">eina_list_search_sorted()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#ga326ba1ce720272160559fcca1abb100d" title="Returns the node if data is in the unsorted list.">eina_list_search_unsorted_list()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga326ba1ce720272160559fcca1abb100d"></a><!-- doxytag: member="eina_list.h::eina_list_search_unsorted_list" ref="ga326ba1ce720272160559fcca1abb100d" args="(const Eina_List *list, Eina_Compare_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga326ba1ce720272160559fcca1abb100d">eina_list_search_unsorted_list</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the node if data is in the unsorted list. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This can be used to check if some value is inside the list and get the container node in this case.</dd></dl>
<p>Example: Imagine a user gives a string, you check if it's in the list before duplicating its contents.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is expensive and may walk the whole list, it's order-N, that is for 1,000,000 elements list it may walk and compare 1,000,000 nodes.</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to search for data, may be unsorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A function pointer that can handle comparing the list data nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The reference value to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The node if func(node-&gt;data, data) == 0, otherwise <code>NULL</code> if not found</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__List__Group.html#ga6a0564d119664930b3a41657c1551e09" title="Returns the node if data is in the sorted list.">eina_list_search_sorted_list()</a> </dd>
<dd>
<a class="el" href="group__Eina__List__Group.html#ga2c093bfd321df8f286fcfeb3d13d675f" title="Returns the node data if it is in the unsorted list.">eina_list_search_unsorted()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa634ce6790e626fd057ecdcfdc841d47"></a><!-- doxytag: member="eina_list.h::eina_list_sort" ref="gaa634ce6790e626fd057ecdcfdc841d47" args="(Eina_List *list, unsigned int limit, Eina_Compare_Cb func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#gaa634ce6790e626fd057ecdcfdc841d47">eina_list_sort</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts a list according to the ordering that <em>func</em> returns. </p>
<p>This function sorts <em>list</em>. If <em>limit</em> is <code>0</code> or greater than the number of elements in <em>list</em>, all the elements are sorted. <em>func</em> is used to compare two elements of <em>list</em>. If <em>func</em> is <code>NULL</code>, this function returns <em>list</em>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><b>in-place</b>: This changes the given list, so you should now point to the new list head that is returned by this function.</dd>
<dd>
Worst case is O(n * log2(n)) comparisons (calls to func()). That means, for 1,000,000 list sort we do 20,000,000 comparisons.</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span>
 sort_cb(<span class="keyword">const</span> <span class="keywordtype">void</span> *d1, <span class="keyword">const</span> <span class="keywordtype">void</span> *d2)
 {
    <span class="keyword">const</span> <span class="keywordtype">char</span> *txt = d1;
    <span class="keyword">const</span> <span class="keywordtype">char</span> *txt2 = d2;

    <span class="keywordflow">if</span>(!txt) <span class="keywordflow">return</span>(1);
    <span class="keywordflow">if</span>(!txt2) <span class="keywordflow">return</span>(-1);

    <span class="keywordflow">return</span>(strcmp(txt, txt2));
 }
 <span class="keyword">extern</span> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *list;

 list = <a class="code" href="group__Eina__List__Group.html#gaa634ce6790e626fd057ecdcfdc841d47" title="Sorts a list according to the ordering that func returns.">eina_list_sort</a>(list, <a class="code" href="group__Eina__List__Group.html#ga301729054a498a2df09a5f1dd760697e" title="Gets the count of the number of items in a list.">eina_list_count</a>(list), sort_cb);
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list handle to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit</td><td>The maximum number of list elements to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A function pointer that can handle comparing the list data nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new head of the list </dd></dl>

</div>
</div>
<a class="anchor" id="ga00740e04bfb71ad5c9ac145f766de3a4"></a><!-- doxytag: member="eina_list.h::eina_list_sorted_insert" ref="ga00740e04bfb71ad5c9ac145f766de3a4" args="(Eina_List *list, Eina_Compare_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga00740e04bfb71ad5c9ac145f766de3a4">eina_list_sorted_insert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts a new node into a sorted list. </p>
<p>This function inserts values into a linked list assuming it is sorted and the result is sorted. If <em>list</em> is <code>NULLL</code>, a new list is returned. On success, a new list pointer that should be used in place of the one given to this function is returned. Otherwise, the old pointer is returned.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Average/worst case performance is O(log2(n)) comparisons (calls to <em>func</em>) as it uses <a class="el" href="group__Eina__List__Group.html#ga44af3419fd1f66ffefc4998e54c4ca70" title="Returns the node nearest to data in the sorted list.">eina_list_search_sorted_near_list()</a> and thus is bounded to that. As said in <a class="el" href="group__Eina__List__Group.html#ga44af3419fd1f66ffefc4998e54c4ca70" title="Returns the node nearest to data in the sorted list.">eina_list_search_sorted_near_list()</a>, lists do not have O(1) access time, so walking to the correct node can be costly, consider worst case to be almost O(n) pointer dereference (list walk).</dd>
<dd>
<em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The given linked list, <b>must</b> be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function called for the sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to insert in the sorted list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list pointer </dd></dl>

</div>
</div>
<a class="anchor" id="ga66747ee5bad3c35ea268385f6c5e174b"></a><!-- doxytag: member="eina_list.h::eina_list_sorted_merge" ref="ga66747ee5bad3c35ea268385f6c5e174b" args="(Eina_List *left, Eina_List *right, Eina_Compare_Cb func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#ga66747ee5bad3c35ea268385f6c5e174b">eina_list_sorted_merge</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga1b31ffcc0d46eed63a2381c5a011b486">Eina_Compare_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges two sorted lists according to the ordering that <em>func</em> returns. </p>
<p>This function compares the head of <em>left</em> and <em>right</em>, and chooses the smallest one to be the head of the returned list. It continues this process for all the entries of both the lists.</p>
<p>Both the left and the right lists are not vaild anymore after the merge and should not be used. If <em>func</em> is <code>NULL</code>, it returns <code>NULL</code>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span>
 sort_cb(<span class="keywordtype">void</span> *d1, <span class="keywordtype">void</span> *d2)
 {
   <span class="keyword">const</span> <span class="keywordtype">char</span> *txt = NULL;
    <span class="keyword">const</span> <span class="keywordtype">char</span> *txt2 = NULL;

    <span class="keywordflow">if</span>(!d1) <span class="keywordflow">return</span>(1);
    <span class="keywordflow">if</span>(!d2) <span class="keywordflow">return</span>(-1);

    <span class="keywordflow">return</span>(strcmp((<span class="keyword">const</span> <span class="keywordtype">char</span>*)d1, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)d2));
 }
 <span class="keyword">extern</span> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *sorted1;
 <span class="keyword">extern</span> <a class="code" href="struct__Eina__List.html" title="The structure type for a generic double linked list.">Eina_List</a> *sorted2;

 list = <a class="code" href="group__Eina__List__Group.html#ga66747ee5bad3c35ea268385f6c5e174b" title="Merges two sorted lists according to the ordering that func returns.">eina_list_sorted_merge</a>(sorted1, sorted2, sort_cb);
</pre></div><dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The first list to merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The second list to merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>A function pointer that can handle comparing the list data nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new sorted list </dd></dl>

</div>
</div>
<a class="anchor" id="gaf45625cf0f450aae2a4e949539b22374"></a><!-- doxytag: member="eina_list.h::eina_list_split_list" ref="gaf45625cf0f450aae2a4e949539b22374" args="(Eina_List *list, Eina_List *relative, Eina_List **right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Eina__List__Group.html#gaf45625cf0f450aae2a4e949539b22374">eina_list_split_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td>
          <td class="paramname"><em>relative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> **&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Splits a list into 2 lists. </p>
<p>This function splits <em>list</em> into two lists ( left and right ) after the node <em>relative</em>. <em>relative</em> becomes the last node of the left list. If <em>list</em> or <em>right</em> is <code>NULL</code>, <em>list</em> is returned. If <em>relative</em> is <code>NULL</code>, <em>right</em> is set to <em>list</em> and <code>NULL</code> is returned. If <em>relative</em> is the last node of <em>list</em>, <em>list</em> is returned and <em>right</em> is set to <code>NULL</code>.</p>
<p>List does not exist anymore after the split.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><em>list</em> must be a pointer to the first element of the list.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>The list to split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relative</td><td>The list is split after <em>relative</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">right</td><td>The head of the new right list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new left list </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
