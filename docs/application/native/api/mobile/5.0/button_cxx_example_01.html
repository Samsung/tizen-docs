<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Button - Complete example</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('button_cxx_example_01.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Button - Complete example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A button is simple, you click on it and something happens. That said, we'll go through an example to show in detail the button API less commonly used.</p>
<p>The first part consists of including the headers. In this case we are only working with the Elementary C++ binding and thus we need only to include him.</p>
<p><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;Elementary.hh&gt;</span>
</pre></div></p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>If necessary the C and/or the C++ headers should be include here as well.</dd></dl>
<p>Now we need to actually start the code and set the elm_policy, which defines for a given policy group/identifier a new policy's value, respectively. In this example the only policy we need to set a value for is <code>ELM_POLICY_QUIT</code>, possibles values for it are:</p>
<ul>
<li><code>ELM_POLICY_QUIT_NONE:</code> Never quit the application automatically;</li>
</ul>
<ul>
<li><code>ELM_POLICY_QUIT_LAST_WINDOW_CLOSED:</code> quit when the application's last window is closed;</li>
</ul>
<ul>
<li><code>ELM_POLICY_QUIT_LAST_WINDOW_HIDDEN</code> : quit when the application's last window is hidden;</li>
</ul>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>As you can see, the policy we chose was to quit when the last win is hidden as opose to examples with the C bindings where we perpetually set it to quit when last win was closed. This changed was necessary because in C++ binding as the elm mainloop stop running all object are destroyed, references are unreferenced and events are stopped at <a class="el" href="group__Elm__General.html#ga50fe52d513f7e89c9c770afd76de7ad9">ELM_MAIN()</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>For more details consult <a class="el" href="group__Elm__General.html#ga7a05f37fd3a019da5e26c5fc91fcd937">elm_policy_set</a></dd></dl>
<p>Next step is creating an Elementary window, in this example we use the C++ binding method with the elm_win_util_standard_add that is a elm_win_legacy function, better explained below. And then we set the autohide state for it.</p>
<p><code>elm_win_util_standard_add</code> (const char *name, const char *tittle) Adds a window object with standard setup. Parameters:</p>
<ul>
<li><code>name</code> - The name of the window;</li>
</ul>
<ul>
<li><code>title</code> - The title for the window.</li>
</ul>
<p>This creates a window but also puts in a standard background with <code><a class="el" href="group__Elm__Bg.html#gaeec8f79ac62ce0cf607cfe330008a63f" title="Adds a new background to the parent.">elm_bg_add()</a></code>, as well as setting the window title to <code>title</code>. The window type created is of type <code>ELM_WIN_BASIC</code>, with the <code>NULL</code> as the parent widget. Returns the created object or <code>NULL</code> on failure.</p>
<p>The autohide works similarly to <code>autodel</code>, automatically handling "delete,request" signals when set to <code>true</code>, with the difference that it will hide the window, instead of destroying it.</p>
<p>It is specially designed to work together with <code>ELM_POLICY_QUIT_LAST_WINDOW_HIDDEN</code> which allows exiting Elementary's main loop when all the windows are hidden.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<dl class="note"><dt><b>Note:</b></dt><dd><code>autodel</code> and <em>autohide</em> are not mutually exclusive. The window will be destructed if both autodel and autohide is set to <code>EINA_TRUE</code> or <code>true</code>.</dd></dl>
<p>In this example we'll have several buttons that will be arranged in two boxes that will be inserted in a bigger box. One of the smaller boxes will contain a set of buttons that will set different times for the autorepeat timeouts of the buttons that will be contained in the other smaller box.</p>
<p>For all this to work, we will construct the three smaller boxes and all the button that will be needed. The smaller boxes will be then packed in the bigger one.</p>
<p>In this part we'll create our directional buttons, that we'll be added in the third smaller box, this is necessary for our callback to work properly.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now let's create our bigger box using the C++ method and setting it's parent as win.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The function <code>size_hint_weight_set</code> for C++ bindings originated from C bindings function evas_object_size_hint_weight_set, that is EFL Evas type function. With this function we set the hints for an object's weight. The parameters are:</p>
<ul>
<li>x - Nonnegative double value to use as horizontal weight hint.</li>
</ul>
<ul>
<li>y - Nonnegative double value to use as vertical weight hint.</li>
</ul>
<p>This is not a size enforcement in any way, it's just a hint that should be used whenever appropriate. This is a hint on how a container object should resize a given child within its area.</p>
<p>Containers may adhere to the simpler logic of just expanding the child object's dimensions to fit its own (see the EVAS_HINT_EXPAND helper weight macro in the EFL Evas Documentation) or the complete one of taking each child's weight hint as real weights to how much of its size to allocate for them in each axis. A container is supposed to, after normalizing the weights of its children (with weight hints), distribute the space it has to layout them by those factors â€“ most weighted children get larger in this process than the least ones.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<dl class="note"><dt><b>Note:</b></dt><dd>Default weight hint values are 0.0, for both axis.</dd></dl>
<p>Now we add the box as a resize_object to win informing that when the size of the win changes so should the box's size. And finally we make it visible.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Creating our initial box, again using the C++ method, in this case we want the arrangement of the objects, that this box will contain, to be displayed horizontally and fot this we will set horizontal to <code>true</code>, vertical by default.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Again we'll set the size hint for weight, but in this box we will set the packing method to include this box inside the bigger one.</p>
<p>When using the elm box the packing method of the subobj - box in this case - should be defined. There are four possible methods:</p>
<ul>
<li><code>pack_start(subobj_)</code> - Add an object to the beginning of the pack list. Pack <code>subobj_</code> into the box obj, placing it first in the list of children objects. The actual position the object will get on screen depends on the layout used. If no custom layout is set, it will be at the top or left, depending if the box is vertical or horizontal, respectively.</li>
</ul>
<ul>
<li><code>pack_end(subobj_)</code> - Add an object at the end of the pack list. Pack <code>subobj_</code> into the box obj, placing it last in the list of children objects. The actual position the object will get on screen depends on the layout used. If no custom layout is set, it will be at the bottom or right, depending if the box is vertical or horizontal, respectively.</li>
</ul>
<ul>
<li><code>pack_before(subobj_, before_)</code> - Adds an object to the box before the indicated object. This will add the <code>subobj_</code> to the box indicated before the object indicated with <code>before_</code>. If before is not already in the box, results are undefined. Before means either to the left of the indicated object or above it depending on orientation.</li>
</ul>
<ul>
<li><code>pack_after(subobj_, after_)</code> - Adds an object to the box after the indicated object. This will add the <code>subobj_</code> to the box indicated after the object indicated with <code>after_</code>. If after is not already in the box, results are undefined. After means either to the right of the indicated object or below it depending on orientation.</li>
</ul>
<p>In this and most examples we use pack_end by choice and practicality. In this part of the code we also make calendar visible.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now let's start creating the buttons that will be included in this first small box, this will contain the initial timeout button.</p>
<p>We'll use again the C++ method to create this button, set a text, packing method for btn and finally make it visible.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>In this part we'll use Lambda type function that will be added in the clicked callback for all buttons in the first smaller box, that'll identify the current initial and gap to be use in the autorepeat timeout that will move the central button.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<dl class="note"><dt><b>Note:</b></dt><dd>To learn more about Lambda Function and its use in Elementary consult <a class="el" href="lambda.html">Lambda Functions with Elementary - C++11</a>.</dd></dl>
<p>The second and third button will also set the initial timeout but with different values.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now for our gap timeout buttons will create our second smaller box, the same way with the initial box, we'll use the C++ method, set to be horizontal, set the size hint weight, choose the packing method and set the visibility to true.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>For our gap buttons we'll again, use the C++ method, set the texts with the different values for gap, choose the packing method, set the visibility and the clicked callback.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now we'll give our directional buttons more options so that it will visible and also have all the caracteristics that is require.</p>
<p>For the up button, we'll set to <code>true</code> the autorepeat, autorepeat_initial_timeout, autoreapet_gap_timeout, the size hints for weight and alignement, choose our packing method and making out up button visible.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>For this directional buttons we'll have a diferent repeated callback that will insure the timeouts of our middle button in the gap and initial timeout that is current setted.</p>
<p><div class="fragment"><pre class="fragment"></pre></div>  For our second callback, we'll detail the release of our directional buttons.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Finishing our up button, we'll create an icon, that'll will be the standard "arrow_up".</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>This last box, will content all the directional buttons and the middle button. As before, we use the C++ method, horizontal set, weight and align hints, chose the packing method and make it visible.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now we'll create all the directional and middle buttons, the same as we did with the up button, changing only the icon.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now we set the size for the window, making it visible in the end:</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Finally we just have to start the elm mainloop, starting to handle events and drawing operations.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The full code for this example can be found at <a class="el" href="button_cxx_example_01_8cc-example.html">button_cxx_example_01::cc</a> .</p>
<p>This example will look like this: </p>
<div class="image">
<img src="screenshots/button_cxx_example_01.png" alt="button_cxx_example_01.png"/>
</div>
  </div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
