<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore_exe</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('Ecore_exe_simple_example_c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Ecore_exe </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Creating a processes and IPC (Inter process communication)</p>
<p>In this example we will show how to create a new process and communicate with it in a portable way using the Ecore_exe module.</p>
<p>In this example we will have two process and both will communicate with each other using messages. A father process will start a child process and it will keep sending messages to the child until it receives a message to quit. To see the full source use the links: </p>
<ul>
<li><a class="el" href="ecore_exe_example_8c-example.html">Father</a> </li>
<li><a class="el" href="ecore_exe_example_child_8c-example.html">Child</a></li>
</ul>
<p>Let's start the tutorial. The implementation of the child it's pretty simple. We just read strings from stdin and write a message in the stdout. But you should be asking yourself right know. "If I'm receiving data from an other
 process why I'm reading and writing in stdin/stdout?". That's because, when you spawn a process using the Ecore_Exe module it will create a pipe between the father and the child process and the stdin/stdout of the child process will be redirected to the pipe. So when the child wants to receive or send data to the father, just use the stdin/stdout. However the steps to send data from the father to the child is quite different, but we will get there.</p>
<p>The child will register a fd handler to monitor the stdin. So we start registering the ecore FD handler:  <div class="fragment"><pre class="fragment">   <a class="code" href="group__Ecore__FD__Handler__Group.html#ga832e68eb7f15912abeadef816bb5d2f5" title="Adds a callback for activity on the given file descriptor.">ecore_main_fd_handler_add</a>(STDIN_FILENO,
                             ECORE_FD_READ,
                             _fd_handler_cb,
                             NULL, NULL, NULL);
</pre></div></p>
<p>If you don't remenber the parameters of <a class="el" href="group__Ecore__FD__Handler__Group.html#ga832e68eb7f15912abeadef816bb5d2f5">ecore_main_fd_handler_add</a>, please check its documentation.</p>
<p>Now that we have our handler registered we will start the ecore's main loop: <div class="fragment"><pre class="fragment">   <a class="code" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a>();
</pre></div></p>
<p>Now let's take a look in the callback function. Its a simple function that will read from stdin 3 times and at the third time will say to the father: "quit".  <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_fd_handler_cb(<span class="keywordtype">void</span> *data EINA_UNUSED, HANDLER_TYPE *fd_handler EINA_UNUSED)
{
   <span class="keyword">static</span> <span class="keywordtype">int</span> numberOfMessages = 0;
   <span class="keywordtype">char</span> message[BUFFER_SIZE];

   <span class="keywordflow">if</span> (!fgets(message, BUFFER_SIZE, stdin))
     <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>;

   numberOfMessages++;

   <span class="keywordflow">if</span> (numberOfMessages &lt; 3)
     {
        printf(<span class="stringliteral">&quot;My father sent this message to me:%s\n&quot;</span>, message);
        fflush(stdout);
        <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>;
     }
   <span class="keywordflow">else</span>
     {
        printf(<span class="stringliteral">&quot;quit\n&quot;</span>);
        fflush(stdout);
        <a class="code" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a>();
        <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga780091d7d49a4bb6cb753f12e1a3b19d">ECORE_CALLBACK_DONE</a>;
     }
}

<span class="keywordtype">int</span>
main(<span class="keywordtype">void</span>)
{
   <span class="keywordflow">if</span> (!<a class="code" href="group__Ecore__Init__Group.html#ga77757609684a2c922dc5ec398274751b">ecore_init</a>())
     <span class="keywordflow">goto</span> error;

<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>   <span class="comment">/* note that stdin fd&#39;s on windows don&#39;t work the same</span>
<span class="comment">    * as on unixes. this uses stdin just as a quick</span>
<span class="comment">    * example that&#39;s simple instead of a more complex</span>
<span class="comment">    * one, so this won&#39;t actually work on windows unless</span>
<span class="comment">    * you use a fd that comes from somewhere that is</span>
<span class="comment">    * select()able. */</span>
   ecore_main_win32_handler_add(GetStdHandle(STD_INPUT_HANDLE),
                                _fd_handler_cb,
                                NULL);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>   <a class="code" href="group__Ecore__FD__Handler__Group.html#ga832e68eb7f15912abeadef816bb5d2f5" title="Adds a callback for activity on the given file descriptor.">ecore_main_fd_handler_add</a>(STDIN_FILENO,
                             ECORE_FD_READ,
                             _fd_handler_cb,
                             NULL, NULL, NULL);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>   <a class="code" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a>();

   <a class="code" href="group__Ecore__Init__Group.html#ga768298b932f18d7e7593a447493e5cde">ecore_shutdown</a>();

   <span class="keywordflow">return</span> EXIT_SUCCESS;

error:
   <span class="keywordflow">return</span> EXIT_FAILURE;
}
</pre></div></p>
<p>You may notice that we are sending the messages to stdout, and our father will receive it. Also our string must have a "\n" because the string will be buffered in the pipe until it finds EOF or a "newline" in our case we won't have a EOF unless we close the pipe, so we use the "\n" char.</p>
<p>One more thing, we use fflush(stdout) because probably our message won't fill our entire buffer and the father would never receive the message. So we use this function to flush the buffer and the father can receive as fast as possible.</p>
<p>Now that we have our child ready, let's start our work in the father's source code.</p>
<p>We start creating the child process like this:  <div class="fragment"><pre class="fragment">   childHandle = <a class="code" href="group__Ecore__Exe__Group.html#gacd208a964c62424424d4c4c92a651db1">ecore_exe_pipe_run</a>(<span class="stringliteral">&quot;./ecore_exe_example_child&quot;</span>,
                                    ECORE_EXE_PIPE_WRITE |
                                    ECORE_EXE_PIPE_READ_LINE_BUFFERED |
                                    ECORE_EXE_PIPE_READ, NULL);
</pre></div></p>
<p>With the command above we are creating our child process, the first parameter is the command to be executed, the second are the pipe flags and in our case we will write and read in the pipe so we must say what we are doing in the pipe. You may notice the flag ECORE_EXE_PIPE_READ_LINE_BUFFERED, this means that reads are buffered until I find a newline. And the third parameter is data that we would like to send to the process in its creating. This case we are sending nothing, so just use NULL.</p>
<p>Then we check if the process was created: <div class="fragment"><pre class="fragment">   <span class="keywordflow">if</span> (childHandle == NULL)
     {
        fprintf(stderr, <span class="stringliteral">&quot;Could not create a child process!\n&quot;</span>);
        <span class="keywordflow">goto</span> <a class="code" href="group__Ecore__Init__Group.html#ga768298b932f18d7e7593a447493e5cde">ecore_shutdown</a>;
     }
</pre></div></p>
<p>After this we get the PID of the child process and just print it in the screen. The PID stands for Process identification. This is just an internal identifier of your process:</p>
<p><div class="fragment"><pre class="fragment">   childPid = <a class="code" href="group__Ecore__Exe__Group.html#ga31fa4d88303d0dc45b3dfdb55fb53883">ecore_exe_pid_get</a>(childHandle);

   <span class="keywordflow">if</span> (childPid == -1)
     fprintf(stderr, <span class="stringliteral">&quot;Could not retrieve the PID!\n&quot;</span>);
</pre></div></p>
<p>The way that Ecore_exe works is: when we want to read data sent from our child we must use an ecore event. So let's start register our event listener: <div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now to send messages to our child we will use a timer, so every 1 second we will send a message to the child. <div class="fragment"><pre class="fragment"></pre></div></p>
<p>After all this we start the main loop. Now let's pass to the callback functions.</p>
<p>Now we will see how we actually send the data and receive it. Let's start with _sendMessage:  <div class="fragment"><pre class="fragment">_sendMessage(<span class="keywordtype">void</span> *data)
{
   <span class="keyword">static</span> <span class="keywordtype">int</span> numberOfMessages = 0;
   Ecore_Exe *childHandle = (Ecore_Exe *)data;
   <span class="keywordtype">char</span> msg[BUFFER_SIZE];

   sprintf(msg, <span class="stringliteral">&quot; Message: %d\n&quot;</span>, numberOfMessages);
   numberOfMessages++;

   <span class="keywordflow">if</span> (<a class="code" href="group__Ecore__Exe__Group.html#gac5a7d73f64baf6b752154836ff4123b9">ecore_exe_send</a>(childHandle, msg, strlen(msg)) != <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>)
     fprintf(stderr, <span class="stringliteral">&quot;Could not send my name to the child\n&quot;</span>);
   <span class="keywordflow">else</span>
     printf(
             <span class="stringliteral">&quot;I&#39;m the father and I sent this message to the child: %s\n&quot;</span>, msg);

   <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>;
}
</pre></div></p>
<p>We use ecore_exe_send to send data to the child process, it's pretty simple. To know what the parameters stands for, check the docs.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The function <b>ecore_exe_send</b> will never block your program, also there is no partial send of the data. This means either the function will send all the data or it will fail.</dd></dl>
<p>Now let's take a look in our event callback and see how we retrieve the messages.  <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_msg_from_child_handler(<span class="keywordtype">void</span> *data EINA_UNUSED, <span class="keywordtype">int</span> type EINA_UNUSED, <span class="keywordtype">void</span> *event)
{
   Ecore_Exe_Event_Data *dataFromProcess = (Ecore_Exe_Event_Data *)event;
   <span class="keywordtype">char</span> msg[BUFFER_SIZE];

   <span class="keywordflow">if</span> (dataFromProcess-&gt;size &gt;= (BUFFER_SIZE - 1))
     {
        printf(<span class="stringliteral">&quot;Data too big for bugger. error\n&quot;</span>);
        <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga780091d7d49a4bb6cb753f12e1a3b19d">ECORE_CALLBACK_DONE</a>;
     }

   strncpy(msg, dataFromProcess-&gt;data, dataFromProcess-&gt;size);
   msg[dataFromProcess-&gt;size] = 0;

   <span class="keywordflow">if</span> (strcmp(msg, <span class="stringliteral">&quot;quit&quot;</span>) == 0)
     {
        printf(<span class="stringliteral">&quot;My child said to me, QUIT!\n&quot;</span>);
        <a class="code" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a>();
     }
</pre></div></p>
<p>It's just like an normal event, we get a reference to Ecore_Exe_Event_Data, extract the data and then show it in the screen.</p>
<p>And that's it, after all it's not complicated to create a process and communicate with it. </p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
