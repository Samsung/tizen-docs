<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore Thread functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Ecore__Thread__Group.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Ecore Thread functions</div>  </div>
<div class="ingroups"><a class="el" href="group__Ecore__Main__Loop__Group.html">Ecore main loop</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>Facilities to run heavy tasks in different threads to avoid blocking the main loop.</p>
<p>The EFL is, for the most part, not thread safe. This means that if you have some task running in another thread and you have, for example, an Evas object to show the status progress of this task, you cannot update the object from within the thread. This can only be done from the main thread, the one running the main loop. This problem can be solved by running a thread that sends messages to the main one using an <a class="el" href="group__Ecore__Pipe__Group.html">Ecore_Pipe</a>, but when you need to handle other things like cancelling the thread, your code grows in complexity and gets much harder to maintain.</p>
<p>Ecore Thread is here to solve that problem. It is <b>not</b> a simple wrapper around standard POSIX threads (or the equivalent in other systems) and it's not meant to be used to run parallel tasks throughout the entire duration of the program, especially when these tasks are performance critical, as Ecore manages these tasks using a pool of threads based on system configuration.</p>
<p>What Ecore Thread does, is make it a lot easier to dispatch a worker function to perform some heavy task and then get the result once it completes, without blocking the application's UI. In addition, cancelling and rescheduling comes practically for free and the developer needs not worry about how many threads are launched, since Ecore will schedule them according to the number of processors the system has and maximum amount of concurrent threads set for the application.</p>
<p>At the system level, Ecore will start a new thread on an as-needed basis until the maximum set is reached. When no more threads can be launched, new worker functions will be queued in a waiting list until a thread becomes available. This way, system threads will be shared throughout different worker functions, but running only one at a time. At the same time, a worker function that is rescheduled may be run on a different thread the next time.</p>
<p>The <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> handler has two meanings, depending on what context it is on. The one returned when starting a worker with any of the functions <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run()</a> or <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run()</a> is an identifier of that specific instance of the function and can be used from the main loop with the <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel()</a> and <a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check()</a> functions. This handler must not be shared with the worker function function running in the thread. This same handler will be the one received on the <code>end</code>, <code>cancel</code> and <code>feedback</code> callbacks.</p>
<p>The worker function, that's the one running in the thread, also receives an <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> handler that can be used with <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel()</a> and <a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check()</a>, sharing the flag with the main loop. But this handler is also associated with the thread where the function is running. This has strong implications when working with thread local data.</p>
<p>There are two kinds of worker threads Ecore handles: simple, or short, workers and feedback workers.</p>
<p>The first kind is for simple functions that perform a usually small but time consuming task. Ecore will run this function in a thread as soon as one becomes available and notify the calling user of its completion once the task is done.</p>
<p>The following image shows the flow of a program running four tasks on a pool of two threads.</p>
<div class="image">
<img src="ecore_thread.png" alt="ecore_thread.png"/>
</div>
  <p>For larger tasks that may require continuous communication with the main program, the feedback workers provide the same functionality plus a way for the function running in the thread to send messages to the main thread.</p>
<p>The next diagram omits some details shown in the previous one regarding how threads are spawned and tasks are queued, but illustrates how feedback jobs communicate with the main loop and the special case of threads running out of pool.</p>
<div class="image">
<img src="ecore_thread_feedback.png" alt="ecore_thread_feedback.png"/>
</div>
  <p>See an overview example in <a class="el" href="ecore_thread_example_c.html">Ecore_Thread - API overview</a>. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_blocking, <a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_end, <a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_cancel, const void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_heavy, <a class="el" href="group__Ecore__Thread__Group.html#gad2d0337f9bd59848a3194bac11e71a1a">Ecore_Thread_Notify_Cb</a> func_notify, <a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_end, <a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_cancel, const void *data, <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> try_no_queue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga0b252a091ed78a33afed31cf147f58e2">ecore_thread_wait</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, double wait)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the main loop until the thread execution is over.  <a href="#ga0b252a091ed78a33afed31cf147f58e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga8fadd19caae011ab1483665f09ce4d91">ecore_thread_feedback</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const void *msg_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185">ecore_thread_reschedule</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gad7a28588dc26d6af8b6db8abc3ef37ce">ecore_thread_active_get</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga3e32f650cfe811e69bba7825c71b9070">ecore_thread_pending_get</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gaa5c56445198f7b03c1f080039499689a">ecore_thread_pending_feedback_get</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gaeaa014287d578a200d41cca861bceac3">ecore_thread_pending_total_get</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220">ecore_thread_max_get</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693">ecore_thread_max_set</a> (int num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga4324944541abf9f84861690b4ff66e18">ecore_thread_max_reset</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga6e7703b3013d9c872449f6e2ec093b53">ecore_thread_available_get</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66">ecore_thread_local_data_add</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const char *key, void *value, <a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a> cb, <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> direct)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453">ecore_thread_local_data_set</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const char *key, void *value, <a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a> cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad">ecore_thread_local_data_find</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const char *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779">ecore_thread_local_data_del</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const char *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a> (const char *key, void *value, <a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a> cb, <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> direct)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd">ecore_thread_global_data_set</a> (const char *key, void *value, <a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a> cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find</a> (const char *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132">ecore_thread_global_data_del</a> (const char *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga910b00728b8b0201677f7a09e8d44896">ecore_thread_global_data_wait</a> (const char *key, double seconds)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct _Ecore_Thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> )(void *data, <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gad2d0337f9bd59848a3194bac11e71a1a">Ecore_Thread_Notify_Cb</a> )(void *data, <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, void *msg_data)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga0c2e1f8d562ccf80ecc0009ada72496f"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Thread" ref="ga0c2e1f8d562ccf80ecc0009ada72496f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _Ecore_Thread <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A handle for threaded jobs </p>

</div>
</div>
<a class="anchor" id="ga2df413a7ddcf4912abe99c0be8de4d33"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Thread_Cb" ref="ga2df413a7ddcf4912abe99c0be8de4d33" args=")(void *data, Ecore_Thread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> <a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A callback used by Ecore_Thread helper. </p>

</div>
</div>
<a class="anchor" id="gad2d0337f9bd59848a3194bac11e71a1a"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Thread_Notify_Cb" ref="gad2d0337f9bd59848a3194bac11e71a1a" args=")(void *data, Ecore_Thread *thread, void *msg_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Thread__Group.html#gad2d0337f9bd59848a3194bac11e71a1a">Ecore_Thread_Notify_Cb</a> <a class="el" href="group__Ecore__Thread__Group.html#gad2d0337f9bd59848a3194bac11e71a1a">Ecore_Thread_Notify_Cb</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A callback used by the main loop to receive data sent by an <a class="el" href="group__Ecore__Thread__Group.html">Ecore Thread functions</a>. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad7a28588dc26d6af8b6db8abc3ef37ce"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_active_get" ref="gad7a28588dc26d6af8b6db8abc3ef37ce" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#gad7a28588dc26d6af8b6db8abc3ef37ce">ecore_thread_active_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the number of active threads running jobs.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of active threads running jobs</dd></dl>
<p>This returns the number of threads currently running jobs of any type through the Ecore_Thread API.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Jobs started through the <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run()</a> function with the <code>try_no_queue</code> parameter set to <code>EINA_TRUE</code> will not be accounted for in the return of this function unless the thread creation fails and it falls back to using one from the pool. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a24">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6e7703b3013d9c872449f6e2ec093b53"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_available_get" ref="ga6e7703b3013d9c872449f6e2ec093b53" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#ga6e7703b3013d9c872449f6e2ec093b53">ecore_thread_available_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the number of threads available for running tasks.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of available threads</dd></dl>
<p>Same as doing <a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220">ecore_thread_max_get()</a> - <a class="el" href="group__Ecore__Thread__Group.html#gad7a28588dc26d6af8b6db8abc3ef37ce">ecore_thread_active_get()</a>.</p>
<p>This function may return a negative number only in the case the user changed the maximum number of running threads while other tasks are running. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a28">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gae9b9b20e1ed53c62c51617b55aed2511"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_cancel" ref="gae9b9b20e1ed53c62c51617b55aed2511" args="(Ecore_Thread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancels a running thread.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to cancel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return <code>EINA_TRUE</code> if the thread has been cancelled, <code>EINA_FALSE</code> if it is pending.</dd></dl>
<p>This function can be called both in the main loop or in the running thread.</p>
<p>This function cancels a running thread. If <code>thread</code> can be immediately cancelled (it's still pending execution after creation or rescheduling), then the <code>cancel</code> callback will be called, <code>thread</code> will be freed and the function will return <code>EINA_TRUE</code>.</p>
<p>If the thread is already running, then this function returns <code>EINA_FALSE</code> after marking the <code>thread</code> as pending cancellation. For the thread to actually be terminated, it needs to return from the user function back into Ecore control. This can happen in several ways: </p>
<ul>
<li>The function ends and returns normally. If it hadn't been cancelled, <code>func_end</code> would be called here, but instead <code>func_cancel</code> will happen. </li>
<li>The function returns after requesting to be rescheduled with <a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185">ecore_thread_reschedule()</a>. </li>
<li>The function is prepared to leave early by checking if <a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check()</a> returns <code>EINA_TRUE</code>.</li>
</ul>
<ul>
<li>The function marks the thread as cancellable using eina_thread_cancellable_set(), allowing the thread to be terminated at explicit cancellation points defined with eina_thread_cancel_checkpoint() or with syscalls mentioned at man:pthreads(7). This allows blocking operations such as network or disk access to be stopped without polling <a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check()</a>. Note that a cancelled thread may leak resources if no cleanup function is registered with <a class="el" href="group__Eina__Thread__Group.html#gacbfb74a9554f86829a021b6074ef9b31" title="Attempts to cancel a running thread.">EINA_THREAD_CLEANUP_PUSH()</a>. Consider running such code using eina_thread_cancellable_run().</li>
</ul>
<p>The user function can cancel itself by calling <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel()</a>, but it should always use the <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> handle passed to it and never share it with the main loop thread by means of shared user data or any other way.</p>
<p><code>thread</code> will be freed and should not be used again if this function returns <code>EINA_TRUE</code> or after the <code>func_cancel</code> callback returns.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check()</a> </dd>
<dd>
eina_thread_cancellable_run() </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a4">ecore_thread_example.c</a>, <a class="el" href="efl_thread_5_8c-example.html#a3">efl_thread_5.c</a>, and <a class="el" href="efl_thread_6_8c-example.html#a15">efl_thread_6.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga792471a7ed00718b71d58b791ddbd08d"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_check" ref="ga792471a7ed00718b71d58b791ddbd08d" args="(Ecore_Thread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if a thread is pending cancellation.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> if the thread is pending cancellation, <code>EINA_FALSE</code> if it is not.</dd></dl>
<p>This function can be called both in the main loop or in the running thread.</p>
<p>When <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel()</a> is called on an already running task, the thread is marked as pending cancellation. This function returns <code>EINA_TRUE</code> if this mark is set for the given <code>thread</code> and can be used from the main loop thread to check if a still active thread has been cancelled, or from the user function running in the thread to check if it should stop doing what it's doing and return early, effectively cancelling the task.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a7">ecore_thread_example.c</a>, <a class="el" href="efl_thread_5_8c-example.html#a2">efl_thread_5.c</a>, and <a class="el" href="efl_thread_6_8c-example.html#a1">efl_thread_6.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8fadd19caae011ab1483665f09ce4d91"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_feedback" ref="ga8fadd19caae011ab1483665f09ce4d91" args="(Ecore_Thread *thread, const void *msg_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga8fadd19caae011ab1483665f09ce4d91">ecore_thread_feedback</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends data from the worker thread to the main loop.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The current <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> context to send data from </td></tr>
    <tr><td class="paramname">msg_data</td><td>Data to be transmitted to the main loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> if <code>msg_data</code> was successfully sent to main loop, <code>EINA_FALSE</code> if anything goes wrong.</dd></dl>
<p>You should use this function only in the <code>func_heavy</code> call.</p>
<p>Only the address to <code>msg_data</code> will be sent and once this function returns <code>EINA_TRUE</code>, the job running in the thread should never touch the contents of it again. The data sent should be malloc()'ed or something similar, as long as it's not memory local to the thread that risks being overwritten or deleted once it goes out of scope or the thread finishes.</p>
<p>Care must be taken that <code>msg_data</code> is properly freed in the <code>func_notify</code> callback set when creating the thread.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a18">ecore_thread_example.c</a>, and <a class="el" href="efl_thread_5_8c-example.html#a1">efl_thread_5.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4bde6b50e177f26ab5b2688aa99e3878"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_feedback_run" ref="ga4bde6b50e177f26ab5b2688aa99e3878" args="(Ecore_Thread_Cb func_heavy, Ecore_Thread_Notify_Cb func_notify, Ecore_Thread_Cb func_end, Ecore_Thread_Cb func_cancel, const void *data, Eina_Bool try_no_queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a>* <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_heavy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#gad2d0337f9bd59848a3194bac11e71a1a">Ecore_Thread_Notify_Cb</a>&#160;</td>
          <td class="paramname"><em>func_notify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>try_no_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Launches a thread to run a task that can talk back to the main thread.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func_heavy</td><td>The function that should run in another thread. </td></tr>
    <tr><td class="paramname">func_notify</td><td>Function that receives the data sent from the thread </td></tr>
    <tr><td class="paramname">func_end</td><td>Function to call from main loop when <code>func_heavy</code> completes its task successfully </td></tr>
    <tr><td class="paramname">func_cancel</td><td>Function to call from main loop if the thread running <code>func_heavy</code> is cancelled or fails to start </td></tr>
    <tr><td class="paramname">data</td><td>User context data to pass to all callback. </td></tr>
    <tr><td class="paramname">try_no_queue</td><td>If you want to run outside of the thread pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new thread handler, or <code>NULL</code> on failure.</dd></dl>
<p>See <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run()</a> for a general description of this function.</p>
<p>The difference with the above is that <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run()</a> is meant for tasks that don't need to communicate anything until they finish, while this function is provided with a new callback, <code>func_notify</code>, that will be called from the main thread for every message sent from <code>func_heavy</code> with <a class="el" href="group__Ecore__Thread__Group.html#ga8fadd19caae011ab1483665f09ce4d91">ecore_thread_feedback()</a>.</p>
<p>Like <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run()</a>, a new thread will be launched to run <code>func_heavy</code> unless the maximum number of simultaneous threads has been reached, in which case the function will be scheduled to run whenever a running task ends and a thread becomes free. But if <code>try_no_queue</code> is set, Ecore will first try to launch a thread outside of the pool to run the task. If it fails, it will revert to the normal behaviour of using a thread from the pool as if <code>try_no_queue</code> had not been set.</p>
<p>Keep in mind that Ecore handles the thread pool based on the number of CPUs available, but running a thread outside of the pool doesn't count for this, so having too many of them may have drastic effects over the program's performance.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga8fadd19caae011ab1483665f09ce4d91">ecore_thread_feedback()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185">ecore_thread_reschedule()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693">ecore_thread_max_set()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a52">ecore_thread_example.c</a>, and <a class="el" href="efl_thread_5_8c-example.html#a13">efl_thread_5.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4e9de7492f8400e19ddd157d8cc21811"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_global_data_add" ref="ga4e9de7492f8400e19ddd157d8cc21811" args="(const char *key, void *value, Eina_Free_Cb cb, Eina_Bool direct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>direct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds some data to a hash shared by all threads.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name under which the data will be stored </td></tr>
    <tr><td class="paramname">value</td><td>The data to add </td></tr>
    <tr><td class="paramname">cb</td><td>Function to free the data when removed from the hash </td></tr>
    <tr><td class="paramname">direct</td><td>If <code>true</code>, this will not copy the key string (like <a class="el" href="group__Eina__Hash__Group.html#ga50aa7d4303e5efbe8dc7f593b59b9f63" title="Adds an entry to the given hash table without duplicating the string.">eina_hash_direct_add()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> on success, <code>EINA_FALSE</code> on failure.</dd></dl>
<p>Ecore Thread keeps a hash that can be used to share data across several threads, including the main loop one, without having to manually handle mutexes to do so safely.</p>
<p>This function adds the data <code>value</code> to this hash under the given <code>key</code>. No other value in the hash may have the same <code>key</code>. If you need to change the value under a <code>key</code>, or you don't know if one exists already, you can use <a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd">ecore_thread_global_data_set()</a>.</p>
<p>Neither <code>key</code> nor <code>value</code> may be <code>NULL</code> and <code>key</code> will be copied in the hash, unless <code>direct</code> is set, in which case the string used should not be freed until the data is removed from the hash.</p>
<p>The <code>cb</code> function will be called when the data in the hash needs to be freed, be it because it got deleted with <a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132">ecore_thread_global_data_del()</a> or because Ecore Thread was shut down and the hash destroyed. This parameter may be NULL, in which case <code>value</code> needs to be manually freed after removing it from the hash with either <a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132">ecore_thread_global_data_del()</a> or <a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd">ecore_thread_global_data_set()</a>.</p>
<p>Manually freeing any data that was added to the hash with a <code>cb</code> function is likely to produce a segmentation fault, or any other strange happenings, later on in the program.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132">ecore_thread_global_data_del()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd">ecore_thread_global_data_set()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a49">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8e53feb974331550744cbc2e40dc9132"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_global_data_del" ref="ga8e53feb974331550744cbc2e40dc9132" args="(const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132">ecore_thread_global_data_del</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes from the shared hash the data corresponding to the given key.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> on success, <code>EINA_FALSE</code> on failure.</dd></dl>
<p>If there's any data stored associated with <code>key</code> in the global hash, this function will remove it from it and return <code>EINA_TRUE</code>. If no data exists or an error occurs, it returns <code>EINA_FALSE</code>.</p>
<p>If the data was added to the hash with a free function, then it will also be freed after removing it from the hash, otherwise it requires to be manually freed by the user, which means that if no other reference to it exists before calling this function, it will result in a memory leak.</p>
<p>Note, also, that freeing data that other threads may be using will result in a crash, so appropriate care must be taken by the application when that possibility exists.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a19">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga011eeb2f99aaa950089ddc6ea989da29"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_global_data_find" ref="ga011eeb2f99aaa950089ddc6ea989da29" args="(const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets data stored in the hash shared by all threads.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value under the given key, or <code>NULL</code> on error.</dd></dl>
<p>Finds and return the data stored in the shared hash under the key <code>key</code>.</p>
<p>Keep in mind that the data returned may be used by more than one thread at the same time and no reference counting is done on it by Ecore. Freeing the data or modifying its contents may require additional precautions to be considered, depending on the application's design.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga910b00728b8b0201677f7a09e8d44896">ecore_thread_global_data_wait()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a11">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gace0bfd51f1dceef9d66f620bcffccabd"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_global_data_set" ref="gace0bfd51f1dceef9d66f620bcffccabd" args="(const char *key, void *value, Eina_Free_Cb cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd">ecore_thread_global_data_set</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets some data in the hash shared by all threads.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name under which the data will be stored </td></tr>
    <tr><td class="paramname">value</td><td>The data to add </td></tr>
    <tr><td class="paramname">cb</td><td>Function to free the data when removed from the hash</td></tr>
  </table>
  </dd>
</dl>
<p>If no data exists in the hash under the <code>key</code>, this function adds <code>value</code> in the hash under the given <code>key</code> and returns NULL. The key itself is copied.</p>
<p>If the hash already contains something under <code>key</code>, the data will be replaced by <code>value</code> and the old value will be returned.</p>
<p><code>NULL</code> will also be returned if either <code>key</code> or <code>value</code> are <code>NULL</code>, or if an error occurred.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132">ecore_thread_global_data_del()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga910b00728b8b0201677f7a09e8d44896"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_global_data_wait" ref="ga910b00728b8b0201677f7a09e8d44896" args="(const char *key, double seconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#ga910b00728b8b0201677f7a09e8d44896">ecore_thread_global_data_wait</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets data stored in the shared hash, or wait for it if it doesn't exist.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
    <tr><td class="paramname">seconds</td><td>The amount of time in seconds to wait for the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value under the given key, or <code>NULL</code> on error.</dd></dl>
<p>Finds and return the data stored in the shared hash under the key <code>key</code>.</p>
<p>If there's nothing in the hash under the given <code>key</code>, the function will block and wait up to <code>seconds</code> seconds for some other thread to add it with either <a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add()</a> or <a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd">ecore_thread_global_data_set()</a>. If after waiting there's still no data to get, <code>NULL</code> will be returned.</p>
<p>If <code>seconds</code> is 0, then no waiting will happen and this function works like <a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find()</a>. If <code>seconds</code> is less than 0, then the function will wait indefinitely.</p>
<p>Keep in mind that the data returned may be used by more than one thread at the same time and no reference counting is done on it by Ecore. Freeing the data or modifying its contents may require additional precautions to be considered, depending on the application's design.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6878f550a9bcc8002c0c709b4b4dca66"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_local_data_add" ref="ga6878f550a9bcc8002c0c709b4b4dca66" args="(Ecore_Thread *thread, const char *key, void *value, Eina_Free_Cb cb, Eina_Bool direct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66">ecore_thread_local_data_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>direct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds some data to a hash local to the thread.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread context the data belongs to </td></tr>
    <tr><td class="paramname">key</td><td>The name under which the data will be stored </td></tr>
    <tr><td class="paramname">value</td><td>The data to add </td></tr>
    <tr><td class="paramname">cb</td><td>Function to free the data when removed from the hash </td></tr>
    <tr><td class="paramname">direct</td><td>If <code>true</code>, this will not copy the key string (like <a class="el" href="group__Eina__Hash__Group.html#ga50aa7d4303e5efbe8dc7f593b59b9f63" title="Adds an entry to the given hash table without duplicating the string.">eina_hash_direct_add()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> on success, <code>EINA_FALSE</code> on failure.</dd></dl>
<p>Ecore Thread has a mechanism to share data across several worker functions that run on the same system thread. That is, the data is stored per thread and for a worker function to have access to it, it must be run by the same thread that stored the data.</p>
<p>When there are no more workers pending, the thread will be destroyed along with the internal hash and any data left in it will be freed with the <code>cb</code> function given.</p>
<p>This set of functions is useful to share things around several instances of a function when that thing is costly to create and can be reused, but may only be used by one function at a time.</p>
<p>For example, if you have a program doing requisitions to a database, these requisitions can be done in threads so that waiting for the database to respond doesn't block the UI. Each of these threads will run a function, and each function will be dependent on a connection to the database, which may not be able to handle more than one request at a time so for each running function you will need one connection handle. The options then are: </p>
<ul>
<li>Each function opens a connection when it's called, does the work and closes the connection when it finishes. This may be costly, wasting a lot of time on resolving hostnames, negotiating permissions and allocating memory. </li>
<li>Open the connections in the main loop and pass it to the threads using the data pointer. Even worse, it's just as costly as before and now it may even be kept with connections open doing nothing until a thread becomes available to run the function. </li>
<li>Have a way to share connection handles, so that each instance of the function can check if an available connection exists, and if it doesn't, create one and add it to the pool. When no more connections are needed, they are all closed.</li>
</ul>
<p>The last option is the most efficient, but it requires a lot of work to implement properly. Using thread local data helps to achieve the same result while avoiding doing all the tracking work on your code. The way to use it would be, at the worker function, to ask for the connection with <a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad">ecore_thread_local_data_find()</a> and if it doesn't exist, then open a new one and save it with <a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66">ecore_thread_local_data_add()</a>. Do the work and forget about the connection handle, when everything is done the function just ends. The next worker to run on that thread will check if a connection exists and find that it does, so the process of opening a new one has been spared. When no more workers exist, the thread is destroyed and the callback used when saving the connection will be called to close it.</p>
<p>This function adds the data <code>value</code> to the thread data under the given <code>key</code>. No other value in the hash may have the same <code>key</code>. If you need to change the value under a <code>key</code>, or you don't know if one exists already, you can use <a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453">ecore_thread_local_data_set()</a>.</p>
<p>Neither <code>key</code> nor <code>value</code> may be <code>NULL</code> and <code>key</code> will be copied in the hash, unless <code>direct</code> is set, in which case the string used should not be freed until the data is removed from the hash.</p>
<p>The <code>cb</code> function will be called when the data in the hash needs to be freed, be it because it got deleted with <a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779">ecore_thread_local_data_del()</a> or because <code>thread</code> was terminated and the hash destroyed. This parameter may be NULL, in which case <code>value</code> needs to be manually freed after removing it from the hash with either <a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779">ecore_thread_local_data_del()</a> or <a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453">ecore_thread_local_data_set()</a>, but it's very unlikely that this is what you want.</p>
<p>This function, and all of the others in the <code>ecore_thread_local_data</code> family of functions, can only be called within the worker function running in the thread. Do not call them from the main loop or from a thread other than the one represented by <code>thread</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453">ecore_thread_local_data_set()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad">ecore_thread_local_data_find()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779">ecore_thread_local_data_del()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a5">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad3c1d51a24772b885b26486be86c2779"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_local_data_del" ref="gad3c1d51a24772b885b26486be86c2779" args="(Ecore_Thread *thread, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779">ecore_thread_local_data_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes from the thread's hash the data corresponding to the given key.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread context the data belongs to </td></tr>
    <tr><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> on success, <code>EINA_FALSE</code> on failure.</dd></dl>
<p>If there's any data stored associated with <code>key</code> in the global hash, this function will remove it from it and return <code>EINA_TRUE</code>. If no data exists or an error occurs, it returns <code>EINA_FALSE</code>.</p>
<p>If the data was added to the hash with a free function, then it will also be freed after removing it from the hash, otherwise it requires to be manually freed by the user, which means that if no other reference to it exists before calling this function, it will result in a memory leak.</p>
<p>This function, and all of the others in the <code>ecore_thread_local_data</code> family of functions, can only be called within the worker function running in the thread. Do not call them from the main loop or from a thread other than the one represented by <code>thread</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66">ecore_thread_local_data_add()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a8">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga1a937d674f1a20162b31b95d0ed100ad"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_local_data_find" ref="ga1a937d674f1a20162b31b95d0ed100ad" args="(Ecore_Thread *thread, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad">ecore_thread_local_data_find</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets data stored in the hash local to the given thread.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread context the data belongs to </td></tr>
    <tr><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value under the given key, or <code>NULL</code> on error.</dd></dl>
<p>Finds and return the data stored in the shared hash under the key <code>key</code>.</p>
<p>This function, and all of the others in the <code>ecore_thread_local_data</code> family of functions, can only be called within the worker function running in the thread. Do not call them from the main loop or from a thread other than the one represented by <code>thread</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66">ecore_thread_local_data_add()</a> </dd>
<dd>
ecore_thread_local_data_wait() </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a3">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga56a7d8c062f5c42fbc338c9ded4da453"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_local_data_set" ref="ga56a7d8c062f5c42fbc338c9ded4da453" args="(Ecore_Thread *thread, const char *key, void *value, Eina_Free_Cb cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453">ecore_thread_local_data_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets some data in the hash local to the given thread.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread context the data belongs to </td></tr>
    <tr><td class="paramname">key</td><td>The name under which the data will be stored </td></tr>
    <tr><td class="paramname">value</td><td>The data to add </td></tr>
    <tr><td class="paramname">cb</td><td>Function to free the data when removed from the hash</td></tr>
  </table>
  </dd>
</dl>
<p>If no data exists in the hash under the <code>key</code>, this function adds <code>value</code> in the hash under the given <code>key</code> and returns NULL. The key itself is copied.</p>
<p>If the hash already contains something under <code>key</code>, the data will be replaced by <code>value</code> and the old value will be returned.</p>
<p><code>NULL</code> will also be returned if either <code>key</code> or <code>value</code> are <code>NULL</code>, or if an error occurred.</p>
<p>This function, and all of the others in the <code>ecore_thread_local_data</code> family of functions, can only be called within the worker function running in the thread. Do not call them from the main loop or from a thread other than the one represented by <code>thread</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66">ecore_thread_local_data_add()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779">ecore_thread_local_data_del()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad">ecore_thread_local_data_find()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gabad7972818b7fb1346ae7a098cd47220"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_max_get" ref="gabad7972818b7fb1346ae7a098cd47220" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220">ecore_thread_max_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the maximum number of threads that can run simultaneously.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Max possible number of Ecore_Thread's running concurrently</dd></dl>
<p>This returns the maximum number of Ecore_Thread's that may be running at the same time. If this number is reached, new jobs started by either <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run()</a> or <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run()</a> will be added to the respective pending queue until one of the running threads finishes its task and becomes available to run a new one.</p>
<p>By default, this will be the proportional to the number of CPU cores found, and will be at least 1 so at least 1 worker can run through the quque of work to do.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693">ecore_thread_max_set()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga4324944541abf9f84861690b4ff66e18">ecore_thread_max_reset()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a46">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4324944541abf9f84861690b4ff66e18"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_max_reset" ref="ga4324944541abf9f84861690b4ff66e18" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Thread__Group.html#ga4324944541abf9f84861690b4ff66e18">ecore_thread_max_reset</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the maximum number of concurrently running threads to the default.</p>
<p>This resets the value returned by <a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220">ecore_thread_max_get()</a> back to its default.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220">ecore_thread_max_get()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693">ecore_thread_max_set()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf965a46e0cc12857883806812af7693"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_max_set" ref="gaaf965a46e0cc12857883806812af7693" args="(int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693">ecore_thread_max_set</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the maximum number of threads allowed to run simultaneously.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>The new maximum</td></tr>
  </table>
  </dd>
</dl>
<p>This sets a new value for the maximum number of concurrently running Ecore_Thread's. It <b>must</b> an interger of at least 1 and may be limited to a reasonable value as to not overload the system too much with too many workers. This limit may change based on the number of CPU cores detected.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220">ecore_thread_max_get()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga4324944541abf9f84861690b4ff66e18">ecore_thread_max_reset()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a48">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa5c56445198f7b03c1f080039499689a"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_pending_feedback_get" ref="gaa5c56445198f7b03c1f080039499689a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#gaa5c56445198f7b03c1f080039499689a">ecore_thread_pending_feedback_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the number of feedback jobs waiting for a thread to run.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of pending threads running "feedback" jobs</dd></dl>
<p>This returns the number of tasks started with <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run()</a> that are pending, waiting for a thread to become available to run them. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a26">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga3e32f650cfe811e69bba7825c71b9070"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_pending_get" ref="ga3e32f650cfe811e69bba7825c71b9070" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#ga3e32f650cfe811e69bba7825c71b9070">ecore_thread_pending_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the number of short jobs waiting for a thread to run.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of pending threads running "short" jobs</dd></dl>
<p>This returns the number of tasks started with <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run()</a> that are pending, waiting for a thread to become available to run them. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a27">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaeaa014287d578a200d41cca861bceac3"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_pending_total_get" ref="gaeaa014287d578a200d41cca861bceac3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#gaeaa014287d578a200d41cca861bceac3">ecore_thread_pending_total_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the total number of pending jobs.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of pending threads running jobs</dd></dl>
<p>Same as the sum of <a class="el" href="group__Ecore__Thread__Group.html#ga3e32f650cfe811e69bba7825c71b9070">ecore_thread_pending_get()</a> and <a class="el" href="group__Ecore__Thread__Group.html#gaa5c56445198f7b03c1f080039499689a">ecore_thread_pending_feedback_get()</a>. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a25">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gadf825c1a58f06bba2a304d025bed3185"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_reschedule" ref="gadf825c1a58f06bba2a304d025bed3185" args="(Ecore_Thread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185">ecore_thread_reschedule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asks for the function in the thread to be called again at a later time.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The current <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> context to rescheduled </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> if the task was successfully rescheduled, <code>EINA_FALSE</code> if anything goes wrong.</dd></dl>
<p>This function should be called only from the same function represented by <code>thread</code>.</p>
<p>Calling this function will mark the thread for a reschedule, so as soon as it returns, it will be added to the end of the list of pending tasks. If no other tasks are waiting or there are sufficient threads available, the rescheduled task will be launched again immediately.</p>
<p>This should never return <code>EINA_FALSE</code>, unless it was called from the wrong thread or with the wrong arguments.</p>
<p>The <code>func_end</code> callback set when the thread is created will not be called until the function in the thread returns without being rescheduled. Similarly, if the <code>thread</code> is cancelled, the reschedule will not take effect. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a22">ecore_thread_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaac9c9933ef0a90ba86f8fd0247e9c7ef"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_run" ref="gaac9c9933ef0a90ba86f8fd0247e9c7ef" args="(Ecore_Thread_Cb func_blocking, Ecore_Thread_Cb func_end, Ecore_Thread_Cb func_cancel, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a>* <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedules a task to run in a parallel thread to avoid locking the main loop.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func_blocking</td><td>The function that should run in another thread. </td></tr>
    <tr><td class="paramname">func_end</td><td>Function to call from main loop when <code>func_blocking</code> completes its task successfully (may be NULL) </td></tr>
    <tr><td class="paramname">func_cancel</td><td>Function to call from main loop if the thread running <code>func_blocking</code> is cancelled or fails to start (may be NULL) </td></tr>
    <tr><td class="paramname">data</td><td>User context data to pass to all callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new thread handler, or <code>NULL</code> on failure.</dd></dl>
<p>This function will try to create a new thread to run <code>func_blocking</code> in, or if the maximum number of concurrent threads has been reached, will add it to the pending list, where it will wait until a thread becomes available. The return value will be an <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> handle that can be used to cancel the thread before its completion.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should always return immediately, but in the rare case that Ecore is built with no thread support, <code>func_blocking</code> will be called here, actually blocking the main loop.</dd></dl>
<p>Once a thread becomes available, <code>func_blocking</code> will be run in it until it finishes, then <code>func_end</code> is called from the thread containing the main loop to inform the user of its completion. While in <code>func_blocking</code>, no functions from the EFL can be used, except for those from Eina that are marked to be thread-safe. Even for the latter, caution needs to be taken if the data is shared across several threads.</p>
<p><code>func_end</code> will be called from the main thread when <code>func_blocking</code> ends, so here it's safe to use anything from the EFL freely.</p>
<p>The thread can also be cancelled before its completion calling <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel()</a>, either from the main thread or <code>func_blocking</code>. In this case, <code>func_cancel</code> will be called, also from the main thread to inform of this happening. If the thread could not be created, this function will be called and it's <code>thread</code> parameter will be NULL. It's also safe to call any EFL function here, as it will be running in the main thread.</p>
<p>Inside <code>func_blocking</code>, it's possible to call <a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185">ecore_thread_reschedule()</a> to tell Ecore that this function should be called again.</p>
<p>Be aware that no assumptions can be made about the order in which the <code>func_end</code> callbacks for each task will be called. Once the function is running in a different thread, it's the OS that will handle its running schedule, and different functions may take longer to finish than others. Also remember that just starting several tasks together doesn't mean they will be running at the same time. Ecore will schedule them based on the number of threads available for the particular system it's running in, so some of the jobs started may be waiting until another one finishes before it can execute its own <code>func_blocking</code>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185">ecore_thread_reschedule()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693">ecore_thread_max_set()</a> </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_thread_example_8c-example.html#a53">ecore_thread_example.c</a>, and <a class="el" href="efl_thread_6_8c-example.html#a10">efl_thread_6.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga0b252a091ed78a33afed31cf147f58e2"></a><!-- doxytag: member="Ecore_Common.h::ecore_thread_wait" ref="ga0b252a091ed78a33afed31cf147f58e2" args="(Ecore_Thread *thread, double wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga0b252a091ed78a33afed31cf147f58e2">ecore_thread_wait</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks the main loop until the thread execution is over. </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.13.0</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to wait on. </td></tr>
    <tr><td class="paramname">wait</td><td>Maximum time to wait before exiting anyway. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EINA_TRUE if the thread execution is over. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
