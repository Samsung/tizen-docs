<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: evas-buffer-simple.c</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('evas-buffer-simple_8c-example.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">evas-buffer-simple.c</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;Evas.h&gt;</span>
<span class="preprocessor">#include &lt;Evas_Engine_Buffer.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;errno.h&gt;</span>

<span class="preprocessor">#define WIDTH (320)</span>
<span class="preprocessor"></span><span class="preprocessor">#define HEIGHT (240)</span>
<span class="preprocessor"></span>
<span class="keyword">static</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *create_canvas(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height);
<span class="keyword">static</span> <span class="keywordtype">void</span> destroy_canvas(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas);
<span class="keyword">static</span> <span class="keywordtype">void</span> draw_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas);
<span class="keyword">static</span> <span class="keywordtype">void</span> save_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas, <span class="keyword">const</span> <span class="keywordtype">char</span> *dest);

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *bg, *r1, *r2, *r3;

   <a name="a0"></a><a class="code" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init</a>();

   <span class="comment">/* After turning Evas on, we create an Evas canvas to work in.</span>
<span class="comment">    * Canvases are graphical workspaces used for placing and organizing</span>
<span class="comment">    * graphical objects.  Normally we&#39;d be using Ecore-Evas to create</span>
<span class="comment">    * the canvas, but for this example we&#39;ll hide the details in a</span>
<span class="comment">    * separate routine for convenience.</span>
<span class="comment">    */</span>
   canvas = create_canvas(WIDTH, HEIGHT);
   <span class="keywordflow">if</span> (!canvas)
     <span class="keywordflow">return</span> -1;

   <span class="comment">/* Next set the background to solid white.  This is typically done by</span>
<span class="comment">    * creating a rectangle sized to the canvas, placed at the canvas</span>
<span class="comment">    * origin.</span>
<span class="comment">    *</span>
<span class="comment">    * Note that if the canvas were to change size, our background</span>
<span class="comment">    * rectangle will not automatically resize itself; we&#39;d need to do</span>
<span class="comment">    * that manually with another evas_object_resize() call.  In a real</span>
<span class="comment">    * application using Ecore-Evas, functionality in Ecore will take</span>
<span class="comment">    * care of resizing things.  For this example, we&#39;ll just keep the</span>
<span class="comment">    * canvas dimensions fixed to avoid the problem.</span>
<span class="comment">    */</span>
   bg = <a name="a1"></a><a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a name="a2"></a><a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(bg, 255, 255, 255, 255); <span class="comment">// white bg, no transparency</span>
   evas_object_move(bg, 0, 0);                    <span class="comment">// at origin</span>
   evas_object_resize(bg, WIDTH, HEIGHT);         <span class="comment">// covers full canvas</span>
   <a name="a3"></a><a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(bg);

   puts(<span class="stringliteral">&quot;initial scene, with just background:&quot;</span>);
   draw_scene(canvas);

   <span class="comment">/* To make the scene interesting let&#39;s add a few more rectangles of</span>
<span class="comment">    * various sizes and colors, starting with a big red one.</span>
<span class="comment">    *</span>
<span class="comment">    * By default all Evas objects are created in a &#39;hidden&#39; state,</span>
<span class="comment">    * meaning they are not visible, won&#39;t be checked for changes during</span>
<span class="comment">    * canvas rendering, and won&#39;t receive input events.  Thus, like we</span>
<span class="comment">    * did for the background object we must call evas_object_show() to</span>
<span class="comment">    * make our graphics objects usable.</span>
<span class="comment">    */</span>
   r1 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r1, 255, 0, 0, 255); <span class="comment">// 100% opaque red</span>
   evas_object_move(r1, 10, 10);
   evas_object_resize(r1, 100, 100);
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r1);

   <span class="comment">/* Let&#39;s add a partly transparent rectangle on top of the red one.</span>
<span class="comment">    *</span>
<span class="comment">    * Graphics objects are treated as a stack in the canvas for drawing</span>
<span class="comment">    * purposes, so subsequent objects are drawn above the ones we&#39;ve</span>
<span class="comment">    * already added to the canvas.  This is important in objects that</span>
<span class="comment">    * have partially transparent fill coloring since we&#39;ll see part of</span>
<span class="comment">    * what&#39;s &quot;behind&quot; our object.</span>
<span class="comment">    *</span>
<span class="comment">    * In Evas, color values are pre-multiplied by their alpha.  This means</span>
<span class="comment">    * that if we want a green rectangle that&#39;s half transparent, we&#39;d have:</span>
<span class="comment">    *</span>
<span class="comment">    * non-premul: r=0, g=255, b=0    a=128 (50% alpha)</span>
<span class="comment">    * premul:</span>
<span class="comment">    *         r_premul = r * a / 255 =      0 * 128 / 255 =      0</span>
<span class="comment">    *         g_premul = g * a / 255 =    255 * 128 / 255 =    128</span>
<span class="comment">    *         b_premul = b * a / 255 =      0 * 128 / 255 =      0</span>
<span class="comment">    *</span>
<span class="comment">    * Since we&#39;re placing our half transparent green rectangle on top of</span>
<span class="comment">    * a red one, in the final output we will actually see a yellow square</span>
<span class="comment">    * (since in RGBA color green + red = yellow).</span>
<span class="comment">    */</span>
   r2 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r2, 0, 128, 0, 128); <span class="comment">// 50% opaque green</span>
   evas_object_move(r2, 10, 10);
   evas_object_resize(r2, 50, 50);
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r2);

   <span class="comment">/* Lastly, for comparison add a dark green rectangle with no</span>
<span class="comment">    * transparency. */</span>
   r3 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r3, 0, 128, 0, 255); <span class="comment">// 100% opaque dark green</span>
   evas_object_move(r3, 60, 60);
   evas_object_resize(r3, 50, 50);
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r3);

   puts(<span class="stringliteral">&quot;final scene (note updates):&quot;</span>);
   draw_scene(canvas);

   <span class="comment">/* In addition to displaying the canvas to the screen, let&#39;s also</span>
<span class="comment">    * output the buffer to a graphics file, for comparison.  Evas</span>
<span class="comment">    * supports a range of graphics file formats, but PPM is particularly</span>
<span class="comment">    * trivial to write, so our save_scene routine will output as PPM.</span>
<span class="comment">    */</span>
   save_scene(canvas, <span class="stringliteral">&quot;/tmp/evas-buffer-simple-render.ppm&quot;</span>);

   destroy_canvas(canvas);

   <a name="a4"></a><a class="code" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09" title="Directly shutdown Evas.">evas_shutdown</a>();

   <span class="keywordflow">return</span> 0;
}

<span class="comment">/* Convenience routine to allocate and initialize the canvas.</span>
<span class="comment"> * In a real application we&#39;d be using ecore_evas_buffer_new() instead.</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *create_canvas(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   Evas_Engine_Info_Buffer *einfo;
   <span class="keywordtype">int</span> method;
   <span class="keywordtype">void</span> *pixels;

   <span class="comment">/* Request a handle for the &#39;buffer&#39; type of rendering engine. */</span>
   method = <a name="a5"></a><a class="code" href="group__Evas__Output__Method.html#ga9f9871fdcc40ce1062d6565308020eb8">evas_render_method_lookup</a>(<span class="stringliteral">&quot;buffer&quot;</span>);
   <span class="keywordflow">if</span> (method &lt;= 0)
     {
    fputs(<span class="stringliteral">&quot;ERROR: evas was not compiled with &#39;buffer&#39; engine!\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Create a general canvas object.</span>
<span class="comment">    * Note that we are responsible for freeing the canvas when we&#39;re done. */</span>
   canvas = <a name="a6"></a><a class="code" href="group__Evas__Canvas.html#ga67e8eb17d2a676bfdfb8794fc5f72bc0">evas_new</a>();
   <span class="keywordflow">if</span> (!canvas)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not instantiate new evas canvas.\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Specify that the canvas will be rendering using the buffer engine method.</span>
<span class="comment">    * We also size the canvas and viewport to the same width and height, with</span>
<span class="comment">    * the viewport set to the origin of the canvas.</span>
<span class="comment">    */</span>
   <a name="a7"></a><a class="code" href="group__Evas__Canvas.html#ga15b85dc673baa6aa40f91f8bfcd3cbaa" title="Sets the output engine for the given evas.">evas_output_method_set</a>(canvas, method);
   <a name="a8"></a><a class="code" href="group__Evas__Canvas.html#gaf6478cb249ed09fa0fe961085773fe1e" title="Sets the output size of the render engine of the given evas.">evas_output_size_set</a>(canvas, width, height);
   <a name="a9"></a><a class="code" href="group__Evas__Canvas.html#ga6dcd13997f7825f03807dc0ec38dd38e" title="Sets the output viewport of the given evas in evas units.">evas_output_viewport_set</a>(canvas, 0, 0, width, height);

   <span class="comment">/* Before we can use the engine, we *must* set its configuration</span>
<span class="comment">    * parameters.  The available parameters are kept in a struct</span>
<span class="comment">    * named Evas_Engine_Info which is internal to Evas.  Thus to set</span>
<span class="comment">    * parameters we must first request the current info object from</span>
<span class="comment">    * our canvas:</span>
<span class="comment">    */</span>
   einfo = (Evas_Engine_Info_Buffer *)<a name="a10"></a><a class="code" href="group__Evas__Canvas.html#gaf396b44e1b97ec0d9dce49fcf9ad54b7" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <a name="a11"></a><a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Create the underlying data buffer that our canvas will use.  This</span>
<span class="comment">    * is a simple array of ARGB32 pixels.  Each color component</span>
<span class="comment">    * (including alpha) is one byte, resulting in 4 bytes per pixel (or</span>
<span class="comment">    * 32 bits).  We can thus store each pixel in an integer data type,</span>
<span class="comment">    * thus calculating our data buffer as W x H x sizeof(int) bytes in</span>
<span class="comment">    * length.</span>
<span class="comment">    */</span>
   pixels = malloc(width * height * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
   <span class="keywordflow">if</span> (!pixels)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not allocate canvas pixels!\n&quot;</span>, stderr);
    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Next set the various configuration parameters.  We</span>
<span class="comment">    * register the pixel buffer that the canvas will use,</span>
<span class="comment">    * indicate the pixel format as ARGB32, and the size of</span>
<span class="comment">    * each row of data. */</span>
   einfo-&gt;info.depth_type = EVAS_ENGINE_BUFFER_DEPTH_ARGB32;
   einfo-&gt;info.dest_buffer = pixels;
   einfo-&gt;info.dest_buffer_row_bytes = width * <span class="keyword">sizeof</span>(int);
   einfo-&gt;info.use_color_key = 0;
   einfo-&gt;info.alpha_threshold = 0;
   einfo-&gt;info.func.new_update_region = NULL;
   einfo-&gt;info.func.free_update_region = NULL;

   <span class="comment">/* Finally, we configure the canvas with our chosen parameters. */</span>
   <a name="a12"></a><a class="code" href="group__Evas__Canvas.html#gae917a8b0d52df622498bbf55357c1af3" title="Applies the engine settings for the given evas from the given Evas_Engine_Info structure.">evas_engine_info_set</a>(canvas, (<a name="_a13"></a><a class="code" href="struct__Evas__Engine__Info.html">Evas_Engine_Info</a> *)einfo);

   <span class="keywordflow">return</span> canvas;
}

<span class="comment">/* Convenience routine to shut down the canvas.</span>
<span class="comment"> * In a real application we&#39;d be using ecore_evas_free() instead</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <span class="keywordtype">void</span> destroy_canvas(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas)
{
   Evas_Engine_Info_Buffer *einfo;

   einfo = (Evas_Engine_Info_Buffer *)<a class="code" href="group__Evas__Canvas.html#gaf396b44e1b97ec0d9dce49fcf9ad54b7" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
    <span class="keywordflow">return</span>;
     }

   <span class="comment">/* Free the data buffer we allocated in create_buffer() */</span>
   free(einfo-&gt;info.dest_buffer);

   <span class="comment">/* Finally, free the canvas itself. */</span>
   <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
}

<span class="comment">/* Convenience routine to update the scene.</span>
<span class="comment"> * In a real application Ecore Evas would be doing this for us.</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <span class="keywordtype">void</span> draw_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas)
{
   <a name="_a14"></a><a class="code" href="struct__Eina__List.html">Eina_List</a> *updates, *n;
   <a class="code" href="group__Eina__Rectangle__Group.html#gad1f49db9be2cd747f458ebf4718b6228">Eina_Rectangle</a> *update;

   <span class="comment">/* Render the canvas, and get a list of the updated rectangles. */</span>
   updates = <a name="a15"></a><a class="code" href="group__Evas__Canvas.html#ga1867d9f5f97545418598496af93e4c71" title="Force immediate renderization of the given Evas canvas.">evas_render_updates</a>(canvas);

   <span class="comment">/* Just for informative purposes, print out the areas being updated: */</span>
   <a name="a16"></a><a class="code" href="group__Eina__List__Group.html#gad02f746a08ee0b12b7ed66d4bc0d71d8" title="Definition for the macro to iterate over a list.">EINA_LIST_FOREACH</a>(updates, n, update)
     printf(&quot;UPDATED REGION: pos: %3d, %3d    size: %3dx%3d\n&quot;,
        update-&gt;x, update-&gt;y, update-&gt;w, update-&gt;h);

   <span class="comment">/* Free the list of update rectangles */</span>
   <a name="a17"></a><a class="code" href="group__Evas__Canvas.html#ga038d98c7c13a86b6ba4de51f8aba3595">evas_render_updates_free</a>(updates);
}

<span class="comment">/* Output the canvas buffer to a Portable Pixel Map (PPM) file */</span>
static <span class="keywordtype">void</span> save_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas, const <span class="keywordtype">char</span> *dest)
{
   Evas_Engine_Info_Buffer *einfo;
   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *pixels, *pixels_end;
   <span class="keywordtype">int</span> width, height;
   FILE *f;

   <span class="comment">/* Retrieve the current data buffer. */</span>
   einfo = (Evas_Engine_Info_Buffer *)<a class="code" href="group__Evas__Canvas.html#gaf396b44e1b97ec0d9dce49fcf9ad54b7" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <span class="keywordflow">return</span>;
     }

   <span class="comment">/* Retrieve the canvas dimensions */</span>
   <a name="a18"></a><a class="code" href="group__Evas__Canvas.html#gadd22b11c786b3b00448ef58550aa55c4" title="Retrieve the output size of the render engine of the given evas.">evas_output_size_get</a>(canvas, &amp;width, &amp;height);

   <span class="comment">/* Open our output PPM file for writing */</span>
   f = fopen(dest, <span class="stringliteral">&quot;wb+&quot;</span>);
   <span class="keywordflow">if</span> (!f)
     {
    fprintf(stderr, <span class="stringliteral">&quot;ERROR: could not open for writing &#39;%s&#39;: %s\n&quot;</span>,
        dest, strerror(errno));
    <span class="keywordflow">return</span>;
     }

   <span class="comment">/* Write out the pixel data to the PPM file */</span>
   pixels = einfo-&gt;info.dest_buffer;
   pixels_end = pixels + (width * height);

   <span class="comment">/* PPM P6 format is dead simple to write.  First we output a magic</span>
<span class="comment">    * number &#39;P6&#39; to designate the file as PPM, then the width and</span>
<span class="comment">    * height on their own line in ASCII decimal, followed by the maximum</span>
<span class="comment">    * color value (255) on its own line in ASCII decimal, and finally a</span>
<span class="comment">    * the pixel data in RGB order with each color component written as</span>
<span class="comment">    * a char (byte).  No alpha information is stored.</span>
<span class="comment">    */</span>
   fprintf(f, <span class="stringliteral">&quot;P6\n%d %d\n255\n&quot;</span>,  width, height);
   <span class="keywordflow">for</span> (; pixels &lt; pixels_end; pixels++)
     {
    <span class="keywordtype">int</span> r, g, b;

    r = ((*pixels) &amp; 0xff0000) &gt;&gt; 16;
    g = ((*pixels) &amp; 0x00ff00) &gt;&gt; 8;
    b = (*pixels) &amp; 0x0000ff;

    fprintf(f, <span class="stringliteral">&quot;%c%c%c&quot;</span>, r, g, b);
     }

   fclose(f);
   printf(<span class="stringliteral">&quot;saved scene as &#39;%s&#39;\n&quot;</span>, dest);
}
</pre></div> </div><!-- contents -->
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
