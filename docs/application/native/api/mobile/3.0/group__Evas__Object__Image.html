<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Image Object Functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">3.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Evas__Object__Image.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Image Object Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__Evas__Object__Specific.html">Specific Object Functions</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>Here are grouped together functions used to create and manipulate image objects. They are available to whichever occasion one needs complex imagery on a GUI that could not be achieved by the other Evas' primitive object types, or to make image manipulations.</p>
<p>Evas will support whichever image file types it was compiled with support to (its image loaders) -- check your software packager for that information and see <a class="el" href="group__Evas__Object__Image.html#ga5fa34fd24e668429507715a92be1cc58">evas_object_image_extension_can_load_get()</a>.</p>
<h2><a class="anchor" id="Evas_Object_Image_Basics"></a>
Image object basics</h2>
<p>The most common use of image objects -- to display an image on the canvas -- is achieved by a common function triplet: </p>
<div class="fragment"><pre class="fragment"> img = <a class="code" href="group__Evas__Object__Image.html#gadd901a6b181c38dc040537b3fd76fcc6">evas_object_image_add</a>(canvas);
 <a class="code" href="group__Evas__Object__Image.html#gac27fd0ceabe5f56607b7a86d71577df1">evas_object_image_file_set</a>(img, <span class="stringliteral">&quot;path/to/img&quot;</span>, NULL);
 <a class="code" href="group__Evas__Object__Image.html#gaf9a32e36b3446f597baf95aab37e33da">evas_object_image_fill_set</a>(img, 0, 0, w, h);
</pre></div><p> The first function, naturally, is creating the image object. Then, one must set an source file on it, so that it knows where to fetch image data from. Next, one must set <b>how to fill the image object's area</b> with that given pixel data. One could use just a sub-region of the original image or even have it tiled repeatedly on the image object. For the common case of having the whole source image to be displayed on the image object, stretched to the destination's size, there's also a function helper, to be used instead of <a class="el" href="group__Evas__Object__Image.html#gaf9a32e36b3446f597baf95aab37e33da">evas_object_image_fill_set()</a>: </p>
<div class="fragment"><pre class="fragment"> evas_object_image_filled_set(img, <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>);
</pre></div><p> See those functions' documentation for more details.</p>
<h2><a class="anchor" id="Evas_Object_Image_Scale"></a>
Scale and resizing</h2>
<p>Resizing of image objects will scale their respective source images to their areas, if they are set to "fill" the object's area (evas_object_image_filled_set()). If the user wants any control on the aspect ratio of an image for different sizes, he/she has to take care of that themselves. There are functions to make images to get loaded scaled (up or down) in memory, already, if the user is going to use them at pre-determined sizes and wants to save computations.</p>
<p>Evas has even a scale cache, which will take care of caching scaled versions of images with more often usage/hits. Finally, one can have images being rescaled <b>smoothly</b> by Evas (more computationally expensive) or not.</p>
<h2><a class="anchor" id="Evas_Object_Image_Performance"></a>
Performance hints</h2>
<p>When dealing with image objects, there are some tricks to boost the performance of your application, if it does intense image loading and/or manipulations, as in animations on a UI.</p>
<h3><a class="anchor" id="Evas_Object_Image_Load"></a>
Load hints</h3>
<p>In image viewer applications, for example, the user will be looking at a given image, at full size, and will desire that the navigation to the adjacent images on his/her album be fluid and fast. Thus, while displaying a given image, the program can be on the background loading the next and previous images already, so that displaying them on the sequence is just a matter of repainting the screen (and not decoding image data).</p>
<p>Evas addresses this issue with <b>image pre-loading</b>. The code for the situation above would be something like the following: </p>
<div class="fragment"><pre class="fragment"> prev = <a class="code" href="group__Evas__Object__Image.html#ga0e8cb83d31d02bf583c75925b7cd14d7">evas_object_image_filled_add</a>(canvas);
 <a class="code" href="group__Evas__Object__Image.html#gac27fd0ceabe5f56607b7a86d71577df1">evas_object_image_file_set</a>(prev, <span class="stringliteral">&quot;/path/to/prev&quot;</span>, NULL);
 <a class="code" href="group__Evas__Object__Image.html#gae314b3d41feb8c395854d8f03cb1d6b2">evas_object_image_preload</a>(prev, <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>);

 next = <a class="code" href="group__Evas__Object__Image.html#ga0e8cb83d31d02bf583c75925b7cd14d7">evas_object_image_filled_add</a>(canvas);
 <a class="code" href="group__Evas__Object__Image.html#gac27fd0ceabe5f56607b7a86d71577df1">evas_object_image_file_set</a>(next, <span class="stringliteral">&quot;/path/to/next&quot;</span>, NULL);
 <a class="code" href="group__Evas__Object__Image.html#gae314b3d41feb8c395854d8f03cb1d6b2">evas_object_image_preload</a>(next, <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>);
</pre></div><p>If you're loading images which are too big, consider setting previously it's loading size to something smaller, in case you won't expose them in real size. It may speed up the loading considerably: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">//to load a scaled down version of the image in memory, if that&#39;s</span>
 <span class="comment">//the size you&#39;ll be displaying it anyway</span>
 evas_object_image_load_scale_down_set(img, zoom);

 <span class="comment">//optional: if you know you&#39;ll be showing a sub-set of the image&#39;s</span>
 <span class="comment">//pixels, you can avoid loading the complementary data</span>
 evas_object_image_load_region_set(img, x, y, w, h);
</pre></div><p> Refer to Elementary's Photocam widget for a high level (smart) object which does lots of loading speed-ups for you.</p>
<h3><a class="anchor" id="Evas_Object_Image_Animation"></a>
Animation hints</h3>
<p>If you want to animate image objects on a UI (what you'd get by concomitant usage of other libraries, like Ecore and Edje), there are also some tips on how to boost the performance of your application. If the animation involves resizing of an image (thus, re-scaling), you'd better turn off smooth scaling on it <b>during</b> the animation, turning it back on afterwards, for less computations. Also, in this case you'd better flag the image object in question not to cache scaled versions of it: </p>
<div class="fragment"><pre class="fragment"> evas_object_image_scale_hint_set(wd-&gt;img, EVAS_IMAGE_SCALE_HINT_DYNAMIC);

 <span class="comment">// resizing takes place in between</span>

 evas_object_image_scale_hint_set(wd-&gt;img, EVAS_IMAGE_SCALE_HINT_STATIC);
</pre></div><p>Finally, movement of opaque images through the canvas is less expensive than of translucid ones, because of blending computations.</p>
<h2><a class="anchor" id="Evas_Object_Image_Borders"></a>
Borders</h2>
<p>Evas provides facilities for one to specify an image's region to be treated specially -- as "borders". This will make those regions be treated specially on resizing scales, by keeping their aspect. This makes setting frames around other objects on UIs easy. See the following figures for a visual explanation:<br/>
  
 <img src="image-borders.png" style="max-width: 100%;" />
 <a href="image-borders.png">Full-size</a>
     
 <img src="border-effect.png" style="max-width: 100%;" />
 <a href="border-effect.png">Full-size</a>
   <h2><a class="anchor" id="Evas_Object_Image_Manipulation"></a>
Manipulating pixels</h2>
<p>Evas image objects can be used to manipulate raw pixels in many ways. The meaning of the data in the pixel arrays will depend on the image's color space, be warned (see next section). You can set your own data as an image's pixel data, fetch an image's pixel data for saving/altering, convert images between different color spaces and even advanced operations like setting a native surface as image objects' data.</p>
<h2><a class="anchor" id="Evas_Object_Image_Color_Spaces"></a>
Color spaces</h2>
<p>Image objects may return or accept "image data" in multiple formats. This is based on the color space of an object. Here is a rundown on formats:</p>
<ul>
<li>#EVAS_COLORSPACE_ARGB8888: This pixel format is a linear block of pixels, starting at the top-left row by row until the bottom right of the image or pixel region. All pixels are 32-bit unsigned int's with the high-byte being alpha and the low byte being blue in the format ARGB. Alpha may or may not be used by evas depending on the alpha flag of the image, but if not used, should be set to 0xff anyway. <br/>
<br/>
 This colorspace uses premultiplied alpha. That means that R, G and B cannot exceed A in value. The conversion from non-premultiplied colorspace is: <br/>
<br/>
 R = (r * a) / 255; G = (g * a) / 255; B = (b * a) / 255; <br/>
<br/>
 So 50% transparent blue will be: 0x80000080. This will not be "dark" - just 50% transparent. Values are 0 == black, 255 == solid or full red, green or blue.</li>
</ul>
<ul>
<li>#EVAS_COLORSPACE_YCBCR422P601_PL: This is a pointer-list indirected set of YUV (YCbCr) pixel data. This means that the data returned or set is not actual pixel data, but pointers TO lines of pixel data. The list of pointers will first be N rows of pointers to the Y plane - pointing to the first pixel at the start of each row in the Y plane. N is the height of the image data in pixels. Each pixel in the Y, U and V planes is 1 byte exactly, packed. The next N / 2 pointers will point to rows in the U plane, and the next N / 2 pointers will point to the V plane rows. U and V planes are half the horizontal and vertical resolution of the Y plane. <br/>
<br/>
 Row order is top to bottom and row pixels are stored left to right. <br/>
<br/>
 There is a limitation that these images MUST be a multiple of 2 pixels in size horizontally or vertically. This is due to the U and V planes being half resolution. Also note that this assumes the itu601 YUV colorspace specification. This is defined for standard television and mpeg streams. HDTV may use the itu709 specification. <br/>
<br/>
 Values are 0 to 255, indicating full or no signal in that plane respectively.</li>
</ul>
<ul>
<li>#EVAS_COLORSPACE_YCBCR422P709_PL: Not implemented yet.</li>
</ul>
<ul>
<li>#EVAS_COLORSPACE_RGB565_A5P: In the process of being implemented in 1 engine only. This may change. <br/>
<br/>
 This is a pointer to image data for 16-bit half-word pixel data in 16bpp RGB 565 format (5 bits red, 6 bits green, 5 bits blue), with the high-byte containing red and the low byte containing blue, per pixel. This data is packed row by row from the top-left to the bottom right. <br/>
<br/>
 If the image has an alpha channel enabled there will be an extra alpha plane after the color pixel plane. If not, then this data will not exist and should not be accessed in any way. This plane is a set of pixels with 1 byte per pixel defining the alpha values of all pixels in the image from the top-left to the bottom right of the image, row by row. Even though the values of the alpha pixels can be 0 to 255, only values 0 through to 32 are used, 32 being solid and 0 being transparent. <br/>
<br/>
 RGB values can be 0 to 31 for red and blue and 0 to 63 for green, with 0 being black and 31 or 63 being full red, green or blue respectively. This colorspace is also pre-multiplied like EVAS_COLORSPACE_ARGB8888 so: <br/>
<br/>
 R = (r * a) / 32; G = (g * a) / 32; B = (b * a) / 32;</li>
</ul>
<ul>
<li>#EVAS_COLORSPACE_GRY8: The image is just a alpha mask (8 bit's per pixel). This is used for alpha masking.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd>We don't guarantee any proper results if you create a Image object without setting the evas engine.</dd></dl>
<p>Some examples on this group of functions can be found <a class="el" href="Example_Evas_Images.html">here</a>. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Object__Image.html#ga5fa34fd24e668429507715a92be1cc58">evas_object_image_extension_can_load_get</a> (const char *file)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Object__Image.html#gae40ab40412b1c92fc539457b78f4ccc6">evas_object_image_extension_can_load_fast_get</a> (const char *file)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Object__Image.html#ga02e823fafa4fdd956b20c59fd5c2b3ab">Evas_Object_Image_Pixels_Get_Cb</a> )(void *data, <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Emile_Colorspace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Object__Image.html#ga86836f7ed4e141782a00de58e6ae3b72">Evas_Colorspace</a></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga86836f7ed4e141782a00de58e6ae3b72"></a><!-- doxytag: member="Evas_Loader.h::Evas_Colorspace" ref="ga86836f7ed4e141782a00de58e6ae3b72" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Emile_Colorspace <a class="el" href="group__Evas__Object__Image.html#ga86836f7ed4e141782a00de58e6ae3b72">Evas_Colorspace</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Colorspaces for pixel data supported by Evas Colorspaces for pixel data supported by Evas </p>

</div>
</div>
<a class="anchor" id="ga02e823fafa4fdd956b20c59fd5c2b3ab"></a><!-- doxytag: member="Evas_Common.h::Evas_Object_Image_Pixels_Get_Cb" ref="ga02e823fafa4fdd956b20c59fd5c2b3ab" args=")(void *data, Evas_Object *o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__Evas__Object__Image.html#ga02e823fafa4fdd956b20c59fd5c2b3ab">Evas_Object_Image_Pixels_Get_Cb</a>)(void *data, <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *o)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function signature for the evas object pixels get callback function </p>
<dl class="see"><dt><b>See also:</b></dt><dd>evas_object_image_pixels_get()</dd></dl>
<p>By <em>data</em> it will be passed the private data. By <em>o</em> it will be passed the Evas_Object image on which the pixels are requested. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gadd901a6b181c38dc040537b3fd76fcc6"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_add" ref="gadd901a6b181c38dc040537b3fd76fcc6" args="(Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a>* <a class="el" href="group__Evas__Object__Image.html#gadd901a6b181c38dc040537b3fd76fcc6">evas_object_image_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new image object on the given Evas <code>e</code> canvas.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The given canvas. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The created image object handle.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If you intend to <b>display</b> an image somehow in a GUI, besides binding it to a real image file/source (with <a class="el" href="group__Evas__Object__Image.html#gac27fd0ceabe5f56607b7a86d71577df1">evas_object_image_file_set()</a>, for example), you'll have to tell this image object how to fill its space with the pixels it can get from the source. See <a class="el" href="group__Evas__Object__Image.html#ga0e8cb83d31d02bf583c75925b7cd14d7">evas_object_image_filled_add()</a>, for a helper on the common case of scaling up an image source to the whole area of the image object.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Object__Image.html#gaf9a32e36b3446f597baf95aab37e33da">evas_object_image_fill_set()</a></dd></dl>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> img = <a class="code" href="group__Evas__Object__Image.html#gadd901a6b181c38dc040537b3fd76fcc6">evas_object_image_add</a>(canvas);
 <a class="code" href="group__Evas__Object__Image.html#gac27fd0ceabe5f56607b7a86d71577df1">evas_object_image_file_set</a>(img, <span class="stringliteral">&quot;/path/to/img&quot;</span>, NULL);
</pre></div><dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-images_8c-example.html#a19">evas-images.c</a>, and <a class="el" href="evas-images2_8c-example.html#a56">evas-images2.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga2c9de2b78628482f61547779521437f2"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_alpha_mask_set" ref="ga2c9de2b78628482f61547779521437f2" args="(Evas_Object *obj, Eina_Bool ismask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#ga2c9de2b78628482f61547779521437f2">evas_object_image_alpha_mask_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>ismask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable an image to be used as an alpha mask.</p>
<p>This will set any flags, and discard any excess image data not used as an alpha mask.</p>
<p>Note there is little point in using a image as alpha mask unless it has an alpha channel.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Object to use as an alpha mask. </td></tr>
    <tr><td class="paramname">ismask</td><td>Use image as alphamask, must be true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga53e93ec0f368db0c6c780e01cbbc9249"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_animated_get" ref="ga53e93ec0f368db0c6c780e01cbbc9249" args="(const Eo *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Object__Image.html#ga53e93ec0f368db0c6c780e01cbbc9249">evas_object_image_animated_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Eo *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if an image object can be animated (have multiple frames)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether obj support animation</dd></dl>
<p>This returns if the image file of an image object is capable of animation such as an animated gif file might. This is only useful to be called once the image object file has been set.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *obj;

 <span class="keywordflow">if</span> (<a class="code" href="group__Evas__Object__Image.html#ga53e93ec0f368db0c6c780e01cbbc9249">evas_object_image_animated_get</a>(obj))
 {
 <span class="keywordtype">int</span> frame_count;
 <span class="keywordtype">int</span> loop_count;
 Evas_Image_Animated_Loop_Hint loop_type;
 <span class="keywordtype">double</span> duration;

 frame_count = evas_object_image_animated_frame_count_get(obj);
 printf(<span class="stringliteral">&quot;This image has %d frames\n&quot;</span>,frame_count);

 duration = evas_object_image_animated_frame_duration_get(obj,1,0);
 printf(<span class="stringliteral">&quot;Frame 1&#39;s duration is %f. You had better set object&#39;s frame to 2 after this duration using timer\n&quot;</span>);

 loop_count = evas_object_image_animated_loop_count_get(obj);
 printf(<span class="stringliteral">&quot;loop count is %d. You had better run loop %d times\n&quot;</span>,loop_count,loop_count);

 loop_type = evas_object_image_animated_loop_type_get(obj);
 <span class="keywordflow">if</span> (loop_type == EVAS_IMAGE_ANIMATED_HINT_LOOP)
 printf(<span class="stringliteral">&quot;You had better set frame like 1-&gt;2-&gt;3-&gt;1-&gt;2-&gt;3...\n&quot;</span>);
 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loop_type == EVAS_IMAGE_ANIMATED_HINT_PINGPONG)
 printf(<span class="stringliteral">&quot;You had better set frame like 1-&gt;2-&gt;3-&gt;2-&gt;1-&gt;2...\n&quot;</span>);
 <span class="keywordflow">else</span>
 printf(<span class="stringliteral">&quot;Unknown loop type\n&quot;</span>);

 evas_object_image_animated_frame_set(obj,1);
 printf(<span class="stringliteral">&quot;You set image object&#39;s frame to 1. You can see frame 1\n&quot;</span>);
 }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Object__Image.html#ga53e93ec0f368db0c6c780e01cbbc9249">evas_object_image_animated_get()</a> </dd>
<dd>
evas_object_image_animated_frame_count_get() </dd>
<dd>
evas_object_image_animated_loop_type_get() </dd>
<dd>
evas_object_image_animated_loop_count_get() </dd>
<dd>
evas_object_image_animated_frame_duration_get() </dd>
<dd>
evas_object_image_animated_frame_set() </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d7ac31db43f0f2f6ba80e317abb7144"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_data_convert" ref="ga2d7ac31db43f0f2f6ba80e317abb7144" args="(Evas_Object *obj, Evas_Colorspace to_cspace) EINA_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Evas__Object__Image.html#ga2d7ac31db43f0f2f6ba80e317abb7144">evas_object_image_data_convert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Image.html#ga86836f7ed4e141782a00de58e6ae3b72">Evas_Colorspace</a>&#160;</td>
          <td class="paramname"><em>to_cspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000108">Deprecated:</a></b></dt><dd>evas_object_image_data_conver</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gae40ab40412b1c92fc539457b78f4ccc6"></a><!-- doxytag: member="Evas_Common.h::evas_object_image_extension_can_load_fast_get" ref="gae40ab40412b1c92fc539457b78f4ccc6" args="(const char *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Object__Image.html#gae40ab40412b1c92fc539457b78f4ccc6">evas_object_image_extension_can_load_fast_get</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if a file extension may be supported by <a class="el" href="group__Evas__Object__Image.html">Image Object Functions</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file to check, it should be an Eina_Stringshare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> if we may be able to open it, <code>EINA_FALSE</code> if it's unlikely. </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1</dd></dl>
<p>This functions is threadsafe.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fa34fd24e668429507715a92be1cc58"></a><!-- doxytag: member="Evas_Common.h::evas_object_image_extension_can_load_get" ref="ga5fa34fd24e668429507715a92be1cc58" args="(const char *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Object__Image.html#ga5fa34fd24e668429507715a92be1cc58">evas_object_image_extension_can_load_get</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if a file extension may be supported by <a class="el" href="group__Evas__Object__Image.html">Image Object Functions</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> if we may be able to open it, <code>EINA_FALSE</code> if it's unlikely. </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1</dd></dl>
<p>If file is a Eina_Stringshare, use directly <a class="el" href="group__Evas__Object__Image.html#gae40ab40412b1c92fc539457b78f4ccc6">evas_object_image_extension_can_load_fast_get</a>.</p>
<p>This functions is threadsafe.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga525cd3bf52ec9f335d0d62121adf9562"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_file_get" ref="ga525cd3bf52ec9f335d0d62121adf9562" args="(const Eo *obj, const char **file, const char **key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#ga525cd3bf52ec9f335d0d62121adf9562">evas_object_image_file_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Eo *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the source file from where an image object is to fetch the real image data (it may be an Eet file, besides pure image ones).</p>
<p>You must <b>not</b> modify the strings on the returned pointers.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Use <code>NULL</code> pointers on the file components you're not interested in: they'll be ignored by the function.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">file</td><td>The image file path. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>The image key in <code>file</code> (if its an Eet one), or <code>NULL</code>, otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gac27fd0ceabe5f56607b7a86d71577df1"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_file_set" ref="gac27fd0ceabe5f56607b7a86d71577df1" args="(Eo *obj, const char *file, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#gac27fd0ceabe5f56607b7a86d71577df1">evas_object_image_file_set</a> </td>
          <td>(</td>
          <td class="paramtype">Eo *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the source file from where an image object must fetch the real image data (it may be an Eet file, besides pure image ones).</p>
<p>If the file supports multiple data stored in it (as Eet files do), you can specify the key to be used as the index of the image in this file.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> img = <a class="code" href="group__Evas__Object__Image.html#gadd901a6b181c38dc040537b3fd76fcc6">evas_object_image_add</a>(canvas);
 <a class="code" href="group__Evas__Object__Image.html#gac27fd0ceabe5f56607b7a86d71577df1">evas_object_image_file_set</a>(img, <span class="stringliteral">&quot;/path/to/img&quot;</span>, NULL);
 err = evas_object_image_load_error_get(img);
 <span class="keywordflow">if</span> (err != EVAS_LOAD_ERROR_NONE)
 {
 fprintf(stderr, <span class="stringliteral">&quot;could not load image &#39;%s&#39;. error string is \&quot;%s\&quot;\n&quot;</span>,
 valid_path, <a class="code" href="group__Evas__Utils.html#gaca3384642e5ebb32cfeab24c760c739a">evas_load_error_str</a>(err));
 }
 <span class="keywordflow">else</span>
 {
 <a class="code" href="group__Evas__Object__Image.html#gaf9a32e36b3446f597baf95aab37e33da">evas_object_image_fill_set</a>(img, 0, 0, w, h);
 <a class="code" href="group__Evas__Font__Group.html#ga21e8604c0e4a93e469bff4bd069e82b5">evas_object_resize</a>(img, w, h);
 <a class="code" href="group__Evas__Font__Group.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(img);
 }
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The image file path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The image key in <code>file</code> (if its an Eet one), or <code>NULL</code>, otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_evas_buffer_example_02_8c-example.html#a15">ecore_evas_buffer_example_02.c</a>, <a class="el" href="edje-basic_8c-example.html#a25">edje-basic.c</a>, <a class="el" href="edje-signals-messages_8c-example.html#a30">edje-signals-messages.c</a>, <a class="el" href="ephysics_logo_8c-example.html#a7">ephysics_logo.c</a>, <a class="el" href="evas-aspect-hints_8c-example.html#a26">evas-aspect-hints.c</a>, <a class="el" href="evas-box_8c-example.html#a35">evas-box.c</a>, <a class="el" href="evas-events_8c-example.html#a41">evas-events.c</a>, <a class="el" href="evas-hints_8c-example.html#a32">evas-hints.c</a>, <a class="el" href="evas-images_8c-example.html#a20">evas-images.c</a>, <a class="el" href="evas-images2_8c-example.html#a46">evas-images2.c</a>, <a class="el" href="evas-map-utils_8c-example.html#a34">evas-map-utils.c</a>, <a class="el" href="evas-object-manipulation_8c-example.html#a22">evas-object-manipulation.c</a>, <a class="el" href="evas-smart-interface_8c-example.html#a19">evas-smart-interface.c</a>, <a class="el" href="evas-smart-object_8c-example.html#a16">evas-smart-object.c</a>, and <a class="el" href="evas-text_8c-example.html#a33">evas-text.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga12091147e3567d1714d1a6986c48f179"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_fill_get" ref="ga12091147e3567d1714d1a6986c48f179" args="(const Evas_Object *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#ga12091147e3567d1714d1a6986c48f179">evas_object_image_fill_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas.html#ga2453e92182bad3b0e0d84e5aff433b07">Evas_Coord</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas.html#ga2453e92182bad3b0e0d84e5aff433b07">Evas_Coord</a> *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas.html#ga2453e92182bad3b0e0d84e5aff433b07">Evas_Coord</a> *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas.html#ga2453e92182bad3b0e0d84e5aff433b07">Evas_Coord</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve how an image object is to fill its drawing rectangle, given the (real) image bound to it.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Use <code>NULL</code> pointers on the fill components you're not interested in: they'll be ignored by the function.</dd></dl>
<p>See <a class="el" href="group__Evas__Object__Image.html#gaf9a32e36b3446f597baf95aab37e33da">evas_object_image_fill_set()</a> for more details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>The x coordinate (from the top left corner of the bound image) to start drawing from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>The y coordinate (from the top left corner of the bound image) to start drawing from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>The width the bound image will be displayed at. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>The height the bound image will be displayed at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-images_8c-example.html#a8">evas-images.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaf9a32e36b3446f597baf95aab37e33da"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_fill_set" ref="gaf9a32e36b3446f597baf95aab37e33da" args="(Evas_Object *obj, Evas_Coord x, Evas_Coord y, Evas_Coord w, Evas_Coord h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#gaf9a32e36b3446f597baf95aab37e33da">evas_object_image_fill_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas.html#ga2453e92182bad3b0e0d84e5aff433b07">Evas_Coord</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas.html#ga2453e92182bad3b0e0d84e5aff433b07">Evas_Coord</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas.html#ga2453e92182bad3b0e0d84e5aff433b07">Evas_Coord</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas.html#ga2453e92182bad3b0e0d84e5aff433b07">Evas_Coord</a>&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set how to fill an image object's drawing rectangle given the (real) image bound to it.</p>
<p>Note that if <code>w</code> or <code>h</code> are smaller than the dimensions of <code>obj</code>, the displayed image will be <b>tiled</b> around the object's area. To have only one copy of the bound image drawn, <code>x</code> and <code>y</code> must be 0 and <code>w</code> and <code>h</code> need to be the exact width and height of the image object itself, respectively.</p>
<p>See the following image to better understand the effects of this call. On this diagram, both image object and original image source have <code>a</code> x <code>a</code> dimensions and the image itself is a circle, with empty space around it:</p>
<div class="image">
<img src="image-fill.png" alt="image-fill.png"/>
</div>
  <dl class="warning"><dt><b>Warning:</b></dt><dd>The default values for the fill parameters are <code>x</code> = 0, <code>y</code> = 0, <code>w</code> = 0 and <code>h</code> = 0. Thus, if you're not using the <a class="el" href="group__Evas__Object__Image.html#ga0e8cb83d31d02bf583c75925b7cd14d7">evas_object_image_filled_add()</a> helper and want your image displayed, you'll have to set valid values with this function on your object.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>evas_object_image_filled_set() is a helper function which will <b>override</b> the values set here automatically, for you, in a given way.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x coordinate (from the top left corner of the bound image) to start drawing from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y coordinate (from the top left corner of the bound image) to start drawing from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The width the bound image will be displayed at. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The height the bound image will be displayed at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-images_8c-example.html#a9">evas-images.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga66643c896d92deed0e4cf648cf813822"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_fill_spread_get" ref="ga66643c896d92deed0e4cf648cf813822" args="(const Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Evas_Fill_Spread <a class="el" href="group__Evas__Object__Image.html#ga66643c896d92deed0e4cf648cf813822">evas_object_image_fill_spread_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the spread (tiling mode) for the given image object's fill.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current spread mode of the image object.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga36710dbfad2dfc10ea17f4897c23f367"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_fill_spread_set" ref="ga36710dbfad2dfc10ea17f4897c23f367" args="(Evas_Object *obj, Evas_Fill_Spread spread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#ga36710dbfad2dfc10ea17f4897c23f367">evas_object_image_fill_spread_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Fill_Spread&#160;</td>
          <td class="paramname"><em>spread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the tiling mode for the given evas image object's fill. EVAS_TEXTURE_RESTRICT, or EVAS_TEXTURE_PAD.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spread</td><td>One of EVAS_TEXTURE_REFLECT, EVAS_TEXTURE_REPEAT,</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0e8cb83d31d02bf583c75925b7cd14d7"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_filled_add" ref="ga0e8cb83d31d02bf583c75925b7cd14d7" args="(Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a>* <a class="el" href="group__Evas__Object__Image.html#ga0e8cb83d31d02bf583c75925b7cd14d7">evas_object_image_filled_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new image object that <b>automatically</b> scales its bound image to the object's area, on both axis.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The given canvas. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The created image object handle.</dd></dl>
<p>This is a helper function around <a class="el" href="group__Evas__Object__Image.html#gadd901a6b181c38dc040537b3fd76fcc6">evas_object_image_add()</a> and evas_object_image_filled_set(). It has the same effect of applying those functions in sequence, which is a very common use case.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Whenever this object gets resized, the bound image will be rescaled, too.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Object__Image.html#gadd901a6b181c38dc040537b3fd76fcc6">evas_object_image_add()</a> </dd>
<dd>
evas_object_image_filled_set() </dd>
<dd>
<a class="el" href="group__Evas__Object__Image.html#gaf9a32e36b3446f597baf95aab37e33da">evas_object_image_fill_set()</a></dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_evas_buffer_example_02_8c-example.html#a14">ecore_evas_buffer_example_02.c</a>, <a class="el" href="edje-basic_8c-example.html#a24">edje-basic.c</a>, <a class="el" href="edje-signals-messages_8c-example.html#a29">edje-signals-messages.c</a>, <a class="el" href="ephysics_logo_8c-example.html#a6">ephysics_logo.c</a>, <a class="el" href="evas-aspect-hints_8c-example.html#a25">evas-aspect-hints.c</a>, <a class="el" href="evas-box_8c-example.html#a34">evas-box.c</a>, <a class="el" href="evas-events_8c-example.html#a40">evas-events.c</a>, <a class="el" href="evas-hints_8c-example.html#a31">evas-hints.c</a>, <a class="el" href="evas-images_8c-example.html#a25">evas-images.c</a>, <a class="el" href="evas-images2_8c-example.html#a43">evas-images2.c</a>, <a class="el" href="evas-map-utils_8c-example.html#a33">evas-map-utils.c</a>, <a class="el" href="evas-object-manipulation_8c-example.html#a21">evas-object-manipulation.c</a>, <a class="el" href="evas-smart-interface_8c-example.html#a18">evas-smart-interface.c</a>, <a class="el" href="evas-smart-object_8c-example.html#a15">evas-smart-object.c</a>, and <a class="el" href="evas-text_8c-example.html#a32">evas-text.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaffdea29e7a6cec374e6aa30bbb4bcca7"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_load_size_get" ref="gaffdea29e7a6cec374e6aa30bbb4bcca7" args="(const Eo *obj, int *w, int *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#gaffdea29e7a6cec374e6aa30bbb4bcca7">evas_object_image_load_size_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Eo *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the load size of a given image object's source image.</p>
<p>This function gets the geometry size set manually for the given canvas image.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Use <code>NULL</code> pointers on the size components you're not interested in: they'll be ignored by the function. </dd>
<dd>
<code>w</code> and <code>h</code> will be set with the image's loading size only if the image's load size is set manually: if <a class="el" href="group__Evas__Object__Image.html#ga46518b9f2ff1fc849db13b3ebe366026">evas_object_image_load_size_set()</a> has not been called, <code>w</code> and <code>h</code> will be set with 0.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Object__Image.html#ga46518b9f2ff1fc849db13b3ebe366026">evas_object_image_load_size_set()</a> for more details</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>The new width of the image's load size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>The new height of the image's load size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga46518b9f2ff1fc849db13b3ebe366026"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_load_size_set" ref="ga46518b9f2ff1fc849db13b3ebe366026" args="(Eo *obj, int w, int h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#ga46518b9f2ff1fc849db13b3ebe366026">evas_object_image_load_size_set</a> </td>
          <td>(</td>
          <td class="paramtype">Eo *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the load size of a given image object's source image.</p>
<p>This function sets a new geometry size for the given canvas image. The image will be loaded into memory as if it was the set size instead of the original size.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The size of a given image object's source image will be less than or equal to the size of <code>w</code> and <code>h</code>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Object__Image.html#gaffdea29e7a6cec374e6aa30bbb4bcca7">evas_object_image_load_size_get()</a></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The new width of the image's load size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The new height of the image's load size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gafe8b60c78ac0d1e3f26a6a872b511368"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_memfile_set" ref="gafe8b60c78ac0d1e3f26a6a872b511368" args="(Evas_Object *obj, void *data, int size, char *format, char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#gafe8b60c78ac0d1e3f26a6a872b511368">evas_object_image_memfile_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the data for an image from memory to be loaded</p>
<p>This is the same as <a class="el" href="group__Evas__Object__Image.html#gac27fd0ceabe5f56607b7a86d71577df1">evas_object_image_file_set()</a> but the file to be loaded may exist at an address in memory (the data for the file, not the filename itself). The <code>data</code> at the address is copied and stored for future use, so no <code>data</code> needs to be kept after this call is made. It will be managed and freed for you when no longer needed. The <code>size</code> is limited to 2 gigabytes in size, and must be greater than 0. A <code>NULL</code> <code>data</code> pointer is also invalid. Set the filename to <code>NULL</code> to reset to empty state and have the image file data freed from memory using <a class="el" href="group__Evas__Object__Image.html#gac27fd0ceabe5f56607b7a86d71577df1">evas_object_image_file_set()</a>.</p>
<p>The <code>format</code> is optional (pass <code>NULL</code> if you don't need/use it). It is used to help Evas guess better which loader to use for the data. It may simply be the "extension" of the file as it would normally be on disk such as "jpg" or "png" or "gif" etc.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The given image object. </td></tr>
    <tr><td class="paramname">data</td><td>The image file data address </td></tr>
    <tr><td class="paramname">size</td><td>The size of the image file data in bytes </td></tr>
    <tr><td class="paramname">format</td><td>The format of the file (optional), or <code>NULL</code> if not needed </td></tr>
    <tr><td class="paramname">key</td><td>The image key in file, or <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4dac4796c8f9375e4c10518722ce4657"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_mmap_get" ref="ga4dac4796c8f9375e4c10518722ce4657" args="(const Eo *obj, const Eina_File **f, const char **key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#ga4dac4796c8f9375e4c10518722ce4657">evas_object_image_mmap_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Eo *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Eina__File__Group.html#ga20697123547cbc937c6c9dd845af0403">Eina_File</a> **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the source mmaped file from where an image object must fetch the real image data (it must be an Eina_File).</p>
<p>If the file supports multiple data stored in it (as Eet files do), you can get the key to be used as the index of the image in this file.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.10</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>The mmaped file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>The image key in <code>file</code> (if its an Eet one), or <code>NULL</code>, otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gaad29d123bfb439a107222f87ee4306aa"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_mmap_set" ref="gaad29d123bfb439a107222f87ee4306aa" args="(Eo *obj, const Eina_File *f, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#gaad29d123bfb439a107222f87ee4306aa">evas_object_image_mmap_set</a> </td>
          <td>(</td>
          <td class="paramtype">Eo *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Eina__File__Group.html#ga20697123547cbc937c6c9dd845af0403">Eina_File</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the source mmaped file from where an image object must fetch the real image data (it must be an Eina_File).</p>
<p>If the file supports multiple data stored in it (as Eet files do), you can specify the key to be used as the index of the image in this file.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The mmaped file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The image key in <code>file</code> (if its an Eet one), or <code>NULL</code>, otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gaabe0ddc5e656d6c09f9f4dd85f981279"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_native_surface_set" ref="gaabe0ddc5e656d6c09f9f4dd85f981279" args="(Evas_Object *obj, Evas_Native_Surface *surf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#gaabe0ddc5e656d6c09f9f4dd85f981279">evas_object_image_native_surface_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__Evas__Native__Surface.html">Evas_Native_Surface</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the native surface of a given image of the canvas</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The given canvas pointer. </td></tr>
    <tr><td class="paramname">surf</td><td>The new native surface.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets a native surface of a given canvas image.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gac11c7b56b285c96b7a77a56fc25f3f4c"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_pixels_import" ref="gac11c7b56b285c96b7a77a56fc25f3f4c" args="(Evas_Object *obj, Evas_Pixel_Import_Source *pixels) EINA_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Object__Image.html#gac11c7b56b285c96b7a77a56fc25f3f4c">evas_object_image_pixels_import</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Pixel_Import_Source *&#160;</td>
          <td class="paramname"><em>pixels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000109">Deprecated:</a></b></dt><dd>evas_object_image_pixels_impor</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="gae314b3d41feb8c395854d8f03cb1d6b2"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_preload" ref="gae314b3d41feb8c395854d8f03cb1d6b2" args="(Evas_Object *obj, Eina_Bool cancel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#gae314b3d41feb8c395854d8f03cb1d6b2">evas_object_image_preload</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>cancel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Preload an image object's image data in the background</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The given image object. </td></tr>
    <tr><td class="paramname">cancel</td><td><code>EINA_FALSE</code> will add it the preloading work queue, <code>EINA_TRUE</code> will remove it (if it was issued before).</td></tr>
  </table>
  </dd>
</dl>
<p>This function requests the preload of the data image in the background. The work is queued before being processed (because there might be other pending requests of this type).</p>
<p>Whenever the image data gets loaded, Evas will call <a class="el" href="group__Evas.html#ggad64cde0da38a60e7cb7905b3ab216968a5cd5ca5f4dcd51dd2429f020cb2dfa9e">EVAS_CALLBACK_IMAGE_PRELOADED</a> registered callbacks on <code>obj</code> (what may be immediately, if the data was already preloaded before).</p>
<p>Use <code>EINA_TRUE</code> for <code>cancel</code> on scenarios where you don't need the image data preloaded anymore.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Any <a class="el" href="group__Evas__Font__Group.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show()</a> call after <a class="el" href="group__Evas__Object__Image.html#gae314b3d41feb8c395854d8f03cb1d6b2">evas_object_image_preload()</a> will make the latter to be <b>cancelled</b>, with the loading process now taking place <b>synchronously</b> (and, thus, blocking the return of the former until the image is loaded). It is highly advisable, then, that the user preload an image with it being <b>hidden</b>, just to be shown on the <a class="el" href="group__Evas.html#ggad64cde0da38a60e7cb7905b3ab216968a5cd5ca5f4dcd51dd2429f020cb2dfa9e">EVAS_CALLBACK_IMAGE_PRELOADED</a> event's callback.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-images2_8c-example.html#a45">evas-images2.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga8f50680090ece901a20d62fa67959c52"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_reload" ref="ga8f50680090ece901a20d62fa67959c52" args="(Evas_Object *obj) EINA_DEPRECATED" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#ga8f50680090ece901a20d62fa67959c52">evas_object_image_reload</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000110">Deprecated:</a></b></dt><dd>evas_object_image_reloa</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bd6201d1b5c5f0e65600b491c6557e4"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_save" ref="ga8bd6201d1b5c5f0e65600b491c6557e4" args="(const Eo *obj, const char *file, const char *key, const char *flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Object__Image.html#ga8bd6201d1b5c5f0e65600b491c6557e4">evas_object_image_save</a> </td>
          <td>(</td>
          <td class="paramtype">const Eo *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Save the given image object's contents to an (image) file.</p>
<p>The extension suffix on <code>file</code> will determine which <b>saver module</b> Evas is to use when saving, thus the final file's format. If the file supports multiple data stored in it (Eet ones), you can specify the key to be used as the index of the image in it.</p>
<p>You can specify some flags when saving the image. Currently acceptable flags are <code>quality</code> and <code>compress</code>. Eg.: <code>"quality=100 compress=9"</code> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The filename to be used to save the image (extension obligatory). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The image key in the file (if an Eet one), or <code>NULL</code>, otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>String containing the flags to be used (<code>NULL</code> for none).</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-images2_8c-example.html#a30">evas-images2.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6307d5c3560528d7525a6c2ed16360ed"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_size_get" ref="ga6307d5c3560528d7525a6c2ed16360ed" args="(const Evas_Object *obj, int *w, int *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#ga6307d5c3560528d7525a6c2ed16360ed">evas_object_image_size_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the size of the given image object.</p>
<p>See <a class="el" href="group__Evas__Object__Image.html#ga369c3638028094b1d66bd482778eb6b2">evas_object_image_size_set()</a> for more details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>The new width of the image. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">h</td><td>The new height of the image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ephysics_logo_8c-example.html#a2">ephysics_logo.c</a>, and <a class="el" href="evas-map-utils_8c-example.html#a10">evas-map-utils.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga369c3638028094b1d66bd482778eb6b2"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_size_set" ref="ga369c3638028094b1d66bd482778eb6b2" args="(Evas_Object *obj, int w, int h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#ga369c3638028094b1d66bd482778eb6b2">evas_object_image_size_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the size of the given image object.</p>
<p>This function will scale down or crop the image so that it is treated as if it were at the given size. If the size given is smaller than the image, it will be cropped. If the size given is larger, then the image will be treated as if it were in the upper left hand corner of a larger image that is otherwise transparent.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>The new width of the image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The new height of the image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_evas_buffer_example_02_8c-example.html#a17">ecore_evas_buffer_example_02.c</a>, and <a class="el" href="evas-images2_8c-example.html#a57">evas-images2.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gac0177597371f246ac377782fcc59c5be"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_smooth_scale_get" ref="gac0177597371f246ac377782fcc59c5be" args="(const Eo *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Object__Image.html#gac0177597371f246ac377782fcc59c5be">evas_object_image_smooth_scale_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Eo *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves whether the given image object is using high-quality image scaling algorithm.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether smooth scale is being used.</dd></dl>
<p>See <a class="el" href="group__Evas__Object__Image.html#gaf79e692448eb80c39da1fd60f8db5dda">evas_object_image_smooth_scale_set()</a> for more details.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-images_8c-example.html#a6">evas-images.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaf79e692448eb80c39da1fd60f8db5dda"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_smooth_scale_set" ref="gaf79e692448eb80c39da1fd60f8db5dda" args="(Eo *obj, Eina_Bool smooth_scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Object__Image.html#gaf79e692448eb80c39da1fd60f8db5dda">evas_object_image_smooth_scale_set</a> </td>
          <td>(</td>
          <td class="paramtype">Eo *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>smooth_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets whether to use high-quality image scaling algorithm on the given image object.</p>
<p>When enabled, a higher quality image scaling algorithm is used when scaling images to sizes other than the source image's original one. This gives better results but is more computationally expensive.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Image objects get created originally with smooth scaling <b>on</b>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Object__Image.html#gac0177597371f246ac377782fcc59c5be">evas_object_image_smooth_scale_get()</a></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">smooth_scale</td><td>Whether to use smooth scale or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-images_8c-example.html#a7">evas-images.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga053a1e4ab2d79edf3fff9dc89f90b355"></a><!-- doxytag: member="Evas_Legacy.h::evas_object_image_source_unset" ref="ga053a1e4ab2d79edf3fff9dc89f90b355" args="(Evas_Object *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Object__Image.html#ga053a1e4ab2d79edf3fff9dc89f90b355">evas_object_image_source_unset</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear the source object on a proxy image object.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Image object to clear source of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>EINA_TRUE</code> on success, <code>EINA_FALSE</code> on error.</dd></dl>
<p>This is equivalent to calling evas_object_image_source_set() with a <code>NULL</code> source.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
