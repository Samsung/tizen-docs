<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: ecore idle state - Idlers, enterers and exiters</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">3.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('ecore_idler_example_c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">ecore idle state - Idlers, enterers and exiters </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This example demonstrates how to manage the idle state of the main loop. Once a program knows that the main loop is going to enter in idle state, it could start doing some processing until getting out of this state.</p>
<p>To exemplify this, we also add events and a timer to this program, so we can see the idle exiter callback being called before processing the event and/or timer, the event/timer callback being called (processed), then the idle enterer being called before entering in idle state again. Once in idle, the main loop keeps calling the idler callback continuously until a new event or timer is received.</p>
<p>First, we declare a struct that will be used as context to be passed to every callback. It's not useful everywhere, since this example is very simple and doesn't do anything other than printing messages, but using this context will make it a little bit more real. Our context will be used to delete the timer, idler, idle enterer and exiter, and the event handler, and also to count how many times the idler was called.</p>
<p>Then we start declaring callbacks for the idle enterer, idle exiter and the idler itself. Idle enterer and exiter callbacks just print a message saying that they were called, while the idler, in addition to printing a message too, also sends an event every 10 times that it is called, incrementing the context count variable. This event will be used to make the main loop exit the idle state and call the event callback.</p>
<p>These callbacks return <a class="el" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>, since we want them to keep being called every time the main loop changes to/from idle state. Otherwise, if we didn't want them to be called again, they should return <a class="el" href="group__Ecore__Main__Loop__Group.html#gae0c653baad8836232c0dc27f91f875d6">ECORE_CALLBACK_CANCEL</a>.</p>
<p>The next function declared is the event callback <code>_event_handler_cb</code>. It will check if the idler was called more than 100 times already <code></code>(ctxt-&gt;count &gt; 100), and will delete the idler, idle enterer and exiter, the timer (if it still exists), and request that the main loop stop running. Then it returns <a class="el" href="group__Ecore__Main__Loop__Group.html#ga780091d7d49a4bb6cb753f12e1a3b19d">ECORE_CALLBACK_DONE</a> to indicate that the event shouldn't be handled by any other callback.</p>
<p>Finally, we add a callback to the timer, that will just print a message when it is called, and this will happen only once (<a class="el" href="group__Ecore__Main__Loop__Group.html#gae0c653baad8836232c0dc27f91f875d6">ECORE_CALLBACK_CANCEL</a> is being returned). This timer callback is just here to show that the main loop gets out of idle state when processing timers too.</p>
<p>The <b>main</b> function is simple, just creates a new type of event that we will use to demonstrate the event handling together with the idle state, adds the callbacks that we declared so far, fill the context struct, and starts running the main loop.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>We use timer and event callbacks to demonstrate the idle state changing, but it also happens for file descriptor handlers, pipe handlers, etc.</dd></dl>
<div class="fragment"><pre class="fragment"><span class="comment">//Compile with:</span>
<span class="comment">// gcc -o ecore_idler_example ecore_idler_example.c `pkg-config --libs --cflags ecore eo`</span>

<span class="preprocessor">#ifdef HAVE_CONFIG_H</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;config.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;Ecore.h&gt;</span>
<span class="preprocessor">#include &lt;Eo.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="keyword">struct </span>context   <span class="comment">// helper struct to give some context to the callbacks</span>
{
   <span class="keywordtype">int</span>                  count;
   <a class="code" href="group__Ecore__Idle__Group.html#ga361e0801c2d510e54e92b54968863ca3">Ecore_Idle_Enterer</a>  *enterer;
   <a class="code" href="group__Ecore__Idle__Group.html#ga2cc50b0957bf0eaf0c024a7c053fa1dc">Ecore_Idler</a>         *idler;
   <a class="code" href="group__Ecore__Idle__Group.html#ga0481e5c5dda1fa73f4e0296ef069692b">Ecore_Idle_Exiter</a>   *exiter;
   <a class="code" href="group__Ecore__Event__Group.html#ga252a2566c9c7c9094964ab8e157f0521">Ecore_Event_Handler</a> *handler;
   <a class="code" href="group__Ecore__Timer__Group.html#gaf96ffb609956658ec038e54bd39f46f0">Ecore_Timer</a>         *timer;
};

<span class="keyword">static</span> <span class="keywordtype">int</span> _event_type = 0; <span class="comment">// a new type of event will be defined and stored here</span>

<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_enterer_cb(<span class="keywordtype">void</span> *data EINA_UNUSED) <span class="comment">// the idle enterer callback</span>
{
   printf(<span class="stringliteral">&quot;IDLE ENTERER: Ecore entering in idle state.\n&quot;</span>);

   <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>; <span class="comment">// same as EINA_TRUE</span>
}

<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_exiter_cb(<span class="keywordtype">void</span> *data EINA_UNUSED) <span class="comment">// the idle exiter callback</span>
{
   printf(<span class="stringliteral">&quot;IDLE EXITER: Ecore exiting idle state.\n&quot;</span>);

   <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>; <span class="comment">// same as EINA_TRUE</span>
}

<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_idler_cb(<span class="keywordtype">void</span> *data) <span class="comment">// the idler callback - ran while the mainloop is idle</span>
{
   <span class="keyword">struct </span>context *ctxt = data;
   printf(<span class="stringliteral">&quot;IDLER: executing idler callback while in idle state.\n&quot;</span>);

   ctxt-&gt;count++;

   <span class="comment">/* each 10 times that the callback gets called, generate an event that</span>
<span class="comment">    * will wake up the main loop, triggering idle enterers, exiters, etc. */</span>
   <span class="keywordflow">if</span> ((ctxt-&gt;count % 10) == 0)
     <a class="code" href="group__Ecore__Event__Group.html#gacea6a144774958a7188274b79c91ee1f" title="Adds an event to the event queue.">ecore_event_add</a>(_event_type, NULL, NULL, NULL);

   <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>; <span class="comment">// same as EINA_TRUE</span>
}

<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_event_handler_cb(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> type EINA_UNUSED, <span class="keywordtype">void</span> *event EINA_UNUSED) <span class="comment">// event callback</span>
{
   <span class="keyword">struct </span>context *ctxt = data;

   printf(<span class="stringliteral">&quot;EVENT: processing callback for the event received.\n&quot;</span>);

   <span class="keywordflow">if</span> (ctxt-&gt;count &gt; 100)
     {
        <a class="code" href="group__Ecore__Idle__Group.html#ga7e1106729c49d0cd714ef58e0343470c">ecore_idle_enterer_del</a>(ctxt-&gt;enterer);
        <a class="code" href="group__Ecore__Idle__Group.html#ga89b7d6e94230fcbc331258f7aedf6010">ecore_idle_exiter_del</a>(ctxt-&gt;exiter);
<span class="comment">//        ecore_idler_del(ctxt-&gt;idler);</span>

        ctxt-&gt;enterer = NULL;
        ctxt-&gt;exiter = NULL;
        ctxt-&gt;idler = NULL;

        <span class="keywordflow">if</span> (ctxt-&gt;timer)
          {
             <a class="code" href="group__Ecore__Timer__Group.html#gaba2b599c7aabe3ab664dc3d47f62a33a">ecore_timer_del</a>(ctxt-&gt;timer);
             ctxt-&gt;timer = NULL;
          }

        <a class="code" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a>();
     }

   <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga780091d7d49a4bb6cb753f12e1a3b19d">ECORE_CALLBACK_DONE</a>; <span class="comment">// same as EINA_FALSE</span>
}

<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_timer_cb(<span class="keywordtype">void</span> *data)
{
   <span class="keyword">struct </span>context *ctxt = data;
   printf(<span class="stringliteral">&quot;TIMER: timer callback called.\n&quot;</span>);

   <span class="keywordflow">if</span> (ctxt-&gt;timer)
     ctxt-&gt;timer = NULL;

   <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#gae0c653baad8836232c0dc27f91f875d6">ECORE_CALLBACK_CANCEL</a>; <span class="comment">// same as EINA_FALSE</span>
}

<span class="keywordtype">int</span>
main(<span class="keywordtype">void</span>)
{
   <span class="keyword">struct </span>context ctxt = {0};

   <span class="keywordflow">if</span> (!<a class="code" href="group__Ecore__Init__Group.html#ga77757609684a2c922dc5ec398274751b">ecore_init</a>())
     {
        printf(<span class="stringliteral">&quot;ERROR: Cannot init Ecore!\n&quot;</span>);
        <span class="keywordflow">return</span> -1;
     }

   _event_type = <a class="code" href="group__Ecore__Event__Group.html#ga3fad8d8bfe3776c69d33aff1f056ba89" title="Allocates a new event type id sensibly and returns the new id.">ecore_event_type_new</a>();

   ctxt.enterer = <a class="code" href="group__Ecore__Idle__Group.html#ga0805b9840716bd08ae44956dba8de3e6">ecore_idle_enterer_add</a>(_enterer_cb, &amp;ctxt);
   ctxt.exiter = <a class="code" href="group__Ecore__Idle__Group.html#ga4bbd02660dd2b36a2da262a9bda3dfb4">ecore_idle_exiter_add</a>(_exiter_cb, &amp;ctxt);
   ctxt.idler = <a class="code" href="group__Ecore__Idle__Group.html#ga048ed35688c416f1f495912a900e9297">ecore_idler_add</a>(_idler_cb, &amp;ctxt);
<span class="comment">//   ctxt.idler = eo_add(ECORE_IDLER_CLASS, NULL, ecore_idler_constructor(_idler_cb, &amp;ctxt));</span>
   ctxt.handler = <a class="code" href="group__Ecore__Event__Group.html#gae75b0b1b2c50e73b8e42afc628b00a62" title="Adds an event handler.">ecore_event_handler_add</a>(_event_type,
                                          _event_handler_cb,
                                          &amp;ctxt);
   ctxt.timer = <a class="code" href="group__Ecore__Timer__Group.html#ga7b9cb9d24ecebfdbb957436e2e669402">ecore_timer_add</a>(0.0005, _timer_cb, &amp;ctxt);

   <a class="code" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a>();
   <a class="code" href="group__Ecore__Init__Group.html#ga768298b932f18d7e7593a447493e5cde">ecore_shutdown</a>();

   <span class="keywordflow">return</span> 0;
}

</pre></div> </div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
