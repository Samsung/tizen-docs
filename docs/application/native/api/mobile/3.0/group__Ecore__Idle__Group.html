<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore Idle functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">3.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Ecore__Idle__Group.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Ecore Idle functions</div>  </div>
<div class="ingroups"><a class="el" href="group__Ecore__Main__Loop__Group.html">Ecore main loop</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>The idler functionality in Ecore allows for callbacks to be called when the program isn't handling <a class="el" href="group__Ecore__Event__Group.html">events</a>, <a class="el" href="group__Ecore__Timer__Group.html">timers</a> or <a class="el" href="group__Ecore__FD__Handler__Group.html">fd handlers</a>.</p>
<p>There are three types of idlers: Enterers, Idlers(proper) and Exiters. They are called, respectively, when the program is about to enter an idle state, when the program is in an idle state and when the program has just left an idle state and will begin processing <a class="el" href="group__Ecore__Event__Group.html">events</a>, <a class="el" href="group__Ecore__Timer__Group.html">timers</a> or <a class="el" href="group__Ecore__FD__Handler__Group.html">fd handlers</a>.</p>
<p>Enterer callbacks are good for updating your program's state, if it has a state engine. Once all of the enterer handlers are called, the program will enter a "sleeping" state.</p>
<p>Idler callbacks are called when the main loop has called all enterer handlers. They are useful for interfaces that require polling and timers would be too slow to use.</p>
<p>Exiter callbacks are called when the main loop wakes up from an idle state.</p>
<p>If no idler callbacks are specified, then the process literally goes to sleep. Otherwise, the idler callbacks are called continuously while the loop is "idle", using as much CPU as is available to the process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Idle state doesn't mean that the <b>program</b> is idle, but that the <b>main loop</b> is idle. It doesn't have any timers, events, fd handlers or anything else to process (which in most <em>event driven</em> programs also means that the <b>program</b> is idle too, but it's not a rule). The program itself may be doing a lot of processing in the idler, or in another thread, for example.</dd></dl>
<p>Example with functions that deal with idle state:</p>
<ul>
<li><a class="el" href="ecore_idler_example_c.html">ecore idle state - Idlers, enterers and exiters</a> </li>
</ul>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#ga2cc50b0957bf0eaf0c024a7c053fa1dc">Ecore_Idler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga048ed35688c416f1f495912a900e9297">ecore_idler_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#gaf7b5ec4cc0d26179c1b5e3ee907e5d58">ecore_idler_del</a> (<a class="el" href="group__Ecore__Idle__Group.html#ga2cc50b0957bf0eaf0c024a7c053fa1dc">Ecore_Idler</a> *idler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#ga361e0801c2d510e54e92b54968863ca3">Ecore_Idle_Enterer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga0805b9840716bd08ae44956dba8de3e6">ecore_idle_enterer_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#ga361e0801c2d510e54e92b54968863ca3">Ecore_Idle_Enterer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga6aa00afaecb0a5a29add3bb92f534a0d">ecore_idle_enterer_before_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga7e1106729c49d0cd714ef58e0343470c">ecore_idle_enterer_del</a> (<a class="el" href="group__Ecore__Idle__Group.html#ga361e0801c2d510e54e92b54968863ca3">Ecore_Idle_Enterer</a> *idle_enterer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#ga0481e5c5dda1fa73f4e0296ef069692b">Ecore_Idle_Exiter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga4bbd02660dd2b36a2da262a9bda3dfb4">ecore_idle_exiter_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga89b7d6e94230fcbc331258f7aedf6010">ecore_idle_exiter_del</a> (<a class="el" href="group__Ecore__Idle__Group.html#ga0481e5c5dda1fa73f4e0296ef069692b">Ecore_Idle_Exiter</a> *idle_exiter)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Eo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga2cc50b0957bf0eaf0c024a7c053fa1dc">Ecore_Idler</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Eo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga361e0801c2d510e54e92b54968863ca3">Ecore_Idle_Enterer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Eo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga0481e5c5dda1fa73f4e0296ef069692b">Ecore_Idle_Exiter</a></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga361e0801c2d510e54e92b54968863ca3"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Idle_Enterer" ref="ga361e0801c2d510e54e92b54968863ca3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eo <a class="el" href="group__Ecore__Idle__Group.html#ga361e0801c2d510e54e92b54968863ca3">Ecore_Idle_Enterer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A handle for idle enterers </p>

</div>
</div>
<a class="anchor" id="ga0481e5c5dda1fa73f4e0296ef069692b"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Idle_Exiter" ref="ga0481e5c5dda1fa73f4e0296ef069692b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eo <a class="el" href="group__Ecore__Idle__Group.html#ga0481e5c5dda1fa73f4e0296ef069692b">Ecore_Idle_Exiter</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A handle for idle exiters </p>

</div>
</div>
<a class="anchor" id="ga2cc50b0957bf0eaf0c024a7c053fa1dc"></a><!-- doxytag: member="Ecore_Common.h::Ecore_Idler" ref="ga2cc50b0957bf0eaf0c024a7c053fa1dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eo <a class="el" href="group__Ecore__Idle__Group.html#ga2cc50b0957bf0eaf0c024a7c053fa1dc">Ecore_Idler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A handle for idlers </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0805b9840716bd08ae44956dba8de3e6"></a><!-- doxytag: member="Ecore_Legacy.h::ecore_idle_enterer_add" ref="ga0805b9840716bd08ae44956dba8de3e6" args="(Ecore_Task_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#ga361e0801c2d510e54e92b54968863ca3">Ecore_Idle_Enterer</a>* <a class="el" href="group__Ecore__Idle__Group.html#ga0805b9840716bd08ae44956dba8de3e6">ecore_idle_enterer_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds an idle enterer handler. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call when entering an idle state. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be passed to the <code>func</code> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to the idle enterer callback if successful. Otherwise, <code>NULL</code> is returned. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The function func will be called every time the main loop is entering idle state, as long as it returns <code>1</code> (or <code>ECORE_CALLBACK_RENEW</code>). A return of <code>0</code> (or <code>ECORE_CALLBACK_CANCEL</code>) deletes the idle enterer.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_idler_example_8c-example.html#a11">ecore_idler_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6aa00afaecb0a5a29add3bb92f534a0d"></a><!-- doxytag: member="Ecore_Legacy.h::ecore_idle_enterer_before_add" ref="ga6aa00afaecb0a5a29add3bb92f534a0d" args="(Ecore_Task_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#ga361e0801c2d510e54e92b54968863ca3">Ecore_Idle_Enterer</a>* <a class="el" href="group__Ecore__Idle__Group.html#ga6aa00afaecb0a5a29add3bb92f534a0d">ecore_idle_enterer_before_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds an idle enterer handler at the start of the list so it gets called earlier than others. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call when entering an idle state. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be passed to the <code>func</code> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to the idle enterer callback if successful. Otherwise, <code>NULL</code> is returned. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The function func will be called every time the main loop is entering idle state, as long as it returns <code>1</code> (or <code>ECORE_CALLBACK_RENEW</code>). A return of <code>0</code> (or <code>ECORE_CALLBACK_CANCEL</code>) deletes the idle enterer.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e1106729c49d0cd714ef58e0343470c"></a><!-- doxytag: member="Ecore_Legacy.h::ecore_idle_enterer_del" ref="ga7e1106729c49d0cd714ef58e0343470c" args="(Ecore_Idle_Enterer *idle_enterer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Idle__Group.html#ga7e1106729c49d0cd714ef58e0343470c">ecore_idle_enterer_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Idle__Group.html#ga361e0801c2d510e54e92b54968863ca3">Ecore_Idle_Enterer</a> *&#160;</td>
          <td class="paramname"><em>idle_enterer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes an idle enterer callback. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idle_enterer</td><td>The idle enterer to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data pointer passed to the idler enterer callback on success. <code>NULL</code> otherwise.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_idler_example_8c-example.html#a3">ecore_idler_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4bbd02660dd2b36a2da262a9bda3dfb4"></a><!-- doxytag: member="Ecore_Legacy.h::ecore_idle_exiter_add" ref="ga4bbd02660dd2b36a2da262a9bda3dfb4" args="(Ecore_Task_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#ga0481e5c5dda1fa73f4e0296ef069692b">Ecore_Idle_Exiter</a>* <a class="el" href="group__Ecore__Idle__Group.html#ga4bbd02660dd2b36a2da262a9bda3dfb4">ecore_idle_exiter_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds an idle exiter handler. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call when exiting an idle state. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be passed to the <code>func</code> call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to the idle exiter callback on success. <code>NULL</code> otherwise. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The function func will be called every time the main loop is exiting idle state, as long as it returns <code>1</code> (or <code>ECORE_CALLBACK_RENEW</code>). A return of <code>0</code> (or <code>ECORE_CALLBACK_CANCEL</code>) deletes the idle exiter.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_idler_example_8c-example.html#a12">ecore_idler_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga89b7d6e94230fcbc331258f7aedf6010"></a><!-- doxytag: member="Ecore_Legacy.h::ecore_idle_exiter_del" ref="ga89b7d6e94230fcbc331258f7aedf6010" args="(Ecore_Idle_Exiter *idle_exiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Idle__Group.html#ga89b7d6e94230fcbc331258f7aedf6010">ecore_idle_exiter_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Idle__Group.html#ga0481e5c5dda1fa73f4e0296ef069692b">Ecore_Idle_Exiter</a> *&#160;</td>
          <td class="paramname"><em>idle_exiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes an idle exiter handler from the list to be run on exiting idle state. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idle_exiter</td><td>The idle exiter to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data pointer that was being being passed to the handler if successful. <code>NULL</code> otherwise.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_idler_example_8c-example.html#a4">ecore_idler_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga048ed35688c416f1f495912a900e9297"></a><!-- doxytag: member="Ecore_Legacy.h::ecore_idler_add" ref="ga048ed35688c416f1f495912a900e9297" args="(Ecore_Task_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#ga2cc50b0957bf0eaf0c024a7c053fa1dc">Ecore_Idler</a>* <a class="el" href="group__Ecore__Idle__Group.html#ga048ed35688c416f1f495912a900e9297">ecore_idler_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds an idler handler. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call when idling. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be passed to this <code>func</code> call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A idler handle if successfully added, <code>NULL</code> otherwise.</dd></dl>
<p>Add an idler handle to the event loop, returning a handle on success and <code>NULL</code> otherwise. The function <code>func</code> will be called repeatedly while no other events are ready to be processed, as long as it returns <code>1</code> (or <code>ECORE_CALLBACK_RENEW</code>). A return of <code>0</code> (or <code>ECORE_CALLBACK_CANCEL</code>) deletes the idler.</p>
<p>Idlers are useful for progressively processing data without blocking.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ecore_idler_example_8c-example.html#a13">ecore_idler_example.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaf7b5ec4cc0d26179c1b5e3ee907e5d58"></a><!-- doxytag: member="Ecore_Legacy.h::ecore_idler_del" ref="gaf7b5ec4cc0d26179c1b5e3ee907e5d58" args="(Ecore_Idler *idler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Idle__Group.html#gaf7b5ec4cc0d26179c1b5e3ee907e5d58">ecore_idler_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Idle__Group.html#ga2cc50b0957bf0eaf0c024a7c053fa1dc">Ecore_Idler</a> *&#160;</td>
          <td class="paramname"><em>idler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deletes an idler callback from the list to be executed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idler</td><td>The handle of the idler callback to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data pointer passed to the idler callback on success, <code>NULL</code> otherwise.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
