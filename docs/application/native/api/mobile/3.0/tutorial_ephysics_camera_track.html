<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: EPhysics - Camera Track</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">EPhysics - Camera Track </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The purpose of this example is to demonstrate the EPhysics_Camera Track usage.</p>
<p>The EPhysics_Camera facilitates the usage of scenarios bigger than the viewport, thats because the EPhysics handles the position of objects which has control.</p>
<div class="image">
<img src="camera_track.png" alt="camera_track.png"/>
</div>
 <p>For this example we'll have an EPhysics_World, one main EPhysics_Body that will be tracked by an EPhysics_Camera on three ways, horizontal, vertical and full tracking. Also nine EPhysics_Bodys with mass 0, that will be used as scenario in order to our main body change its position on x and y axes when passes through this scenario.</p>
<p>The basic concepts like - initializing an EPhysics_World, render geometry, physics limiting boundaries, add an Ephysics_Body, associate it to evas objects, change restitution, friction and impulse properties, were already covered in <a class="el" href="tutorial_ephysics_bouncing_ball.html">EPhysics - Bouncing Ball</a></p>
<h2><a class="anchor" id="add-trkstruct"></a>
Track Data Struct</h2>
<p>While in this example we'll be working with a struct to hold some objects in our code. For clarity sake we present you the struct declaration in the following block.</p>
<p><div class="fragment"><pre class="fragment"><span class="keyword">struct </span>_Track_Data {
     Test_Data base;
     EPhysics_Body *body;
     <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *sp;
     <span class="keywordtype">int</span> old_cx;
};
</pre></div></p>
<h2><a class="anchor" id="add-camera"></a>
Adding a Camera</h2>
<p>In this example we'll use 3 kinds of tracking, to change this values we'll have an Elementary spinner widget and handle it on this function.</p>
<p>Every world has a camera, so here we get this camera used by our EPhysics_World.</p>
<p><div class="fragment"><pre class="fragment">_track_apply(Track_Data *track_data)
{
   <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> hor = <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>;
   <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> ver = <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>;
   EPhysics_Camera *camera;
   EPhysics_Body *body;
   <span class="keywordtype">int</span> mode;

   body = track_data-&gt;body;
   camera = ephysics_world_camera_get(track_data-&gt;base.world);
</pre></div></p>
<p>Here we'll get the elm_spinner value to the tracking base on this value</p>
<p><div class="fragment"><pre class="fragment">   mode = (int) <a class="code" href="group__Elm__Spinner.html#gac2a9d4a2e05073be0495e3323f52b7ab" title="Control the value the spinner displays.">elm_spinner_value_get</a>(track_data-&gt;sp);

   <span class="keywordflow">switch</span> (mode)
     {
      <span class="keywordflow">case</span> 1:
         hor = <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>;
         <span class="keywordflow">break</span>;
      <span class="keywordflow">case</span> 3:
         hor = <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>;
      <span class="keywordflow">case</span> 2:
         ver = <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>;
     }
</pre></div></p>
<p>Here we'll set the camera to track the body, when a body is tracked, the camera will move automatically, following this body. It will keeps the body centralized on rendered area. If it will be centralized horizontally and / or vertically depends if parameters horizontal and vertical are set to EINA_TRUE, in this case we based these values on elm_spinner.</p>
<p><div class="fragment"><pre class="fragment">   ephysics_camera_body_track(camera, body, hor, ver);
}
</pre></div></p>
<h2><a class="anchor" id="add-uptfloor"></a>
Updating the floor</h2>
<p>Here we'll use 2 floor images to give the impression of an infinite ground.</p>
<p>Calling ephysics_world_event_callback_add() will register a callback to a type of physics world event.</p>
<p>EPHYSICS_CALLBACK_WORLD_CAMERA_MOVED : called if the camera position changed on physics simulation tick.</p>
<p><div class="fragment"><pre class="fragment">   ephysics_world_event_callback_add(world,
                                     EPHYSICS_CALLBACK_WORLD_CAMERA_MOVED,
                                     _camera_moved_cb, track_data);
</pre></div></p>
<p>In the function, we'll get the cameras position to know how much the camera moved and move the same value to the floor passing it as delta_x to the function, note that we use an old_x variable to do this calculation.</p>
<p>We'll get also if the body is being tracked on x and y axes. If the body isn't being tracked on x axis the floors x position won't change, delta_x will be zero.</p>
<p><div class="fragment"><pre class="fragment">_camera_moved_cb(<span class="keywordtype">void</span> *data, EPhysics_World *world __UNUSED__, <span class="keywordtype">void</span> *event_info)
{
   EPhysics_Camera *camera = event_info;
   Track_Data *track_data = data;
   <span class="keywordtype">int</span> cx, cy, delta_x = 0;
   <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> hor, ver;

   DBG(<span class="stringliteral">&quot;Camera moved&quot;</span>);

   ephysics_camera_tracked_body_get(camera, NULL, &amp;hor, &amp;ver);
   ephysics_camera_position_get(camera, &amp;cx, &amp;cy);

   <span class="keywordflow">if</span> (hor)
     delta_x = track_data-&gt;old_cx - cx;

   _update_floor(track_data-&gt;base.layout, <span class="stringliteral">&quot;floor&quot;</span>, delta_x, cy, ver);
   _update_floor(track_data-&gt;base.layout, <span class="stringliteral">&quot;floor2&quot;</span>, delta_x, cy, ver);

   track_data-&gt;old_cx = cx;
}
</pre></div></p>
<p>Here we get the floors position and plus the delta_x value to move the floor in the same "velocity".</p>
<p><div class="fragment"><pre class="fragment">_update_floor(<a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *layout, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> delta_x, <span class="keywordtype">int</span> cy, <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> ver)
{
   <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *floor_obj;
   <span class="keywordtype">int</span> x, y, fx, fy;

   floor_obj = <a class="code" href="group__Evas__Object__Group__Extras.html#gafbad43015793eda4ae50202c0ce0e652">evas_object_data_get</a>(layout, name);
   <a class="code" href="group__Evas__Font__Group.html#ga6f52fab1a96dc58c85ee481d84bac871">evas_object_geometry_get</a>(floor_obj, &amp;x, &amp;y, NULL, NULL);
   fx = x + delta_x;
</pre></div></p>
<p>We use 2 floor images because whenever one exits the screen by the left side, another is being shown, when it happens the one which exit the screen is sent to the right side, entering into an infinite loop, giving the impression of an infinite ground image. Its important to note that we need to use the fx to don't gap the images.</p>
<p>Note that the fy is being defined considering its offsets, -20 is to the floor image be above the floor, thus having an border above the collision point, +40 is the render area height, to offset the cameras y, basically to draw in the correct position in the canvas.</p>
<p><div class="fragment"><pre class="fragment">   <span class="keywordflow">if</span> (fx &lt; -FLOOR_WIDTH)
     fx += 2 * FLOOR_WIDTH;

   fy = (ver) ? FLOOR_Y - 20 - cy + 40 : y;
   <a class="code" href="group__Evas__Font__Group.html#ga02da8091bbac768b8e86c7b74b2a94f9">evas_object_move</a>(floor_obj, fx, fy);
}
</pre></div></p>
<p>Here we finish the example. The full source code can be found at <a class="el" href="test_camera_track_c.html">test_camera_track.c</a>. </p>
</div></div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
