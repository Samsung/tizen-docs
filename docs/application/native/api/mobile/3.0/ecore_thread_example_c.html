<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore_Thread - API overview</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">3.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('ecore_thread_example_c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Ecore_Thread - API overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Working with threads is hard. Ecore helps to do so a bit easier, but as the example in <a class="el" href="ecore_thread_example_8c-example.html">ecore_thread_example.c</a> shows, there's a lot to consider even when doing the most simple things.</p>
<p>We'll be going through this thorough example now, showing how the differents aspects of <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> are used, but users are encourage to avoid threads unless it's really the only option, as they always add more complexity than the program usually requires.</p>
<p>Ecore Threads come in two flavors, short jobs and feedback jobs. Short jobs just run the given function and are more commonly used for small tasks where the main loop does not need to know how the work is going in between. The short job in our example is so short we had to artificially enlarge it with <code>sleep()</code>. Other than that, it also uses threads local data to keep the data we are working with persistent across different jobs ran by the same system thread. This data will be freed when the no more jobs are pending and the thread is terminated. If the data doesn't exist in the thread's storage, we create it and save it there for future jobs to find it. If creation fails, we cancel ourselves, so the main loop knows that we didn't just exit normally, meaning the job could not be done. The main part of the function checks in each iteration if it was canceled by the main loop, and if it was, it stops processing and clears the data from the storage (we assume <code>cancel</code> means no one else will need this, but this is really application dependent).  <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
_local_data_free(<span class="keywordtype">void</span> *data)
{
   Thread_Data *td = data;
   <span class="keywordtype">char</span> *str;

   <a class="code" href="group__Eina__List__Group.html#gae27a2c686a0a11693f9b06957c9bba83" title="Definition for the macro to remove each list node while having access to each node&#39;s data...">EINA_LIST_FREE</a>(td-&gt;list, str)
     {
        printf(<span class="stringliteral">&quot;Freeing string: %s\n&quot;</span>, str);
        free(str);
     }
   free(td);
}

<span class="keyword">static</span> <span class="keywordtype">void</span>
_short_job(<span class="keywordtype">void</span> *data EINA_UNUSED, <a class="code" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *th)
{
   Thread_Data *td;
   <span class="keywordtype">int</span> i;

   td = <a class="code" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad">ecore_thread_local_data_find</a>(th, <span class="stringliteral">&quot;data&quot;</span>);
   <span class="keywordflow">if</span> (!td)
     {
        td = calloc(1, <span class="keyword">sizeof</span>(Thread_Data));
        <span class="keywordflow">if</span> (!td)
          {
             <a class="code" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel</a>(th);
             <span class="keywordflow">return</span>;
          }
        <a class="code" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66">ecore_thread_local_data_add</a>(th, <span class="stringliteral">&quot;data&quot;</span>, td, _local_data_free,
                                    <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>);
     }

   <span class="keywordflow">for</span> (i = 0; i &lt; 10; i++)
     {
        <span class="keywordtype">char</span> buf[200];

        <span class="keywordflow">if</span> (<a class="code" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check</a>(th))
          {
             <a class="code" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779">ecore_thread_local_data_del</a>(th, <span class="stringliteral">&quot;data&quot;</span>);
             <span class="keywordflow">break</span>;
          }

        snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;Thread %p: String number %d&quot;</span>, th, i);
        td-&gt;list = <a class="code" href="group__Eina__List__Group.html#ga92ec14d1a1040a361c4d8cd0ab7b0ecc" title="Appends the given data to the given linked list.">eina_list_append</a>(td-&gt;list, strdup(buf));
        sleep(1);
     }
}
</pre></div></p>
<p>Feedback jobs, on the other hand, run tasks that will inform back to the main loop its progress, send partial data as is processed, just ping saying it's still alive and processing, or anything that needs the thread to talk back to the main loop. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
_feedback_job(<span class="keywordtype">void</span> *data EINA_UNUSED, <a class="code" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *th)
{
   time_t t;
   <span class="keywordtype">int</span> i, count;
   Feedback_Thread_Data *ftd = NULL;
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>   HANDLE h;
   WIN32_FIND_DATA fd;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>   DIR *dir;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>   App_Msg *msg;

   count = (int)(uintptr_t)<a class="code" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find</a>(<span class="stringliteral">&quot;count&quot;</span>);
   <span class="keywordflow">for</span> (i = 0; i &lt; count; i++)
     {
        <span class="keywordtype">char</span> buf[32];
        snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;data%d&quot;</span>, i);
        ftd = <a class="code" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find</a>(buf);
        <span class="keywordflow">if</span> (!ftd)
          <span class="keywordflow">continue</span>;
        <span class="keywordflow">if</span> (<a class="code" href="group__Eina__Lock__Group.html#ga13c8270c1589bfd4770ee4cd43977bc5" title="Attempts to take a lock if possible.">eina_lock_take_try</a>(&amp;ftd-&gt;mutex))
          <span class="keywordflow">break</span>;
        <span class="keywordflow">else</span>
          ftd = NULL;
     }
   <span class="keywordflow">if</span> (!ftd)
     <span class="keywordflow">return</span>;

<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>   h = FindFirstFile(ftd-&gt;base, &amp;fd);
   <span class="keywordflow">if</span> (h == INVALID_HANDLE_VALUE)
     <span class="keywordflow">goto</span> the_end;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>   dir = opendir(ftd-&gt;base);
   <span class="keywordflow">if</span> (!dir)
     <span class="keywordflow">goto</span> the_end;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
   msg = calloc(1, <span class="keyword">sizeof</span>(App_Msg));

   t = time(NULL);
   <span class="keywordflow">while</span> (time(NULL) &lt; t + 2)
     {
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        <span class="keywordflow">if</span> (strlen(fd.cFileName) &gt;= 10)
          msg-&gt;list = <a class="code" href="group__Eina__List__Group.html#ga92ec14d1a1040a361c4d8cd0ab7b0ecc" title="Appends the given data to the given linked list.">eina_list_append</a>(msg-&gt;list,
                                       strdup(fd.cFileName));
        FindNextFile(h, &amp;fd);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <span class="keyword">struct </span>dirent entry, *result;

        <span class="keywordflow">if</span> (readdir_r(dir, &amp;entry, &amp;result))
          <span class="keywordflow">break</span>;
        <span class="keywordflow">if</span> (!result)
          <span class="keywordflow">break</span>;

        <span class="keywordflow">if</span> (strlen(result-&gt;d_name) &gt;= 10)
          msg-&gt;list = <a class="code" href="group__Eina__List__Group.html#ga92ec14d1a1040a361c4d8cd0ab7b0ecc" title="Appends the given data to the given linked list.">eina_list_append</a>(msg-&gt;list,
                                       strdup(result-&gt;d_name));
<span class="preprocessor">#endif</span>
<span class="preprocessor">     }</span>
</pre></div></p>
<p>Finally, one more feedback job, but this one will be running outside of Ecore's pool, so we can use the pool for real work and keep this very light function unchecked. All it does is check if some condition is met and send a message to the main loop telling it it's time to close. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
_out_of_pool_job(<span class="keywordtype">void</span> *data, <a class="code" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *th)
{
   App_Data *ad = data;
   App_Msg *msg;

   <span class="keywordflow">while</span> (1)
     {
        <span class="keywordtype">int</span> msgs;
        <a class="code" href="group__Eina__Lock__Group.html#ga149f387d5f18c469c365147ffbd4dc2c" title="Causes a thread to wait until signaled by the condition.">eina_condition_wait</a>(&amp;ad-&gt;condition);
        msgs = ad-&gt;msgs_received;
        <a class="code" href="group__Eina__Lock__Group.html#ga469476cfe8d8ca4dfdc46469fb9e31e5" title="Releases a lock.">eina_lock_release</a>(&amp;ad-&gt;mutex);
        <span class="keywordflow">if</span> (msgs == ad-&gt;max_msgs)
          {
             msg = calloc(1, <span class="keyword">sizeof</span>(App_Msg));
             msg-&gt;all_done = 1;
             <a class="code" href="group__Ecore__Thread__Group.html#ga8fadd19caae011ab1483665f09ce4d91">ecore_thread_feedback</a>(th, msg);
             <span class="keywordflow">return</span>;
          }
     }
}
</pre></div></p>
<p>Every now and then the program prints its status, counting threads running and pending jobs. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
_print_status(<span class="keywordtype">void</span>)
{
   <span class="keywordtype">int</span> active, pending_total, pending_feedback, pending_short, available;

   active = <a class="code" href="group__Ecore__Thread__Group.html#gad7a28588dc26d6af8b6db8abc3ef37ce">ecore_thread_active_get</a>();
   pending_total = <a class="code" href="group__Ecore__Thread__Group.html#gaeaa014287d578a200d41cca861bceac3">ecore_thread_pending_total_get</a>();
   pending_feedback = <a class="code" href="group__Ecore__Thread__Group.html#gaa5c56445198f7b03c1f080039499689a">ecore_thread_pending_feedback_get</a>();
   pending_short = <a class="code" href="group__Ecore__Thread__Group.html#ga3e32f650cfe811e69bba7825c71b9070">ecore_thread_pending_get</a>();
   available = <a class="code" href="group__Ecore__Thread__Group.html#ga6e7703b3013d9c872449f6e2ec093b53">ecore_thread_available_get</a>();

   printf(<span class="stringliteral">&quot;Status:\n\t* Active threads: %d\n&quot;</span>
          <span class="stringliteral">&quot;\t* Available threads: %d\n&quot;</span>
          <span class="stringliteral">&quot;\t* Pending short jobs: %d\n&quot;</span>
          <span class="stringliteral">&quot;\t* Pending feedback jobs: %d\n&quot;</span>
          <span class="stringliteral">&quot;\t* Pending total: %d\n&quot;</span>, active, available, pending_short,
          pending_feedback, pending_total);
}
</pre></div></p>
<p>In our main loop, we'll be receiving messages from our feedback jobs using the same callback for both of them. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
_feedback_job_msg_cb(<span class="keywordtype">void</span> *data, <a class="code" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *th, <span class="keywordtype">void</span> *msg_data)
{
   App_Data *ad = data;
   App_Msg *msg = msg_data;
   <span class="keywordtype">char</span> *str;
</pre></div></p>
<p>The light job running out of the pool will let us know when we can exit our program. <div class="fragment"><pre class="fragment">
   <span class="keywordflow">if</span> (msg-&gt;all_done)
     {
        <a class="code" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a>();
        free(msg);
        <span class="keywordflow">return</span>;
     }
</pre></div></p>
<p>Next comes the handling of data sent from the actual worker threads, always remembering that the data belongs to us now, and not the thread, so it's our responsibility to free it. <div class="fragment"><pre class="fragment">
   _print_status();

   <span class="keywordflow">if</span> (!msg-&gt;list)
     printf(<span class="stringliteral">&quot;Received an empty list from thread %p\n&quot;</span>, th);
   <span class="keywordflow">else</span>
     {
        <span class="keywordtype">int</span> i = 0;
        printf(<span class="stringliteral">&quot;Received %d elements from threads %p (printing first 5):\n&quot;</span>,
               <a class="code" href="group__Eina__List__Group.html#ga301729054a498a2df09a5f1dd760697e" title="Gets the count of the number of items in a list.">eina_list_count</a>(msg-&gt;list), th);
        <a class="code" href="group__Eina__List__Group.html#gae27a2c686a0a11693f9b06957c9bba83" title="Definition for the macro to remove each list node while having access to each node&#39;s data...">EINA_LIST_FREE</a>(msg-&gt;list, str)
          {
             <span class="keywordflow">if</span> (i &lt;= 5)
               printf(<span class="stringliteral">&quot;\t%s\n&quot;</span>, str);
             free(str);
             i++;
          }
     }
</pre></div></p>
<p>Last, the condition to exit is given by how many messages we want to handle, so we need to count them and inform the condition checking thread that the value changed. <div class="fragment"><pre class="fragment">
   <a class="code" href="group__Eina__Lock__Group.html#ga2ad27b83cf8562a41fe67557d8d2d753" title="Attempts to take a lock.">eina_lock_take</a>(&amp;ad-&gt;mutex);
   ad-&gt;msgs_received++;
   <a class="code" href="group__Eina__Lock__Group.html#ga42cfdc4920e74fd7ba99527a6a99cd7d" title="Signals a thread waiting for a condition.">eina_condition_signal</a>(&amp;ad-&gt;condition);
   <a class="code" href="group__Eina__Lock__Group.html#ga469476cfe8d8ca4dfdc46469fb9e31e5" title="Releases a lock.">eina_lock_release</a>(&amp;ad-&gt;mutex);

   free(msg);
}
</pre></div></p>
<p>When a thread finishes its job or gets canceled, the main loop is notified through the callbacks set when creating the task. In this case, we just print what happen and keep track of one of them used to exemplify canceling. Here we are pretending one of our short jobs has a timeout, so if it doesn't finish before a timer is triggered, it will be canceled. <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span>
_thread_end_cb(<span class="keywordtype">void</span> *data, <a class="code" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *th)
{
   App_Data *ad = data;

   printf(<span class="stringliteral">&quot;Normal termination for thread %p.\n&quot;</span>, th);
   <span class="keywordflow">if</span> (th == ad-&gt;thread_3)
     ad-&gt;thread_3 = NULL;
}

<span class="keyword">static</span> <span class="keywordtype">void</span>
_thread_cancel_cb(<span class="keywordtype">void</span> *data, <a class="code" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *th)
{
   App_Data *ad = data;

   printf(<span class="stringliteral">&quot;Thread %p got cancelled.\n&quot;</span>, th);
   <span class="keywordflow">if</span> (th == ad-&gt;thread_3)
     ad-&gt;thread_3 = NULL;
}

<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_cancel_timer_cb(<span class="keywordtype">void</span> *data)
{
   App_Data *ad = data;

   <span class="keywordflow">if</span> (ad-&gt;thread_3 &amp;&amp; !<a class="code" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check</a>(ad-&gt;thread_3))
     <a class="code" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel</a>(ad-&gt;thread_3);

   <span class="keywordflow">return</span> <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>;
}
</pre></div></p>
<p>The main function does some setup that includes reading parameters from the command line to change its behaviour and test different results. These are: </p>
<ul>
<li>-t &lt;some_num&gt; maximum number of threads to run at the same time. </li>
<li>-p &lt;some_path&gt; adds <code>some_path</code> to the list used by the feedback jobs. This parameter can be used multiple times. </li>
<li>-m &lt;some_num&gt; the number of messages to process before the program is signalled to exit.</li>
</ul>
<p>Skipping some bits, we init Ecore and our application data. <div class="fragment"><pre class="fragment">   <a class="code" href="group__Ecore__Init__Group.html#ga77757609684a2c922dc5ec398274751b">ecore_init</a>();

   i = <a class="code" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220">ecore_thread_max_get</a>();
   printf(<span class="stringliteral">&quot;Initial max threads: %d\n&quot;</span>, i);

   memset(&amp;appdata, 0, <span class="keyword">sizeof</span>(App_Data));
   appdata.max_msgs = 1;
</pre></div></p>
<p>If any paths for the feedback jobs were given, we use them, otherwise we fallback to some defaults. Always initializing the proper mutexes used by the threaded job. <div class="fragment"><pre class="fragment">   <span class="keywordflow">if</span> (!path_list)
     {
        Feedback_Thread_Data *ftd;
        <a class="code" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a>(<span class="stringliteral">&quot;count&quot;</span>, (<span class="keywordtype">void</span> *)3, NULL, <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>);
        ftd = calloc(1, <span class="keyword">sizeof</span>(Feedback_Thread_Data));
        ftd-&gt;name = strdup(<span class="stringliteral">&quot;data0&quot;</span>);
        ftd-&gt;base = strdup(<span class="stringliteral">&quot;/usr/bin&quot;</span>);
        <a class="code" href="group__Eina__Lock__Group.html#ga8dda398c1db315582a80640c7f78f648" title="Initializes a new #Eina_Lock.">eina_lock_new</a>(&amp;ftd-&gt;mutex);
        <a class="code" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a>(ftd-&gt;name, ftd, NULL, <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>);
        ftd = calloc(1, <span class="keyword">sizeof</span>(Feedback_Thread_Data));
        ftd-&gt;name = strdup(<span class="stringliteral">&quot;data1&quot;</span>);
        ftd-&gt;base = strdup(<span class="stringliteral">&quot;/usr/lib&quot;</span>);
        <a class="code" href="group__Eina__Lock__Group.html#ga8dda398c1db315582a80640c7f78f648" title="Initializes a new #Eina_Lock.">eina_lock_new</a>(&amp;ftd-&gt;mutex);
        <a class="code" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a>(ftd-&gt;name, ftd, NULL, <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>);
        ftd = calloc(1, <span class="keyword">sizeof</span>(Feedback_Thread_Data));
        ftd-&gt;name = strdup(<span class="stringliteral">&quot;data2&quot;</span>);
        ftd-&gt;base = strdup(<span class="stringliteral">&quot;/usr/share&quot;</span>);
        <a class="code" href="group__Eina__Lock__Group.html#ga8dda398c1db315582a80640c7f78f648" title="Initializes a new #Eina_Lock.">eina_lock_new</a>(&amp;ftd-&gt;mutex);
        <a class="code" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a>(ftd-&gt;name, ftd, NULL, <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>);
     }
   <span class="keywordflow">else</span>
     {
        Feedback_Thread_Data *ftd;
        <span class="keywordtype">char</span> *str;
        <a class="code" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a>(<span class="stringliteral">&quot;count&quot;</span>,
                                     (<span class="keywordtype">void</span> *)(uintptr_t)<a class="code" href="group__Eina__List__Group.html#ga301729054a498a2df09a5f1dd760697e" title="Gets the count of the number of items in a list.">eina_list_count</a>(path_list), NULL,
                                     <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>);
        i = 0;
        <a class="code" href="group__Eina__List__Group.html#gae27a2c686a0a11693f9b06957c9bba83" title="Definition for the macro to remove each list node while having access to each node&#39;s data...">EINA_LIST_FREE</a>(path_list, str)
          {
             <span class="keywordtype">char</span> buf[32];
             snprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="stringliteral">&quot;data%d&quot;</span>, i);
             ftd = calloc(1, <span class="keyword">sizeof</span>(Feedback_Thread_Data));
             ftd-&gt;name = strdup(buf);
             ftd-&gt;base = strdup(str);
             <a class="code" href="group__Eina__Lock__Group.html#ga8dda398c1db315582a80640c7f78f648" title="Initializes a new #Eina_Lock.">eina_lock_new</a>(&amp;ftd-&gt;mutex);
             <a class="code" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a>(ftd-&gt;name, ftd, NULL, <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>);
             free(str);
             i++;
          }
     }
</pre></div></p>
<p>Initialize the mutex needed for the condition checking thread <div class="fragment"><pre class="fragment">   <a class="code" href="group__Eina__Lock__Group.html#ga8dda398c1db315582a80640c7f78f648" title="Initializes a new #Eina_Lock.">eina_lock_new</a>(&amp;appdata.mutex);
   <a class="code" href="group__Eina__Lock__Group.html#gaab2b734db1cbdaffe79559f6716ac793" title="Initializes a new condition variable.">eina_condition_new</a>(&amp;appdata.condition, &amp;appdata.mutex);
</pre></div></p>
<p>And start our tasks. <div class="fragment"><pre class="fragment">
   <a class="code" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run</a>(_out_of_pool_job, _feedback_job_msg_cb, NULL,
                             NULL, &amp;appdata, <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>);

   <a class="code" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run</a>(_short_job, _thread_end_cb, _thread_cancel_cb, &amp;appdata);
   <a class="code" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run</a>(_feedback_job, _feedback_job_msg_cb,
                             _thread_end_cb, _thread_cancel_cb, &amp;appdata,
                             <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>);
   appdata.thread_3 = <a class="code" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run</a>(_short_job, _thread_end_cb,
                                       _thread_cancel_cb, &amp;appdata);
   <a class="code" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run</a>(_feedback_job, _feedback_job_msg_cb,
                             _thread_end_cb, _thread_cancel_cb, &amp;appdata,
                             <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>);
</pre></div></p>
<p>To finalize, set a timer to cancel one of the tasks if it doesn't end before the timeout, one more timer for status report and get into the main loop. Once we are out, destroy our mutexes and finish the program. <div class="fragment"><pre class="fragment">
   <a class="code" href="group__Ecore__Timer__Group.html#ga7b9cb9d24ecebfdbb957436e2e669402">ecore_timer_add</a>(1.0, _cancel_timer_cb, &amp;appdata);
   <a class="code" href="group__Ecore__Timer__Group.html#ga7b9cb9d24ecebfdbb957436e2e669402">ecore_timer_add</a>(2.0, _status_timer_cb, NULL);

   _print_status();

   <a class="code" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a>();

   <a class="code" href="group__Eina__Lock__Group.html#ga838e1e7dfc8bbf114634a7de67de8956" title="Deallocates a condition variable.">eina_condition_free</a>(&amp;appdata.condition);
   <a class="code" href="group__Eina__Lock__Group.html#gaf8d1c4e3aff3bd26fc85d81ed8c4e71a" title="Deallocates an #Eina_Lock.">eina_lock_free</a>(&amp;appdata.mutex);

   <a class="code" href="group__Ecore__Init__Group.html#ga768298b932f18d7e7593a447493e5cde">ecore_shutdown</a>();

   <span class="keywordflow">return</span> 0;
}
</pre></div> </p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
