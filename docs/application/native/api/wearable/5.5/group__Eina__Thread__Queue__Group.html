<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Thread Queue Group</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.5</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Eina__Thread__Queue__Group.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Thread Queue Group</div>  </div>
<div class="ingroups"><a class="el" href="group__Eina.html">Eina</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>These functions provide simple zero-copy message queues for threads. </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#gadcb3ccf8211f36644008f4a8c7ecce77">eina_thread_queue_new</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread queue.  <a href="#gadcb3ccf8211f36644008f4a8c7ecce77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga3797df8c0a9f2dcd86da8c971316e1d3">eina_thread_queue_free</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a thread queue.  <a href="#ga3797df8c0a9f2dcd86da8c971316e1d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga44e757fc9b6566f5d209f09a800aa638">eina_thread_queue_send</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, int size, void **allocref)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a message to send down a thread queue.  <a href="#ga44e757fc9b6566f5d209f09a800aa638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga338ae6b9a613eb3e227cbab06c94ab4f">eina_thread_queue_send_done</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, void *allocref)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes sending the allocated message.  <a href="#ga338ae6b9a613eb3e227cbab06c94ab4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#gad25bf389aa93c3f7f814ff2015eb27ce">eina_thread_queue_wait</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, void **allocref)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches a message from a thread queue.  <a href="#gad25bf389aa93c3f7f814ff2015eb27ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga1ccc3cfbf71e80596f9825d6c6fd6135">eina_thread_queue_wait_done</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, void *allocref)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes fetching a message from a thread queue.  <a href="#ga1ccc3cfbf71e80596f9825d6c6fd6135"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga4b9f65958da9fee0e59106d8faf31390">eina_thread_queue_poll</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, void **allocref)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches a message from a thread queue, but return immediately if there is none with NULL.  <a href="#ga4b9f65958da9fee0e59106d8faf31390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga710c894586159601163826961f0f62b4">eina_thread_queue_pending_get</a> (const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of messages on a queue as yet unfetched.  <a href="#ga710c894586159601163826961f0f62b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#gad0903fc27ff93c55b0b432dbbf53491d">eina_thread_queue_parent_set</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq_parent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent of a thread queue (make this one a child).  <a href="#gad0903fc27ff93c55b0b432dbbf53491d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#gadb13e550bc7899e83a98b225986d4406">eina_thread_queue_parent_get</a> (const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent of a thread queue.  <a href="#gadb13e550bc7899e83a98b225986d4406"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#gae776bfd1d50f9a591ef6230316c4d72e">eina_thread_queue_fd_set</a> (<a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq, int fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a file descriptor to write a byte to on a message send.  <a href="#gae776bfd1d50f9a591ef6230316c4d72e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#gac2389428764e684288e2896c494b5546">eina_thread_queue_fd_get</a> (const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *thq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file descriptor written to on message sends.  <a href="#gac2389428764e684288e2896c494b5546"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct _Eina_Thread_Queue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
_Eina_Thread_Queue_Msg&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga691263b2be42e2b5671448f275687eb5">Eina_Thread_Queue_Msg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
_Eina_Thread_Queue_Msg_Sub&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga6f77f4fb207e88cc9455ef661d3b9f12">Eina_Thread_Queue_Msg_Sub</a></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga414a1a16533bf9ba8bdf14ffb61c2ed9"></a><!-- doxytag: member="eina_thread_queue.h::Eina_Thread_Queue" ref="ga414a1a16533bf9ba8bdf14ffb61c2ed9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a uni-directional zero-copy thread message queue specifically designed with the idea of sending large volumes of messages with no copies from one thread to another (or from/to the mainloop). The idea is that a thread queue is created and then one or more threads send messages in one end and fetch messages off the other end. If you set a parent message queue to 1 or more queues, then this parent will wake up with a sub queue message, indicating which child queue woke up. This can be used to implement the ability to listen to multiple queues at once.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>

</div>
</div>
<a class="anchor" id="ga691263b2be42e2b5671448f275687eb5"></a><!-- doxytag: member="eina_thread_queue.h::Eina_Thread_Queue_Msg" ref="ga691263b2be42e2b5671448f275687eb5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga691263b2be42e2b5671448f275687eb5">Eina_Thread_Queue_Msg</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the minimal header of every message to be put into an Eina Thread Queue. Every message has at least this header at the start of the message data, with payload following. You would put this structure as the first struct member of every message type you have, like Eina_Thread_Queue_Msg_Sub does. Messages are always 8 byte aligned within message memory to ensure alignment of all types.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f77f4fb207e88cc9455ef661d3b9f12"></a><!-- doxytag: member="eina_thread_queue.h::Eina_Thread_Queue_Msg_Sub" ref="ga6f77f4fb207e88cc9455ef661d3b9f12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga6f77f4fb207e88cc9455ef661d3b9f12">Eina_Thread_Queue_Msg_Sub</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a special message type for Eina Thread Queues that have child queues. This is the only Message type for a parent message queue and it indicates which child queue was woken up with a new message to read. When this message is retrieved, the caller should then also fetch the message from the indicated child queue too.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gac2389428764e684288e2896c494b5546"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_fd_get" ref="gac2389428764e684288e2896c494b5546" args="(const Eina_Thread_Queue *thq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Eina__Thread__Queue__Group.html#gac2389428764e684288e2896c494b5546">eina_thread_queue_fd_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the file descriptor written to on message sends. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thq</td><td>The thread queue to get the file descriptor of </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The file descriptor set (or -1 if none is set).</dd></dl>
<p>This returns the file descriptor set by <a class="el" href="group__Eina__Thread__Queue__Group.html#gae776bfd1d50f9a591ef6230316c4d72e" title="Sets a file descriptor to write a byte to on a message send.">eina_thread_queue_fd_set()</a> and by default returns -1 (no fd set).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__Thread__Queue__Group.html#gae776bfd1d50f9a591ef6230316c4d72e" title="Sets a file descriptor to write a byte to on a message send.">eina_thread_queue_fd_set()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gae776bfd1d50f9a591ef6230316c4d72e"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_fd_set" ref="gae776bfd1d50f9a591ef6230316c4d72e" args="(Eina_Thread_Queue *thq, int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Eina__Thread__Queue__Group.html#gae776bfd1d50f9a591ef6230316c4d72e">eina_thread_queue_fd_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a file descriptor to write a byte to on a message send. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to set the file descriptor of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>The fd to set, or -1 to unset it</td></tr>
  </table>
  </dd>
</dl>
<p>This sets a file descriptor to write to when a message is written to the thread queue. This can be used to glue a thread queue to something like an Ecore_Pipe that can wake up the mainloop and call a callback whenever data is available on the pipe. The number of bytes available will be the number of messages to fetch from the associated thread queue.</p>
<p>You should set this up before anything writes to or reads from this thread queue.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga3797df8c0a9f2dcd86da8c971316e1d3"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_free" ref="ga3797df8c0a9f2dcd86da8c971316e1d3" args="(Eina_Thread_Queue *thq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Eina__Thread__Queue__Group.html#ga3797df8c0a9f2dcd86da8c971316e1d3">eina_thread_queue_free</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees a thread queue. </p>
<p>This frees a thread queue. It must no longer be in use by anything waiting on messages or sending them. Any pending messages will be freed without being processed by a listener.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thq</td><td>The thread queue to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gadcb3ccf8211f36644008f4a8c7ecce77"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_new" ref="gadcb3ccf8211f36644008f4a8c7ecce77" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a>* <a class="el" href="group__Eina__Thread__Queue__Group.html#gadcb3ccf8211f36644008f4a8c7ecce77">eina_thread_queue_new</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new thread queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid new thread queue, or NULL on failure</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gadb13e550bc7899e83a98b225986d4406"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_parent_get" ref="gadb13e550bc7899e83a98b225986d4406" args="(const Eina_Thread_Queue *thq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a>* <a class="el" href="group__Eina__Thread__Queue__Group.html#gadb13e550bc7899e83a98b225986d4406">eina_thread_queue_parent_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the parent of a thread queue. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thq</td><td>The thread queue to get the parent of </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The parent thread queue</dd></dl>
<p>This gets the parent set by <a class="el" href="group__Eina__Thread__Queue__Group.html#gadb13e550bc7899e83a98b225986d4406" title="Gets the parent of a thread queue.">eina_thread_queue_parent_get()</a>. If no parent is set, NULL is returned.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__Thread__Queue__Group.html#gad0903fc27ff93c55b0b432dbbf53491d" title="Sets the parent of a thread queue (make this one a child).">eina_thread_queue_parent_set()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gad0903fc27ff93c55b0b432dbbf53491d"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_parent_set" ref="gad0903fc27ff93c55b0b432dbbf53491d" args="(Eina_Thread_Queue *thq, Eina_Thread_Queue *thq_parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Eina__Thread__Queue__Group.html#gad0903fc27ff93c55b0b432dbbf53491d">eina_thread_queue_parent_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq_parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the parent of a thread queue (make this one a child). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to alter the parent of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thq_parent</td><td>The new parent to set</td></tr>
  </table>
  </dd>
</dl>
<p>This sets the parent queue where messages will be reported to. This is how you can listen to multiple queues at once - set multiple queues to have the same parent and then just wait on that one parent. This should be done before any messages are read from or written to the queue. To unset a parent, just set the parent to NULL.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga710c894586159601163826961f0f62b4"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_pending_get" ref="ga710c894586159601163826961f0f62b4" args="(const Eina_Thread_Queue *thq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Eina__Thread__Queue__Group.html#ga710c894586159601163826961f0f62b4">eina_thread_queue_pending_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of messages on a queue as yet unfetched. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thq</td><td>The thread queue to query for pending count </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of messages waiting to be fetched</dd></dl>
<p>This returns the number of messages waiting to be fetched with <a class="el" href="group__Eina__Thread__Queue__Group.html#gad25bf389aa93c3f7f814ff2015eb27ce" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a> or <a class="el" href="group__Eina__Thread__Queue__Group.html#ga4b9f65958da9fee0e59106d8faf31390" title="Fetches a message from a thread queue, but return immediately if there is none with NULL...">eina_thread_queue_poll()</a>.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b9f65958da9fee0e59106d8faf31390"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_poll" ref="ga4b9f65958da9fee0e59106d8faf31390" args="(Eina_Thread_Queue *thq, void **allocref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Eina__Thread__Queue__Group.html#ga4b9f65958da9fee0e59106d8faf31390">eina_thread_queue_poll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetches a message from a thread queue, but return immediately if there is none with NULL. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to fetch the message from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocref</td><td>A pointer to store a general reference handle for the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the message data</dd></dl>
<p>This is the same as <a class="el" href="group__Eina__Thread__Queue__Group.html#gad25bf389aa93c3f7f814ff2015eb27ce" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a>, but if no messages are available for reading, it immediately returns NULL to the caller, without waiting for a new message to arrive.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Eina__Thread__Queue__Group.html#gad25bf389aa93c3f7f814ff2015eb27ce" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga44e757fc9b6566f5d209f09a800aa638"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_send" ref="ga44e757fc9b6566f5d209f09a800aa638" args="(Eina_Thread_Queue *thq, int size, void **allocref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Eina__Thread__Queue__Group.html#ga44e757fc9b6566f5d209f09a800aa638">eina_thread_queue_send</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a message to send down a thread queue. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to allocate the message on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the message, including standard header </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocref</td><td>A pointer to store a general reference handle for the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the message data to fill in</dd></dl>
<p>This allocates space for a new message on the message queue, but does not actually trigger the send. For that you will need to call <a class="el" href="group__Eina__Thread__Queue__Group.html#ga338ae6b9a613eb3e227cbab06c94ab4f" title="Finishes sending the allocated message.">eina_thread_queue_send_done()</a> to complete the send and trigger the other side. Every message must at least be a Eina_Thread_Queue_Msg in size and have this structure as the first member (first N bytes) of the message.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga338ae6b9a613eb3e227cbab06c94ab4f"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_send_done" ref="ga338ae6b9a613eb3e227cbab06c94ab4f" args="(Eina_Thread_Queue *thq, void *allocref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Eina__Thread__Queue__Group.html#ga338ae6b9a613eb3e227cbab06c94ab4f">eina_thread_queue_send_done</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes sending the allocated message. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue the message was placed on </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">allocref</td><td>The allocref returned by <a class="el" href="group__Eina__Thread__Queue__Group.html#ga44e757fc9b6566f5d209f09a800aa638" title="Allocates a message to send down a thread queue.">eina_thread_queue_send()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This completes the send and triggers the thread queue to wake up any listeners.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gad25bf389aa93c3f7f814ff2015eb27ce"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_wait" ref="gad25bf389aa93c3f7f814ff2015eb27ce" args="(Eina_Thread_Queue *thq, void **allocref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Eina__Thread__Queue__Group.html#gad25bf389aa93c3f7f814ff2015eb27ce">eina_thread_queue_wait</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetches a message from a thread queue. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue to fetch the message from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">allocref</td><td>A pointer to store a general reference handle for the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the message data</dd></dl>
<p>This will fetch the next message to read from the thread queue and return a pointer to it. The message is guaranteed to have an initial Eina_Thread_Queue_Msg member that will indicate size of the message as a whole. This function will wait, if no messages are available to read and block until a new message comes in, then return. When the message is finished with, the caller must use <a class="el" href="group__Eina__Thread__Queue__Group.html#ga1ccc3cfbf71e80596f9825d6c6fd6135" title="Finishes fetching a message from a thread queue.">eina_thread_queue_wait_done()</a> to indicate they are done.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ccc3cfbf71e80596f9825d6c6fd6135"></a><!-- doxytag: member="eina_thread_queue.h::eina_thread_queue_wait_done" ref="ga1ccc3cfbf71e80596f9825d6c6fd6135" args="(Eina_Thread_Queue *thq, void *allocref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Eina__Thread__Queue__Group.html#ga1ccc3cfbf71e80596f9825d6c6fd6135">eina_thread_queue_wait_done</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Eina__Thread__Queue__Group.html#ga414a1a16533bf9ba8bdf14ffb61c2ed9">Eina_Thread_Queue</a> *&#160;</td>
          <td class="paramname"><em>thq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>allocref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finishes fetching a message from a thread queue. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thq</td><td>The thread queue the message was fetched from </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">allocref</td><td>The allocref returned by <a class="el" href="group__Eina__Thread__Queue__Group.html#gad25bf389aa93c3f7f814ff2015eb27ce" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This should be used after <a class="el" href="group__Eina__Thread__Queue__Group.html#gad25bf389aa93c3f7f814ff2015eb27ce" title="Fetches a message from a thread queue.">eina_thread_queue_wait()</a> or <a class="el" href="group__Eina__Thread__Queue__Group.html#ga4b9f65958da9fee0e59106d8faf31390" title="Fetches a message from a thread queue, but return immediately if there is none with NULL...">eina_thread_queue_poll()</a> to indicate the caller is done with the message.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.11 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
