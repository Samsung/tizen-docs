<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: EPhysics - Bouncing Ball</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">EPhysics - Bouncing Ball </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The purpose of this example is to show how to write an simple application - as the name suggests - with a small ball bouncing on the ground and responding to users events by making it jump - applying a central impulse on it.</p>
<div class="image">
<img src="bouncing_ball.png" alt="bouncing_ball.png"/>
</div>
 <p>We'll guide you on defining a EPhysics world, defining its render geometry and the physics limiting boundaries, you'll learn how to add EPhysics bodies and how to associate it to evas objects. We also explain how to change restitution and friction properties. We see how to apply central impulse on a EPhysics_Body by implementing an elementary input event callback and calling the proper function.</p>
<h2><a class="anchor" id="test-structure"></a>
A test struct</h2>
<p>While in this example we'll be working with a struct to hold some objects in our code. For clarity sake we present you the struct declaration in the following block.</p>
<p><div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>_Test_Data Test_Data;

<span class="keyword">struct </span>_Test_Data {
     EPhysics_World *world;
     <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *layout;
     <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *win;
     <a class="code" href="struct__Eina__List.html">Eina_List</a> *constraints;
     <a class="code" href="struct__Eina__List.html">Eina_List</a> *evas_objs;
     <a class="code" href="struct__Eina__List.html">Eina_List</a> *bodies;
     <span class="keywordtype">void</span> *data;
};
</pre></div></p>
<h2><a class="anchor" id="world-new"></a>
World Initialization</h2>
<p>Calling ephysics_world_new() will create a new physics world with its collision configuration, constraint solver, broadphase interface and dispatcher.</p>
<p>The default gravity is set to -9.81. It's possible to stop a running world but its default status is running. Take a look at ephysics_world_running_set() for further informations about world running status.</p>
<p><div class="fragment"><pre class="fragment">   world = ephysics_world_new();
</pre></div></p>
<h2><a class="anchor" id="render-geometry"></a>
Render geometry</h2>
<p>By setting the render geometry you tell ephysics the dimensions of rendered area to be take on account by default updates.</p>
<p>By default it starts with null x, y, z, width, height and depth. Initially there's no physics limits but - as we'll see later in this example - boundaries can be added by issuing either ephysics_body_top_boundary_add(), ephysics_body_bottom_boundary_add(), ephysics_body_left_boundary_add() and ephysics_body_right_boundary_add().</p>
<p>While setting the worlds render geometry the first parameter is our just created world, the following parameters indicate the x, y, z, width, height and depth of our area of interest.</p>
<p><div class="fragment"><pre class="fragment">   ephysics_world_render_geometry_set(world, 50, 40, -50,
                                      WIDTH - 100, FLOOR_Y - 40, DEPTH);
</pre></div></p>
<h2><a class="anchor" id="boundaries"></a>
Adding boundaries</h2>
<p>Boundaries are physics limits added by EPhysics which you can use to limit the area where your objects can move around. Bear in mind that those boundaries are created by EPhysics taking in account the render geometry you have previously defined by calling ephysics_world_render_geometry_set().</p>
<p>In our example we start by adding a bottom boundary. This EPhysics_Body represents a physics limit under the world render geometry.</p>
<p>The second line states the restitution factor for that bottom boundary, and the third line its friction. These changes will make our ball to bounce whenever it hits the ground.</p>
<p><div class="fragment"><pre class="fragment">   boundary = ephysics_body_bottom_boundary_add(test_data-&gt;world);
   ephysics_body_restitution_set(boundary, 0.65);
   ephysics_body_friction_set(boundary, 4);
</pre></div></p>
<p>Then we add a right boundary limiting the physics world on the left side, we also change its restitution and friction factors but with a smaller value, we don't want to make it bounce as much as it is when hits the ground.</p>
<p><div class="fragment"><pre class="fragment">   boundary = ephysics_body_right_boundary_add(test_data-&gt;world);
   ephysics_body_restitution_set(boundary, 0.4);
   ephysics_body_friction_set(boundary, 3);
</pre></div></p>
<p>We also add a left boundary taking the same considerations for right boundary.</p>
<p><div class="fragment"><pre class="fragment">   boundary = ephysics_body_left_boundary_add(test_data-&gt;world);
   ephysics_body_restitution_set(boundary, 0.4);
   ephysics_body_friction_set(boundary, 3);
</pre></div></p>
<p>One of this examples requirements is to make the ball jump after a specific user event, so the ball can suffer an impulse for any direction.</p>
<p>With an upper impulse we don't want our ball to fly all over there, we want to limit its upper movements, it's intended to limit the ball movement within a box, it should not leave the render geometry area, for that purpose we must define a top boundary.</p>
<p><div class="fragment"><pre class="fragment">   ephysics_body_top_boundary_add(test_data-&gt;world);
</pre></div> <h2><a class="anchor" id="world-populate"></a>
Adding a ball</h2>
<p>Since we have defined the physics limits with our boundaries it's time to add some fun. Here we add a ball as an elementary image widget and tell ephysics about it.</p>
<p>After setting the file that will be used as the image's source of our elm image we move it to the center of render geometry and resize it to 70x70 pixels and show it.</p>
<p><div class="fragment"><pre class="fragment">   sphere = <a class="code" href="group__Elm__Image.html#ga5d211c8af4f6e297a24fc4e8737c81a9">elm_image_add</a>(test_data-&gt;win);
   <a class="code" href="group__Elm__Image.html#gad1a96ede5f513042cef3c1dac4572f73">elm_image_file_set</a>(
      sphere, PACKAGE_DATA_DIR <span class="stringliteral">&quot;/&quot;</span> EPHYSICS_TEST_THEME <span class="stringliteral">&quot;.edj&quot;</span>, <span class="stringliteral">&quot;big-blue-ball&quot;</span>);
   <a class="code" href="group__Evas__Font__Group.html#ga02da8091bbac768b8e86c7b74b2a94f9">evas_object_move</a>(sphere, WIDTH / 3, HEIGHT / 8);
   <a class="code" href="group__Evas__Font__Group.html#ga21e8604c0e4a93e469bff4bd069e82b5">evas_object_resize</a>(sphere, 70, 70);
   <a class="code" href="group__Evas__Font__Group.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(sphere);
</pre></div></p>
<p>The evas object is just set and we must tell EPhysics about it, creating the EPhysics_Body representing our ball and associating it to the just created evas object.</p>
<p>Once the ball has been moved to the center of render geometry it should start falling after associating it to the EPhysics_Body. By default its mass is initially set to 1 kilo, but it can be changed by calling ephysics_body_mass_set(). Bear in mind that if you change its mass to 0 kilos it becomes a static body and will not move at all, the body will remain fixed in the initial position.</p>
<p>In the following code the first line adds a circle body, then we associate the evas object to EPhysics_Body, EPhysics will map every changes on physics object simulation to its evas object. Some restitution and friction factors are added as well.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<h2><a class="anchor" id="jumping-ball"></a>
Making it jump</h2>
<p>The next step is to give us the ability to make our ball to jump - actually apply some impulse whenever a key has been pressed. Then we add a elementary input callback to the window widget.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The jumping callback implementation consists on handling only key up events and discarding any other input event we get. We're interested on keyboard events only. All the operations done in the following lines are done on sphere EPhysics_Body previously created.</p>
<p>We mainly use the ephysics_body_central_impulse_apply() function. This function applies an impulse on the center of a body.</p>
<p>Once pressed &lt;Up&gt; key it applies a central impulse of 0 kilos on X axis, 10 kilos on Y and 0 kilos on Z - so the ball is forced up.</p>
<p>If &lt;Down&gt; key has been pressed we apply an impulse of 0 kilos on X axis, -10 kilos on Y and 0 kilos on Z - here the ball is forced down.</p>
<p>In the case of &lt;Right&gt; key pressing it's applied an impulse of 10 kilos on X axis, 0 kilos on Y and 0 kilos on Z - which applies a force to the right side. But if the key being pressed is &lt;Left&gt; the opposite is done, and an impulse of -10 kilos is applied on X, 0 kilos on Y and 0 kilos on Z - and the ball is forced to the left.</p>
<p><div class="fragment"><pre class="fragment">_on_keydown(<span class="keywordtype">void</span> *data, <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *obj __UNUSED__, <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *src __UNUSED__, <a class="code" href="group__Evas.html#gad64cde0da38a60e7cb7905b3ab216968">Evas_Callback_Type</a> type, <span class="keywordtype">void</span> *event_info)
{
   <a class="code" href="struct__Evas__Event__Key__Down.html">Evas_Event_Key_Down</a> *ev = event_info;
   EPhysics_Body *body = data;

   <span class="keywordflow">if</span> (type != <a class="code" href="group__Evas.html#ggad64cde0da38a60e7cb7905b3ab216968ac436b50ad665089f8a24b0fb827cec5f">EVAS_CALLBACK_KEY_UP</a>)
     <span class="keywordflow">return</span> <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>;

   <span class="keywordflow">if</span> (strcmp(ev-&gt;<a class="code" href="struct__Evas__Event__Key__Down.html#a70473bba88a1afaee180a54150513824">key</a>, <span class="stringliteral">&quot;Up&quot;</span>) == 0)
     ephysics_body_central_impulse_apply(body, 0, -300, 0);
   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(ev-&gt;<a class="code" href="struct__Evas__Event__Key__Down.html#a70473bba88a1afaee180a54150513824">key</a>, <span class="stringliteral">&quot;Down&quot;</span>) == 0)
     ephysics_body_central_impulse_apply(body, 0, 300, 0);
   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(ev-&gt;<a class="code" href="struct__Evas__Event__Key__Down.html#a70473bba88a1afaee180a54150513824">key</a>, <span class="stringliteral">&quot;Right&quot;</span>) == 0)
     ephysics_body_central_impulse_apply(body, 300, 0, 0);
   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(ev-&gt;<a class="code" href="struct__Evas__Event__Key__Down.html#a70473bba88a1afaee180a54150513824">key</a>, <span class="stringliteral">&quot;Left&quot;</span>) == 0)
     ephysics_body_central_impulse_apply(body, -300, 0, 0);

   <span class="keywordflow">return</span> <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>;
}
</pre></div></p>
<p>Here we finish the very simple bouncing ball example. The full source code can be found at <a class="el" href="test_bouncing_ball_c.html">test_bouncing_ball.c</a>. </p>
</div></div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
