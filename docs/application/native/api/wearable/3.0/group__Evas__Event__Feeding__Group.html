<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Input Events Feeding Functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">3.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Evas__Event__Feeding__Group.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Input Events Feeding Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__Evas__Canvas__Events.html">Canvas Events</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>Functions to tell Evas that input events happened and should be processed.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Most of the time these functions are <b>not</b> what you're looking for. These functions should only be used if you're not working with ecore evas(or another input handling system). If you're not using ecore evas please consider using it, in most situation it will make life a lot easier.</dd></dl>
<p>As explained in intro_not_evas, Evas does not know how to poll for input events, so the developer should do it and then feed such events to the canvas to be processed. This is only required if operating Evas directly. Modules such as Ecore_Evas do that for you.</p>
<p>Some of the functions in this group are exemplified <a class="el" href="Example_Evas_Events.html">here</a>. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Evas_Device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gafa4fb5030c83d1b49d87f3016ecf5d8e">evas_device_add</a> (<a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#ga73e1616a2b3cfd3c165a8dcca162eaaf">evas_device_del</a> (Evas_Device *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gae1c145ffcfeb301faa1d52d3b1086c42">evas_device_push</a> (<a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, Evas_Device *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#ga18273057afa4a086a0f3e459e90323ad">evas_device_pop</a> (<a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gae75c9ad6a7df347d7a6c894e9b48dce8">evas_device_list</a> (<a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, const Evas_Device *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#ga37f4666b0a0dad0b8e1dfb3b5bc016ee">evas_device_name_set</a> (Evas_Device *dev, const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gaec5dc5b3582c7cd8959635f09eeafb4a">evas_device_name_get</a> (const Evas_Device *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#ga9621012a50076697ce5d1c5c73584638">evas_device_description_set</a> (Evas_Device *dev, const char *desc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gaba810711417b80d8fb154fe0fb9cb37c">evas_device_description_get</a> (const Evas_Device *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#ga905bf02ef71debc15a296f541a74c7d0">evas_device_parent_set</a> (Evas_Device *dev, Evas_Device *parent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const Evas_Device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#ga19002f3e6d472772ea47df94942d8b83">evas_device_parent_get</a> (const Evas_Device *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gadd1433c895b5d06cab9e6bbd97cae835">evas_device_class_set</a> (Evas_Device *dev, Evas_Device_Class clas)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Evas_Device_Class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#ga48345e08c83930c86dd972c0b4a152bf">evas_device_class_get</a> (const Evas_Device *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gac468ac5b5780d020f7ac453ab8717d63">evas_device_subclass_set</a> (Evas_Device *dev, Evas_Device_Subclass clas)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Evas_Device_Subclass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gaac0eb10da59f01d8439ec43f9295cc9f">evas_device_subclass_get</a> (const Evas_Device *dev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gab8a4f7145896328f8cc6b805954813c9">evas_device_emulation_source_set</a> (Evas_Device *dev, Evas_Device *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const Evas_Device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Event__Feeding__Group.html#gaeb021665824f6432b7af2019bffbb4b6">evas_device_emulation_source_get</a> (const Evas_Device *dev)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gafa4fb5030c83d1b49d87f3016ecf5d8e"></a><!-- doxytag: member="Evas_Common.h::evas_device_add" ref="gafa4fb5030c83d1b49d87f3016ecf5d8e" args="(Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Evas_Device* <a class="el" href="group__Evas__Event__Feeding__Group.html#gafa4fb5030c83d1b49d87f3016ecf5d8e">evas_device_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a new device type</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The canvas to create the device node for.</td></tr>
  </table>
  </dd>
</dl>
<p>Adds a new device node to the given canvas <code>e</code>. All devices created as part of the canvas <code>e</code> will automatically be deleted when the canvas is freed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the device node created or NULL if an error occurred.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Event__Feeding__Group.html#ga73e1616a2b3cfd3c165a8dcca162eaaf">evas_device_del</a> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga48345e08c83930c86dd972c0b4a152bf"></a><!-- doxytag: member="Evas_Common.h::evas_device_class_get" ref="ga48345e08c83930c86dd972c0b4a152bf" args="(const Evas_Device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Evas_Device_Class <a class="el" href="group__Evas__Event__Feeding__Group.html#ga48345e08c83930c86dd972c0b4a152bf">evas_device_class_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the major class of a device</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The devise to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The device class to set</dd></dl>
<p>This sets the device class set by <a class="el" href="group__Evas__Event__Feeding__Group.html#gadd1433c895b5d06cab9e6bbd97cae835">evas_device_class_set()</a>.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gadd1433c895b5d06cab9e6bbd97cae835"></a><!-- doxytag: member="Evas_Common.h::evas_device_class_set" ref="gadd1433c895b5d06cab9e6bbd97cae835" args="(Evas_Device *dev, Evas_Device_Class clas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#gadd1433c895b5d06cab9e6bbd97cae835">evas_device_class_set</a> </td>
          <td>(</td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Device_Class&#160;</td>
          <td class="paramname"><em>clas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the major class of device</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device whose class to set </td></tr>
    <tr><td class="paramname">clas</td><td>The class to set it to</td></tr>
  </table>
  </dd>
</dl>
<p>This sets the "primary" class of device (a broad thing like mouse, keyboard, touch, pen etc.).</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga73e1616a2b3cfd3c165a8dcca162eaaf"></a><!-- doxytag: member="Evas_Common.h::evas_device_del" ref="ga73e1616a2b3cfd3c165a8dcca162eaaf" args="(Evas_Device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#ga73e1616a2b3cfd3c165a8dcca162eaaf">evas_device_del</a> </td>
          <td>(</td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a new device type</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device node you want to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Event__Feeding__Group.html#gafa4fb5030c83d1b49d87f3016ecf5d8e">evas_device_add</a> </dd>
<dd>
<a class="el" href="group__Evas__Event__Feeding__Group.html#gae1c145ffcfeb301faa1d52d3b1086c42">evas_device_push</a> </dd>
<dd>
<a class="el" href="group__Evas__Event__Feeding__Group.html#ga18273057afa4a086a0f3e459e90323ad">evas_device_pop</a> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gaba810711417b80d8fb154fe0fb9cb37c"></a><!-- doxytag: member="Evas_Common.h::evas_device_description_get" ref="gaba810711417b80d8fb154fe0fb9cb37c" args="(const Evas_Device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="group__Evas__Event__Feeding__Group.html#gaba810711417b80d8fb154fe0fb9cb37c">evas_device_description_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the description of a device</p>
<p><code>dev</code> The device to query </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The device description string or NULL if none is set</dd></dl>
<p>This gets the description set by <a class="el" href="group__Evas__Event__Feeding__Group.html#ga9621012a50076697ce5d1c5c73584638">evas_device_description_set()</a>. This is a readable UTF8 C string, or NULL if no description is set.</p>
<p>A description is meant to be a longer string describing the device so a human may make sense of it. For example "Wireless 6 button mouse in Black
 with red buttons" would be a good description, so a user may identify precisely which device is being talked about.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9621012a50076697ce5d1c5c73584638"></a><!-- doxytag: member="Evas_Common.h::evas_device_description_set" ref="ga9621012a50076697ce5d1c5c73584638" args="(Evas_Device *dev, const char *desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#ga9621012a50076697ce5d1c5c73584638">evas_device_description_set</a> </td>
          <td>(</td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the description of a device as a string</p>
<p><code>dev</code> The device to set the description of <code>name</code> The description string as a readable C UTF8 string</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb021665824f6432b7af2019bffbb4b6"></a><!-- doxytag: member="Evas_Common.h::evas_device_emulation_source_get" ref="gaeb021665824f6432b7af2019bffbb4b6" args="(const Evas_Device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Evas_Device* <a class="el" href="group__Evas__Event__Feeding__Group.html#gaeb021665824f6432b7af2019bffbb4b6">evas_device_emulation_source_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the emulation source device</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The source emulation device set by <a class="el" href="group__Evas__Event__Feeding__Group.html#gab8a4f7145896328f8cc6b805954813c9">evas_device_emulation_source_set()</a>.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gab8a4f7145896328f8cc6b805954813c9"></a><!-- doxytag: member="Evas_Common.h::evas_device_emulation_source_set" ref="gab8a4f7145896328f8cc6b805954813c9" args="(Evas_Device *dev, Evas_Device *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#gab8a4f7145896328f8cc6b805954813c9">evas_device_emulation_source_set</a> </td>
          <td>(</td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the emulation source device</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device being emulated </td></tr>
    <tr><td class="paramname">src</td><td>The primary source device producing events in the emulated device</td></tr>
  </table>
  </dd>
</dl>
<p>Devices may not be real, but may be emulated by listening to input on other devices and modifying or interpeting it to generate output on an emulated device (example a fingeron a touchscreen will often emulate a mouse when it presses). This allows you to set which device primarily emulates <code>dev</code> so the user can choose to ignore events from emulated devices if they also pay attention to source device events for example.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gae75c9ad6a7df347d7a6c894e9b48dce8"></a><!-- doxytag: member="Evas_Common.h::evas_device_list" ref="gae75c9ad6a7df347d7a6c894e9b48dce8" args="(Evas *e, const Evas_Device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__Eina__List__Group.html#ga3295e1210efea1fb0fd6acbf3cbc1f29">Eina_List</a>* <a class="el" href="group__Evas__Event__Feeding__Group.html#gae75c9ad6a7df347d7a6c894e9b48dce8">evas_device_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List all current devices attached to the given canvas and/or device</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The canvas to query for a device list </td></tr>
    <tr><td class="paramname">dev</td><td>A specific device inside the canvas to query for child devices or NULL if just querying the base canvas devices </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An internal list of Evas_Device pointers, or NULL if no devices are found</dd></dl>
<p>This will list all devices belonging to a specific evas canvas <code>e</code>, at the top-level in the device tree if <code>dev</code> passed in is NULL. If <code>dev</code> is a valid device for the given canvas <code>e</code>, then a list of child devices of <code>dev</code> will be returned, allowing you to walk the device tree.</p>
<p>The list returned is only valid so long as no changes are made to the device tree in the given canvas <code>e</code>. If there are no devices or children then NULL is returned.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Event__Feeding__Group.html#ga19002f3e6d472772ea47df94942d8b83">evas_device_parent_get</a> </dd>
<dd>
<a class="el" href="group__Evas__Event__Feeding__Group.html#gaec5dc5b3582c7cd8959635f09eeafb4a">evas_device_name_get</a> </dd>
<dd>
<a class="el" href="group__Evas__Event__Feeding__Group.html#gaba810711417b80d8fb154fe0fb9cb37c">evas_device_description_get</a> </dd>
<dd>
<a class="el" href="group__Evas__Event__Feeding__Group.html#ga48345e08c83930c86dd972c0b4a152bf">evas_device_class_get</a> </dd>
<dd>
<a class="el" href="group__Evas__Event__Feeding__Group.html#gaac0eb10da59f01d8439ec43f9295cc9f">evas_device_subclass_get</a> </dd>
<dd>
<a class="el" href="group__Evas__Event__Feeding__Group.html#gaeb021665824f6432b7af2019bffbb4b6">evas_device_emulation_source_get</a> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gaec5dc5b3582c7cd8959635f09eeafb4a"></a><!-- doxytag: member="Evas_Common.h::evas_device_name_get" ref="gaec5dc5b3582c7cd8959635f09eeafb4a" args="(const Evas_Device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="group__Evas__Event__Feeding__Group.html#gaec5dc5b3582c7cd8959635f09eeafb4a">evas_device_name_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of a device</p>
<p><code>dev</code> The device to query </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The device name string or NULL if none is set</dd></dl>
<p>This gets the name set by <a class="el" href="group__Evas__Event__Feeding__Group.html#ga37f4666b0a0dad0b8e1dfb3b5bc016ee">evas_device_name_set()</a>. This is a readable UTF8 C string, or NULL if no name is set.</p>
<p>The name should be a short name like "Wireless Mouse", "Joystick", "Finger", "Keyboard" or "Numberpad" etc.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga37f4666b0a0dad0b8e1dfb3b5bc016ee"></a><!-- doxytag: member="Evas_Common.h::evas_device_name_set" ref="ga37f4666b0a0dad0b8e1dfb3b5bc016ee" args="(Evas_Device *dev, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#ga37f4666b0a0dad0b8e1dfb3b5bc016ee">evas_device_name_set</a> </td>
          <td>(</td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the name of a device as a string</p>
<p><code>dev</code> The device to set the name of <code>name</code> The name string as a readable C UTF8 string</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga19002f3e6d472772ea47df94942d8b83"></a><!-- doxytag: member="Evas_Common.h::evas_device_parent_get" ref="ga19002f3e6d472772ea47df94942d8b83" args="(const Evas_Device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Evas_Device* <a class="el" href="group__Evas__Event__Feeding__Group.html#ga19002f3e6d472772ea47df94942d8b83">evas_device_parent_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the parent of a device</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The parent device or NULL if it is a toplevel</dd></dl>
<p>This returns the parent device of any given device entry, or NULL if no parent device exists (is a toplevel device).</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga905bf02ef71debc15a296f541a74c7d0"></a><!-- doxytag: member="Evas_Common.h::evas_device_parent_set" ref="ga905bf02ef71debc15a296f541a74c7d0" args="(Evas_Device *dev, Evas_Device *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#ga905bf02ef71debc15a296f541a74c7d0">evas_device_parent_set</a> </td>
          <td>(</td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the parent of a device</p>
<p><code>dev</code> The device to set the parent of <code>parent</code> The new parent device</p>
<p>This sets the parent of a device <code>dev</code> to the parent given by <code>parent</code>. If the device already has a parent, it is removed from that parent's list. If <code>parent</code> is NULL then the device is unparented and placed back as a root device in the canvas.</p>
<p>When a device is deleted with <a class="el" href="group__Evas__Event__Feeding__Group.html#ga73e1616a2b3cfd3c165a8dcca162eaaf">evas_device_del()</a>, all children are also deleted along with it.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Event__Feeding__Group.html#ga73e1616a2b3cfd3c165a8dcca162eaaf">evas_device_del</a> </dd>
<dd>
<a class="el" href="group__Evas__Event__Feeding__Group.html#ga19002f3e6d472772ea47df94942d8b83">evas_device_parent_get</a> </dd>
<dd>
<a class="el" href="group__Evas__Event__Feeding__Group.html#gae75c9ad6a7df347d7a6c894e9b48dce8">evas_device_list</a></dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga18273057afa4a086a0f3e459e90323ad"></a><!-- doxytag: member="Evas_Common.h::evas_device_pop" ref="ga18273057afa4a086a0f3e459e90323ad" args="(Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#ga18273057afa4a086a0f3e459e90323ad">evas_device_pop</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This pops the top of the device stack for the canvas</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The canvas to pop the device stack from</td></tr>
  </table>
  </dd>
</dl>
<p>This pops the top of the device stack making the current device context used for device events being what is now at the top of the stack after popping.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Event__Feeding__Group.html#gae1c145ffcfeb301faa1d52d3b1086c42">evas_device_push</a> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gae1c145ffcfeb301faa1d52d3b1086c42"></a><!-- doxytag: member="Evas_Common.h::evas_device_push" ref="gae1c145ffcfeb301faa1d52d3b1086c42" args="(Evas *e, Evas_Device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#gae1c145ffcfeb301faa1d52d3b1086c42">evas_device_push</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push the current context device onto the device stack</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The canvas to push the device on to </td></tr>
    <tr><td class="paramname">dev</td><td>The device to push.</td></tr>
  </table>
  </dd>
</dl>
<p>This pushes the given device <code>dev</code> onto the stack for the canvas <code>e</code> resulting in the dev pointer in all events that get fed to the canvas being the device at the top of the device stack for that canvas.</p>
<p>If a device is pushed onto the device stack, it will not be deleted until a canvas free OR until it has been popped from the stack even if <a class="el" href="group__Evas__Event__Feeding__Group.html#ga73e1616a2b3cfd3c165a8dcca162eaaf">evas_device_del()</a> is called.</p>
<p>The device <code>dev</code> must have been created as a device for the canvas it is pushed onto (and not another canvas).</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__Evas__Event__Feeding__Group.html#gae1c145ffcfeb301faa1d52d3b1086c42">evas_device_push</a>(canvas, dev);
 <a class="code" href="group__Evas__Canvas.html#ga4b9de86613e9236282f25ab265a00eeb" title="Mouse move event feed.">evas_event_feed_mouse_move</a>(canvas, 20, 30, 0, NULL);
 <a class="code" href="group__Evas__Event__Feeding__Group.html#ga18273057afa4a086a0f3e459e90323ad">evas_device_pop</a>(canvas);
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Event__Feeding__Group.html#ga18273057afa4a086a0f3e459e90323ad">evas_device_pop</a> </dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gaac0eb10da59f01d8439ec43f9295cc9f"></a><!-- doxytag: member="Evas_Common.h::evas_device_subclass_get" ref="gaac0eb10da59f01d8439ec43f9295cc9f" args="(const Evas_Device *dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Evas_Device_Subclass <a class="el" href="group__Evas__Event__Feeding__Group.html#gaac0eb10da59f01d8439ec43f9295cc9f">evas_device_subclass_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the device sub-class</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The device sub-class set by <a class="el" href="group__Evas__Event__Feeding__Group.html#gac468ac5b5780d020f7ac453ab8717d63">evas_device_subclass_set()</a>.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gac468ac5b5780d020f7ac453ab8717d63"></a><!-- doxytag: member="Evas_Common.h::evas_device_subclass_set" ref="gac468ac5b5780d020f7ac453ab8717d63" args="(Evas_Device *dev, Evas_Device_Subclass clas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#gac468ac5b5780d020f7ac453ab8717d63">evas_device_subclass_set</a> </td>
          <td>(</td>
          <td class="paramtype">Evas_Device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Device_Subclass&#160;</td>
          <td class="paramname"><em>clas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the sub-class of a device</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>The device to modify </td></tr>
    <tr><td class="paramname">clas</td><td>The sub-class to set</td></tr>
  </table>
  </dd>
</dl>
<p>This sets the sub-class of a device which gives much more detailed usage within a broader category.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f6046343eab8b062e5509d984100ec8"></a><!-- doxytag: member="Evas_Legacy.h::evas_event_freeze" ref="ga4f6046343eab8b062e5509d984100ec8" args="(Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#ga4f6046343eab8b062e5509d984100ec8">evas_event_freeze</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Freeze all input events processing.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The canvas to freeze input events processing on.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will indicate to Evas that the canvas <code>e</code> is to have all input event processing frozen until a matching <a class="el" href="group__Evas__Event__Feeding__Group.html#ga376918c56c3dc588a059da7fe8629b70">evas_event_thaw()</a> function is called on the same canvas. All events of this kind during the freeze will get <b>discarded</b>. Every freeze call must be matched by a thaw call in order to completely thaw out a canvas (i.e. these calls may be nested). The most common use is when you don't want the user to interact with your user interface when you're populating a view or changing the layout.</p>
<p>Example:  <div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot;\tf - freeze input for 3 seconds\n&quot;</span>
  <span class="stringliteral">&quot;\tp - toggle precise point collision detection on image\n&quot;</span>
  <span class="stringliteral">&quot;\tControl + o - add an obscured rectangle\n&quot;</span>
  <span class="stringliteral">&quot;\th - print help\n&quot;</span>;

<span class="keyword">struct </span>test_data
{
   Ecore_Evas  *ee;
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a>        *canvas;
   <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *img, *bg;
   <a class="code" href="group__Ecore__Timer__Group.html#gaf96ffb609956658ec038e54bd39f46f0">Ecore_Timer</a> *resize_timer, *freeze_timer;
   <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>    obscured, focus;
};
</pre></div>  <div class="fragment"><pre class="fragment"><span class="comment">/* let&#39;s have our events back */</span>
<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_thaw_cb(<span class="keywordtype">void</span> *data EINA_UNUSED)
{
   fprintf(stdout, <span class="stringliteral">&quot;Canvas was frozen %d times, now thawing.\n&quot;</span>,
           <a class="code" href="group__Evas__Event__Feeding__Group.html#gaca66af7f9b72ddbd63104d59c1fdf894">evas_event_freeze_get</a>(d.canvas));
   <a class="code" href="group__Evas__Event__Feeding__Group.html#ga376918c56c3dc588a059da7fe8629b70">evas_event_thaw</a>(d.canvas);
   <span class="keywordflow">return</span> <a class="code" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a>; <span class="comment">/* do not re-issue the timer */</span>
}
</pre></div></p>
<p>See the full <a class="el" href="Example_Evas_Events.html">example</a>.</p>
<p>If you run that example, you'll see the canvas ignoring all input events for 3 seconds, when the "f" key is pressed. In a more realistic code we would be freezing while a toolkit or Edje was doing some UI changes, thawing it back afterwards.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-events_8c-example.html#a17">evas-events.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaca66af7f9b72ddbd63104d59c1fdf894"></a><!-- doxytag: member="Evas_Legacy.h::evas_event_freeze_get" ref="gaca66af7f9b72ddbd63104d59c1fdf894" args="(const Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Event__Feeding__Group.html#gaca66af7f9b72ddbd63104d59c1fdf894">evas_event_freeze_get</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the freeze count on input events of a given canvas.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The canvas to fetch the freeze count from.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns the number of times the canvas has been told to freeze input events. It is possible to call <a class="el" href="group__Evas__Event__Feeding__Group.html#ga4f6046343eab8b062e5509d984100ec8">evas_event_freeze()</a> multiple times, and these must be matched by <a class="el" href="group__Evas__Event__Feeding__Group.html#ga376918c56c3dc588a059da7fe8629b70">evas_event_thaw()</a> calls. This call allows the program to discover just how many times things have been frozen in case it may want to break out of a deep freeze state where the count is high.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *evas;

 <span class="keywordflow">while</span> (<a class="code" href="group__Evas__Event__Feeding__Group.html#gaca66af7f9b72ddbd63104d59c1fdf894">evas_event_freeze_get</a>(evas) &gt; 0) <a class="code" href="group__Evas__Event__Feeding__Group.html#ga376918c56c3dc588a059da7fe8629b70">evas_event_thaw</a>(evas);
</pre></div><dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-events_8c-example.html#a6">evas-events.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga376918c56c3dc588a059da7fe8629b70"></a><!-- doxytag: member="Evas_Legacy.h::evas_event_thaw" ref="ga376918c56c3dc588a059da7fe8629b70" args="(Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#ga376918c56c3dc588a059da7fe8629b70">evas_event_thaw</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Thaw a canvas out after freezing (for input events).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The canvas to thaw out.</td></tr>
  </table>
  </dd>
</dl>
<p>This will thaw out a canvas after a matching <a class="el" href="group__Evas__Event__Feeding__Group.html#ga4f6046343eab8b062e5509d984100ec8">evas_event_freeze()</a> call. If this call completely thaws out a canvas, i.e., there's no other unbalanced call to <a class="el" href="group__Evas__Event__Feeding__Group.html#ga4f6046343eab8b062e5509d984100ec8">evas_event_freeze()</a>, events will start to be processed again, but any "missed" events will <b>not</b> be evaluated.</p>
<p>See <a class="el" href="group__Evas__Event__Feeding__Group.html#ga4f6046343eab8b062e5509d984100ec8">evas_event_freeze()</a> for an example.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-events_8c-example.html#a7">evas-events.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga690446435c07686f2acc7b4a9ae40dbf"></a><!-- doxytag: member="Evas_Legacy.h::evas_event_thaw_eval" ref="ga690446435c07686f2acc7b4a9ae40dbf" args="(Evas *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Event__Feeding__Group.html#ga690446435c07686f2acc7b4a9ae40dbf">evas_event_thaw_eval</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After thaw of a canvas, re-evaluate the state of objects and call callbacks</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The canvas to evaluate after a thaw</td></tr>
  </table>
  </dd>
</dl>
<p>This is normally called after <a class="el" href="group__Evas__Event__Feeding__Group.html#ga376918c56c3dc588a059da7fe8629b70">evas_event_thaw()</a> to re-evaluate mouse containment and other states and thus also call callbacks for mouse in and out on new objects if the state change demands it.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
