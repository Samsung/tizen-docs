<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Smart Functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">4.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Evas__Smart__Group.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<div class="title">Smart Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__Evas.html">Evas</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>Functions that deal with #Evas_Smart structs, creating definition (classes) of objects that will have customized behavior for methods like <a class="el" href="group__Evas__Font__Group.html#ga02da8091bbac768b8e86c7b74b2a94f9">evas_object_move()</a>, <a class="el" href="group__Evas__Font__Group.html#ga21e8604c0e4a93e469bff4bd069e82b5">evas_object_resize()</a>, evas_object_clip_set() and others.</p>
<p>These objects will accept the generic methods defined in <a class="el" href="group__Evas__Object__Group.html">Generic Object Functions</a> and the extensions defined in <a class="el" href="group__Evas__Smart__Object__Group.html">Smart Object Functions</a>. There are a couple of existent smart objects in Evas itself (see <a class="el" href="group__Evas__Object__Box.html">Box Smart Object</a>, <a class="el" href="group__Evas__Object__Table.html">Table Smart Object.</a> and <a class="el" href="group__Evas__Smart__Object__Clipped.html">Clipped Smart Object</a>).</p>
<p>See also some <a class="el" href="Example_Evas_Smart_Objects.html">examples</a> of this group of functions. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#gae10922eb9cf7d0654f282ba87dfc3ece">evas_smart_free</a> (Evas_Smart *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Evas_Smart *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga52391e412ef2905ad25c348724f33e26">evas_smart_class_new</a> (const <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> *sc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#gac3424c1ddb24487269d56ab3413756d0">evas_smart_class_get</a> (const Evas_Smart *s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#gadeb340e24859a09577a0b7838fa11829">evas_smart_data_get</a> (const Evas_Smart *s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data pointer set on an #Evas_Smart struct.  <a href="#gadeb340e24859a09577a0b7838fa11829"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga21bfd8ca489ecc08a0c3c9f66764f06d">evas_smart_callbacks_descriptions_get</a> (const Evas_Smart *s, unsigned int *count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga96fda01ec73f9ce9302fc73c827b8751">evas_smart_callback_description_find</a> (const Evas_Smart *s, const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#gae095bab508ff7a68b435047f43bb1ad9">evas_smart_class_inherit_full</a> (<a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> *sc, const <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> *parent_sc, unsigned int parent_sc_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga5f197ec846dac0a3998b084b46ce3d34">evas_smart_usage_get</a> (const Evas_Smart *s)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__Evas__Smart__Class.html">_Evas_Smart_Class</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct__Evas__Smart__Interface.html">_Evas_Smart_Interface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#gaef9b6443e1fdb6ffd3acd39981e91fee">Evas_Smart_Interface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="struct__Evas__Smart__Cb__Description.html">_Evas_Smart_Cb_Description</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga223f5d420c1e22275cd6490cd77c85f0">EVAS_SMART_CLASS_INIT_NULL</a>&#160;&#160;&#160;{NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#gaaa610a135c79167162405b56cffe8562">EVAS_SMART_CLASS_INIT_VERSION</a>&#160;&#160;&#160;{NULL, <a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#gaff2bbd5bb79e51ad8d31f98106caff77">EVAS_SMART_CLASS_INIT_NAME_VERSION</a>(name)&#160;&#160;&#160;{name, <a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga653b7bf36c2c87bd38d8126e11a4671d">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT</a>(name, parent)&#160;&#160;&#160;{name, <a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, parent, NULL, NULL}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga5ebe1775142621cc3b75a3c57085ec83">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS</a>(name, parent, callbacks)&#160;&#160;&#160;{name, <a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, parent, callbacks, NULL}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga58dc94af6f064b39b2bf0155908fbe52">EVAS_SMART_SUBCLASS_NEW</a>(smart_name, prefix, api_type, parent_type, parent_func, cb_desc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#gaa2fb3871db63677c2c76cd082112e238">EVAS_SMART_SUBCLASS_IFACE_NEW</a>(smart_name,prefix,api_type,parent_type,parent_func,cb_desc,ifaces)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga4aa4b72aafa0391144fb0171aeff2ccd">EVAS_SMART_DATA_ALLOC</a>(o, priv_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Smart__Group.html#ga6888875280ccf11f026e09c890650c95">evas_smart_class_inherit</a>(sc, parent_sc)&#160;&#160;&#160;<a class="el" href="group__Evas__Smart__Group.html#gae095bab508ff7a68b435047f43bb1ad9">evas_smart_class_inherit_full</a>(sc, (<a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> *)parent_sc, sizeof(*parent_sc))</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga6888875280ccf11f026e09c890650c95"></a><!-- doxytag: member="Evas_Common.h::evas_smart_class_inherit" ref="ga6888875280ccf11f026e09c890650c95" args="(sc, parent_sc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#ga6888875280ccf11f026e09c890650c95">evas_smart_class_inherit</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parent_sc&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__Evas__Smart__Group.html#gae095bab508ff7a68b435047f43bb1ad9">evas_smart_class_inherit_full</a>(sc, (<a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> *)parent_sc, sizeof(*parent_sc))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Easy to use version of <a class="el" href="group__Evas__Smart__Group.html#gae095bab508ff7a68b435047f43bb1ad9">evas_smart_class_inherit_full()</a>.</p>
<p>This version will use sizeof(parent_sc), copying everything.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sc</td><td>child class, will have methods copied from <em>parent_sc</em> </td></tr>
    <tr><td class="paramname">parent_sc</td><td>parent class, will provide contents to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 on success, 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff2bbd5bb79e51ad8d31f98106caff77"></a><!-- doxytag: member="Evas_Common.h::EVAS_SMART_CLASS_INIT_NAME_VERSION" ref="gaff2bbd5bb79e51ad8d31f98106caff77" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#gaff2bbd5bb79e51ad8d31f98106caff77">EVAS_SMART_CLASS_INIT_NAME_VERSION</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;{name, <a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializer to zero a whole Evas_Smart_Class structure and set name and version.</p>
<p>Similar to EVAS_SMART_CLASS_INIT_NULL, but will set version field to latest EVAS_SMART_CLASS_VERSION and name to the specified value.</p>
<p>It will keep a reference to name field as a "const char *", that is, name must be available while the structure is used (hint: static or global!) and will not be modified.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Smart__Group.html#ga223f5d420c1e22275cd6490cd77c85f0">EVAS_SMART_CLASS_INIT_NULL</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#gaaa610a135c79167162405b56cffe8562">EVAS_SMART_CLASS_INIT_VERSION</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#ga653b7bf36c2c87bd38d8126e11a4671d">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#ga5ebe1775142621cc3b75a3c57085ec83">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga653b7bf36c2c87bd38d8126e11a4671d"></a><!-- doxytag: member="Evas_Common.h::EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT" ref="ga653b7bf36c2c87bd38d8126e11a4671d" args="(name, parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#ga653b7bf36c2c87bd38d8126e11a4671d">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parent&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;{name, <a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, parent, NULL, NULL}</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializer to zero a whole Evas_Smart_Class structure and set name, version and parent class.</p>
<p>Similar to EVAS_SMART_CLASS_INIT_NULL, but will set version field to latest EVAS_SMART_CLASS_VERSION, name to the specified value and parent class.</p>
<p>It will keep a reference to name field as a "const char *", that is, name must be available while the structure is used (hint: static or global!) and will not be modified. Similarly, parent reference will be kept.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Smart__Group.html#ga223f5d420c1e22275cd6490cd77c85f0">EVAS_SMART_CLASS_INIT_NULL</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#gaaa610a135c79167162405b56cffe8562">EVAS_SMART_CLASS_INIT_VERSION</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#gaff2bbd5bb79e51ad8d31f98106caff77">EVAS_SMART_CLASS_INIT_NAME_VERSION</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#ga5ebe1775142621cc3b75a3c57085ec83">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ebe1775142621cc3b75a3c57085ec83"></a><!-- doxytag: member="Evas_Common.h::EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS" ref="ga5ebe1775142621cc3b75a3c57085ec83" args="(name, parent, callbacks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#ga5ebe1775142621cc3b75a3c57085ec83">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parent, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">callbacks&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;{name, <a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, parent, callbacks, NULL}</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializer to zero a whole Evas_Smart_Class structure and set name, version, parent class and callbacks definition.</p>
<p>Similar to EVAS_SMART_CLASS_INIT_NULL, but will set version field to latest EVAS_SMART_CLASS_VERSION, name to the specified value, parent class and callbacks at this level.</p>
<p>It will keep a reference to name field as a "const char *", that is, name must be available while the structure is used (hint: static or global!) and will not be modified. Similarly, parent and callbacks reference will be kept.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Smart__Group.html#ga223f5d420c1e22275cd6490cd77c85f0">EVAS_SMART_CLASS_INIT_NULL</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#gaaa610a135c79167162405b56cffe8562">EVAS_SMART_CLASS_INIT_VERSION</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#gaff2bbd5bb79e51ad8d31f98106caff77">EVAS_SMART_CLASS_INIT_NAME_VERSION</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#ga653b7bf36c2c87bd38d8126e11a4671d">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga223f5d420c1e22275cd6490cd77c85f0"></a><!-- doxytag: member="Evas_Common.h::EVAS_SMART_CLASS_INIT_NULL" ref="ga223f5d420c1e22275cd6490cd77c85f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#ga223f5d420c1e22275cd6490cd77c85f0">EVAS_SMART_CLASS_INIT_NULL</a>&#160;&#160;&#160;{NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializer to zero a whole Evas_Smart_Class structure.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Smart__Group.html#gaaa610a135c79167162405b56cffe8562">EVAS_SMART_CLASS_INIT_VERSION</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#gaff2bbd5bb79e51ad8d31f98106caff77">EVAS_SMART_CLASS_INIT_NAME_VERSION</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#ga653b7bf36c2c87bd38d8126e11a4671d">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#ga5ebe1775142621cc3b75a3c57085ec83">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa610a135c79167162405b56cffe8562"></a><!-- doxytag: member="Evas_Common.h::EVAS_SMART_CLASS_INIT_VERSION" ref="gaaa610a135c79167162405b56cffe8562" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#gaaa610a135c79167162405b56cffe8562">EVAS_SMART_CLASS_INIT_VERSION</a>&#160;&#160;&#160;{NULL, <a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializer to zero a whole Evas_Smart_Class structure and set version.</p>
<p>Similar to EVAS_SMART_CLASS_INIT_NULL, but will set version field to latest EVAS_SMART_CLASS_VERSION.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Smart__Group.html#ga223f5d420c1e22275cd6490cd77c85f0">EVAS_SMART_CLASS_INIT_NULL</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#gaff2bbd5bb79e51ad8d31f98106caff77">EVAS_SMART_CLASS_INIT_NAME_VERSION</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#ga653b7bf36c2c87bd38d8126e11a4671d">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT</a> </dd>
<dd>
<a class="el" href="group__Evas__Smart__Group.html#ga5ebe1775142621cc3b75a3c57085ec83">EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ca1514302a47188c921b232d6ce42db"></a><!-- doxytag: member="Evas_Common.h::EVAS_SMART_CLASS_VERSION" ref="ga1ca1514302a47188c921b232d6ce42db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The version you have to put into the version field in the <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> struct. Used to safeguard from binaries with old smart object intefaces running with newer ones. </p>

</div>
</div>
<a class="anchor" id="ga4aa4b72aafa0391144fb0171aeff2ccd"></a><!-- doxytag: member="Evas_Common.h::EVAS_SMART_DATA_ALLOC" ref="ga4aa4b72aafa0391144fb0171aeff2ccd" args="(o, priv_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#ga4aa4b72aafa0391144fb0171aeff2ccd">EVAS_SMART_DATA_ALLOC</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">o, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">priv_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">priv_type * priv;                                      \
  priv = evas_object_smart_data_get(o);                  \
  if (!priv) {                                           \
       priv = (priv_type *)calloc(1, <span class="keyword">sizeof</span>(priv_type)); \
       if (!priv) return;                                \
       evas_object_smart_data_set(o, priv);              \
    }
</pre></div><p>Convenience macro to allocate smart data only if needed.</p>
<p>When writing a subclassable smart object, the <code></code>.add() function will need to check if the smart private data was already allocated by some child object or not. This macro makes it easier to do it.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is an idiom used when one calls the parent's <code></code>.add() after the specialized code. Naturally, the parent's base smart data has to be contemplated as the specialized one's first member, for things to work.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>Evas object passed to the <code></code>.add() function </td></tr>
    <tr><td class="paramname">priv_type</td><td>The type of the data to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a17">evas-smart-interface.c</a>, and <a class="el" href="evas-smart-object_8c-example.html#a14">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa2fb3871db63677c2c76cd082112e238"></a><!-- doxytag: member="Evas_Common.h::EVAS_SMART_SUBCLASS_IFACE_NEW" ref="gaa2fb3871db63677c2c76cd082112e238" args="(smart_name,prefix,api_type,parent_type,parent_func,cb_desc,ifaces)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#gaa2fb3871db63677c2c76cd082112e238">EVAS_SMART_SUBCLASS_IFACE_NEW</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">smart_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prefix, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">api_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parent_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parent_func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb_desc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ifaces&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> parent_type * prefix##_parent_sc = NULL;    \
  static <span class="keywordtype">void</span> prefix##_smart_set_user(api_type * api);     \
  static <span class="keywordtype">void</span> prefix##_smart_set(api_type * api)           \
  {                                                        \
     Evas_Smart_Class *sc;                                 \
     if (!(sc = (<a class="code" href="struct__Evas__Smart__Class.html">Evas_Smart_Class</a> *)api))                  \
       return;                                             \
     if (!prefix##_parent_sc)                              \
       prefix##_parent_sc = parent_func();                 \
     evas_smart_class_inherit(sc, prefix##_parent_sc);     \
     prefix##_smart_set_user(api);                         \
  }                                                        \
  static Evas_Smart *prefix##_smart_class_new(<span class="keywordtype">void</span>)        \
  {                                                        \
     static Evas_Smart *smart = NULL;                      \
     static api_type api;                                  \
     if (!smart)                                           \
       {                                                   \
          Evas_Smart_Class *sc = (<a class="code" href="struct__Evas__Smart__Class.html">Evas_Smart_Class</a> *)&amp;api; \
          memset(&amp;api, 0, <span class="keyword">sizeof</span>(api_type));               \
          sc-&gt;version = <a class="code" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>;          \
          sc-&gt;name = smart_name;                           \
          sc-&gt;callbacks = cb_desc;                         \
          sc-&gt;interfaces = ifaces;                         \
          prefix##_smart_set(&amp;api);                        \
          smart = <a class="code" href="group__Evas__Smart__Group.html#ga52391e412ef2905ad25c348724f33e26">evas_smart_class_new</a>(sc);                \
       }                                                   \
     return smart;                                         \
  }
</pre></div><dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7</dd></dl>
<p>Convenience macro to subclass a given Evas smart class. This is the same as <a class="el" href="group__Evas__Smart__Group.html#ga58dc94af6f064b39b2bf0155908fbe52">EVAS_SMART_SUBCLASS_NEW</a>, but now <b>declaring smart interfaces</b> besides the smart callbacks.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">smart_name</td><td>The name used for the smart class. e.g: <code>"Evas_Object_Box"</code>. </td></tr>
    <tr><td class="paramname">prefix</td><td>Prefix used for all variables and functions defined and referenced by this macro. </td></tr>
    <tr><td class="paramname">api_type</td><td>Type of the structure used as API for the smart class. Either <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> or something derived from it. </td></tr>
    <tr><td class="paramname">parent_type</td><td>Type of the parent class API. </td></tr>
    <tr><td class="paramname">parent_func</td><td>Function that gets the parent class. e.g: <a class="el" href="group__Evas__Object__Box.html#ga87222ff21012a79caf1e284dcecad350">evas_object_box_smart_class_get()</a>. </td></tr>
    <tr><td class="paramname">cb_desc</td><td>Array of smart callback descriptions for this smart class. </td></tr>
    <tr><td class="paramname">ifaces</td><td>Array of Evas smart interafaces for this smart class.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro saves some typing when writing a smart class derived from another one. In order to work, the user <b>must</b> provide some functions adhering to the following guidelines:</p>
<ul>
<li>&lt;prefix&gt;_smart_set_user(): the <b>internal</b> <code>_smart_set</code> function (defined by this macro) will call this one, provided by the user, after inheriting everything from the parent, which should <b>take care of setting the right member functions for the class</b>, both overrides and extensions, if any.</li>
<li>If this new class should be subclassable as well, a <b>public</b> <code>_smart_set()</code> function is desirable to fill in the class used as parent by the children. It's up to the user to provide this interface, which will most likely call &lt;prefix&gt;_smart_set() to get the job done.</li>
</ul>
<p>After the macro's usage, the following will be defined for use:</p>
<ul>
<li>&lt;prefix&gt;_parent_sc: A pointer to the <b>parent</b> smart class. When calling parent functions from overloaded ones, use this global variable.</li>
<li>&lt;prefix&gt;_smart_class_new(): this function returns the #Evas_Smart needed to create smart objects with this class, which should be passed to <a class="el" href="group__Evas__Smart__Object__Group.html#gad80de73a33446f902d4b39141a8d0a05">evas_object_smart_add()</a>.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd><code>smart_name</code> has to be a pointer to a globally available string! The smart class created here will just have a pointer set to that, and all object instances will depend on it for smart class name lookup. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-interface_8c-example.html#a5">evas-smart-interface.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga58dc94af6f064b39b2bf0155908fbe52"></a><!-- doxytag: member="Evas_Common.h::EVAS_SMART_SUBCLASS_NEW" ref="ga58dc94af6f064b39b2bf0155908fbe52" args="(smart_name, prefix, api_type, parent_type, parent_func, cb_desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Evas__Smart__Group.html#ga58dc94af6f064b39b2bf0155908fbe52">EVAS_SMART_SUBCLASS_NEW</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">smart_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prefix, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">api_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parent_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parent_func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cb_desc&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keyword">const</span> parent_type * prefix##_parent_sc = NULL;                                          \
  static <span class="keywordtype">void</span> prefix##_smart_set_user(api_type * api);                                           \
  static <span class="keywordtype">void</span> prefix##_smart_set(api_type * api)                                                 \
  {                                                                                              \
     Evas_Smart_Class *sc;                                                                       \
     if (!(sc = (<a class="code" href="struct__Evas__Smart__Class.html">Evas_Smart_Class</a> *)api))                                                        \
       return;                                                                                   \
     if (!prefix##_parent_sc)                                                                    \
       prefix##_parent_sc = parent_func();                                                       \
     evas_smart_class_inherit(sc, prefix##_parent_sc);                                           \
     prefix##_smart_set_user(api);                                                               \
  }                                                                                              \
  static Evas_Smart *prefix##_smart_class_new(<span class="keywordtype">void</span>)                                              \
  {                                                                                              \
     static Evas_Smart *smart = NULL;                                                            \
     static api_type api;                                                                        \
     if (!smart)                                                                                 \
       {                                                                                         \
          Evas_Smart_Class *sc = (<a class="code" href="struct__Evas__Smart__Class.html">Evas_Smart_Class</a> *)&amp;api;                                       \
          memset(&amp;api, 0, <span class="keyword">sizeof</span>(api_type));                                                     \
          sc-&gt;version = <a class="code" href="group__Evas__Smart__Group.html#ga1ca1514302a47188c921b232d6ce42db">EVAS_SMART_CLASS_VERSION</a>;                                                \
          sc-&gt;name = smart_name;                                                                 \
          sc-&gt;callbacks = cb_desc;                                                               \
          prefix##_smart_set(&amp;api);                                                              \
          smart = <a class="code" href="group__Evas__Smart__Group.html#ga52391e412ef2905ad25c348724f33e26">evas_smart_class_new</a>(sc);                                                      \
       }                                                                                         \
     return smart;                                                                               \
  }
</pre></div><p>Convenience macro to subclass a given Evas smart class.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">smart_name</td><td>The name used for the smart class. e.g: <code>"Evas_Object_Box"</code>. </td></tr>
    <tr><td class="paramname">prefix</td><td>Prefix used for all variables and functions defined and referenced by this macro. </td></tr>
    <tr><td class="paramname">api_type</td><td>Type of the structure used as API for the smart class. Either <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> or something derived from it. </td></tr>
    <tr><td class="paramname">parent_type</td><td>Type of the parent class API. </td></tr>
    <tr><td class="paramname">parent_func</td><td>Function that gets the parent class. e.g: <a class="el" href="group__Evas__Object__Box.html#ga87222ff21012a79caf1e284dcecad350">evas_object_box_smart_class_get()</a>. </td></tr>
    <tr><td class="paramname">cb_desc</td><td>Array of callback descriptions for this smart class.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro saves some typing when writing a smart class derived from another one. In order to work, the user <b>must</b> provide some functions adhering to the following guidelines:</p>
<ul>
<li>&lt;prefix&gt;_smart_set_user(): the <b>internal</b> <code>_smart_set</code> function (defined by this macro) will call this one, provided by the user, after inheriting everything from the parent, which should <b>take care of setting the right member functions for the class</b>, both overrides and extensions, if any.</li>
<li>If this new class should be subclassable as well, a <b>public</b> <code>_smart_set()</code> function is desirable to fill in the class used as parent by the children. It's up to the user to provide this interface, which will most likely call &lt;prefix&gt;_smart_set() to get the job done.</li>
</ul>
<p>After the macro's usage, the following will be defined for use:</p>
<ul>
<li>&lt;prefix&gt;_parent_sc: A pointer to the <b>parent</b> smart class. When calling parent functions from overloaded ones, use this global variable.</li>
<li>&lt;prefix&gt;_smart_class_new(): this function returns the #Evas_Smart needed to create smart objects with this class, which should be passed to <a class="el" href="group__Evas__Smart__Object__Group.html#gad80de73a33446f902d4b39141a8d0a05">evas_object_smart_add()</a>.</li>
</ul>
<dl class="warning"><dt><b>Warning:</b></dt><dd><code>smart_name</code> has to be a pointer to a globally available string! The smart class created here will just have a pointer set to that, and all object instances will depend on it for smart class name lookup. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-smart-object_8c-example.html#a1">evas-smart-object.c</a>.</dd>
</dl>
</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga0ad0e7d482d7660e756e275d355e3634"></a><!-- doxytag: member="Evas_Common.h::Evas_Smart_Cb_Description" ref="ga0ad0e7d482d7660e756e275d355e3634" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A smart object callback description, used to provide introspection </p>

</div>
</div>
<a class="anchor" id="gaea15f67e901bf5380cdb67dc1bb43391"></a><!-- doxytag: member="Evas_Common.h::Evas_Smart_Class" ref="gaea15f67e901bf5380cdb67dc1bb43391" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A smart object's <b>base</b> class definition </p>

</div>
</div>
<a class="anchor" id="gaef9b6443e1fdb6ffd3acd39981e91fee"></a><!-- doxytag: member="Evas_Common.h::Evas_Smart_Interface" ref="gaef9b6443e1fdb6ffd3acd39981e91fee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Evas__Smart__Group.html#gaef9b6443e1fdb6ffd3acd39981e91fee">Evas_Smart_Interface</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A smart object's <b>base</b> interface definition</p>
<p>An Evas interface is exactly like the OO-concept: an 'contract' or API a given object is declared to support. A smart object may have more than one interface, thus extending the behavior it gets from sub-classing.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7 </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga96fda01ec73f9ce9302fc73c827b8751"></a><!-- doxytag: member="Evas_Common.h::evas_smart_callback_description_find" ref="ga96fda01ec73f9ce9302fc73c827b8751" args="(const Evas_Smart *s, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a>* <a class="el" href="group__Evas__Smart__Group.html#ga96fda01ec73f9ce9302fc73c827b8751">evas_smart_callback_description_find</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Smart *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a callback description for the callback named <em>name</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The #Evas_Smart where to search for class registered smart event callbacks. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the desired callback, which must <b>not</b> be <code>NULL</code>. The search has a special case for <em>name</em> being the same pointer as registered with <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a>. One can use it to avoid excessive use of strcmp(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the description if found, or <code>NULL</code>, otherwise</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Smart__Group.html#ga21bfd8ca489ecc08a0c3c9f66764f06d">evas_smart_callbacks_descriptions_get()</a></dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga21bfd8ca489ecc08a0c3c9f66764f06d"></a><!-- doxytag: member="Evas_Common.h::evas_smart_callbacks_descriptions_get" ref="ga21bfd8ca489ecc08a0c3c9f66764f06d" args="(const Evas_Smart *s, unsigned int *count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__Evas__Smart__Group.html#ga0ad0e7d482d7660e756e275d355e3634">Evas_Smart_Cb_Description</a>** <a class="el" href="group__Evas__Smart__Group.html#ga21bfd8ca489ecc08a0c3c9f66764f06d">evas_smart_callbacks_descriptions_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Smart *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the smart callbacks known by this #Evas_Smart handle's smart class hierarchy.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">s</td><td>A valid #Evas_Smart handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>Returns the number of elements in the returned array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The array with callback descriptions known by this smart class, with its size returned in <em>count</em> parameter. It should not be modified in any way. If no callbacks are known, <code>NULL</code> is returned. The array is sorted by event names and elements refer to the original values given to <a class="el" href="group__Evas__Smart__Group.html#ga52391e412ef2905ad25c348724f33e26">evas_smart_class_new()</a>'s <a class="el" href="struct__Evas__Smart__Class.html#af7074494030024c3d0e502bca7b19067">Evas_Smart_Class::callbacks</a> (pointer to them).</dd></dl>
<p>This is likely different from evas_object_smart_callbacks_descriptions_get() as it will contain the callbacks of <b>all</b> this class hierarchy sorted, while the direct smart class member refers only to that specific class and should not include parent's.</p>
<p>If no callbacks are known, this function returns <code>NULL</code>.</p>
<p>The array elements and thus their contents will be <b>references</b> to original values given to <a class="el" href="group__Evas__Smart__Group.html#ga52391e412ef2905ad25c348724f33e26">evas_smart_class_new()</a> as <a class="el" href="struct__Evas__Smart__Class.html#af7074494030024c3d0e502bca7b19067">Evas_Smart_Class::callbacks</a>.</p>
<p>The array is sorted by <a class="el" href="struct__Evas__Smart__Cb__Description.html#ab377859f4cfcf1c2dd3c149a76b70b53">Evas_Smart_Cb_Description::name</a>. The last array element is a <code>NULL</code> pointer and is not accounted for in <em>count</em>. Loop iterations can check any of these size indicators.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>objects may provide per-instance callbacks, use evas_object_smart_callbacks_descriptions_get() to get those as well. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>evas_object_smart_callbacks_descriptions_get()</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gac3424c1ddb24487269d56ab3413756d0"></a><!-- doxytag: member="Evas_Common.h::evas_smart_class_get" ref="gac3424c1ddb24487269d56ab3413756d0" args="(const Evas_Smart *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a>* <a class="el" href="group__Evas__Smart__Group.html#gac3424c1ddb24487269d56ab3413756d0">evas_smart_class_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Smart *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> handle of an #Evas_Smart struct</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a valid #Evas_Smart pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> in it</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gae095bab508ff7a68b435047f43bb1ad9"></a><!-- doxytag: member="Evas_Common.h::evas_smart_class_inherit_full" ref="gae095bab508ff7a68b435047f43bb1ad9" args="(Evas_Smart_Class *sc, const Evas_Smart_Class *parent_sc, unsigned int parent_sc_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Smart__Group.html#gae095bab508ff7a68b435047f43bb1ad9">evas_smart_class_inherit_full</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> *&#160;</td>
          <td class="paramname"><em>sc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> *&#160;</td>
          <td class="paramname"><em>parent_sc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parent_sc_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets one class to inherit from the other.</p>
<p>Copy all function pointers, set <code>parent</code> to <em>parent_sc</em> and copy everything after sizeof(Evas_Smart_Class) present in <em>parent_sc</em>, using <em>parent_sc_size</em> as reference.</p>
<p>This is recommended instead of a single memcpy() since it will take care to not modify <em>sc</em> name, version, callbacks and possible other members.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sc</td><td>child class. </td></tr>
    <tr><td class="paramname">parent_sc</td><td>parent class, will provide attributes. </td></tr>
    <tr><td class="paramname">parent_sc_size</td><td>size of parent_sc structure, child should be at least this size. Everything after <code>Evas_Smart_Class</code> size is copied using regular memcpy().</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga52391e412ef2905ad25c348724f33e26"></a><!-- doxytag: member="Evas_Common.h::evas_smart_class_new" ref="ga52391e412ef2905ad25c348724f33e26" args="(const Evas_Smart_Class *sc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Evas_Smart* <a class="el" href="group__Evas__Smart__Group.html#ga52391e412ef2905ad25c348724f33e26">evas_smart_class_new</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> *&#160;</td>
          <td class="paramname"><em>sc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new #Evas_Smart from a given <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> struct</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sc</td><td>the smart class definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new #Evas_Smart pointer</dd></dl>
<p>#Evas_Smart handles are necessary to create new <b>instances</b> of smart objects belonging to the class described by <code>sc</code>. That handle will contain, besides the smart class interface definition, all its smart callbacks infrastructure set, too.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you are willing to subclass a given smart class to construct yours, consider using the <a class="el" href="group__Evas__Smart__Group.html#ga58dc94af6f064b39b2bf0155908fbe52">EVAS_SMART_SUBCLASS_NEW</a> macro, which will make use of this function automatically for you.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gadeb340e24859a09577a0b7838fa11829"></a><!-- doxytag: member="Evas_Common.h::evas_smart_data_get" ref="gadeb340e24859a09577a0b7838fa11829" args="(const Evas_Smart *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Evas__Smart__Group.html#gadeb340e24859a09577a0b7838fa11829">evas_smart_data_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Smart *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the data pointer set on an #Evas_Smart struct. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a valid #Evas_Smart handle</td></tr>
  </table>
  </dd>
</dl>
<p>This data pointer is set as the data field in the <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> passed in to <a class="el" href="group__Evas__Smart__Group.html#ga52391e412ef2905ad25c348724f33e26">evas_smart_class_new()</a>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gae10922eb9cf7d0654f282ba87dfc3ece"></a><!-- doxytag: member="Evas_Common.h::evas_smart_free" ref="gae10922eb9cf7d0654f282ba87dfc3ece" args="(Evas_Smart *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Evas__Smart__Group.html#gae10922eb9cf7d0654f282ba87dfc3ece">evas_smart_free</a> </td>
          <td>(</td>
          <td class="paramtype">Evas_Smart *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free an #Evas_Smart struct</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the #Evas_Smart struct to free</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If this smart handle was created using <a class="el" href="group__Evas__Smart__Group.html#ga52391e412ef2905ad25c348724f33e26">evas_smart_class_new()</a>, the associated <a class="el" href="group__Evas__Smart__Group.html#gaea15f67e901bf5380cdb67dc1bb43391">Evas_Smart_Class</a> will not be freed.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If you're using the <a class="el" href="group__Evas__Smart__Group.html#ga58dc94af6f064b39b2bf0155908fbe52">EVAS_SMART_SUBCLASS_NEW</a> schema to create your smart object, note that an #Evas_Smart handle will be shared amongst all instances of the given smart class, through a static variable. Evas will internally count references on #Evas_Smart handles and free them when they are not referenced anymore. Thus, this function is of no use for Evas users, most probably.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f197ec846dac0a3998b084b46ce3d34"></a><!-- doxytag: member="Evas_Common.h::evas_smart_usage_get" ref="ga5f197ec846dac0a3998b084b46ce3d34" args="(const Evas_Smart *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Smart__Group.html#ga5f197ec846dac0a3998b084b46ce3d34">evas_smart_usage_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Evas_Smart *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of users of the smart instance</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The Evas_Smart to get the usage count of </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of uses of the smart instance</dd></dl>
<p>This function tells you how many more uses of the smart instance are in existence. This should be used before freeing/clearing any of the Evas_Smart_Class that was used to create the smart instance. The smart instance will refer to data in the Evas_Smart_Class used to create it and thus you cannot remove the original data until all users of it are gone. When the usage count goes to 0, you can <a class="el" href="group__Evas__Smart__Group.html#gae10922eb9cf7d0654f282ba87dfc3ece">evas_smart_free()</a> the smart instance <code>s</code> and remove from memory any of the Evas_Smart_Class that was used to create the smart instance, if you desire. Removing it from memory without doing this will cause problems (crashes, undefined behavior etc. etc.), so either never remove the original Evas_Smart_Class data from memory (have it be a constant structure and data), or use this API call and be very careful.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
