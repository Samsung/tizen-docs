<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Top Level Functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">5.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Evas__Main__Group.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Top Level Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__Evas.html">Evas</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>Functions that affect Evas as a whole. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#gad5b2116495471db12a34bab9a34edfaa">EINA_DEPRECATED</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8">evas_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly initialize Evas and its required dependencies.  <a href="#ga5dc5f05144dd72e8d58a043344e373b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09">evas_shutdown</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly shutdown Evas.  <a href="#ga95a8864f81d944a92bb012b77ffd1b09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Evas_Alloc_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#gacfae4f589c777003f58d51e502c52835">evas_alloc_error</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error status of the most recent memory allocation call.  <a href="#gacfae4f589c777003f58d51e502c52835"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#ga301c7d776c3d00085659fcf00c52b22d">evas_async_events_fd_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the canvas' asynchronous event queue.  <a href="#ga301c7d776c3d00085659fcf00c52b22d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#ga80fa27be7ba9fe5180ebbd1ec551e4a3">evas_async_events_process</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the asynchronous event queue.  <a href="#ga80fa27be7ba9fe5180ebbd1ec551e4a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#gab4dda3c2ef0c587a849935bafea9f66a">evas_async_events_put</a> (const void *target, Evas_Callback_Type type, void *event_info, Evas_Async_Events_Put_Cb func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert asynchronous events on the canvas.  <a href="#gab4dda3c2ef0c587a849935bafea9f66a"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gacfae4f589c777003f58d51e502c52835"></a><!-- doxytag: member="Evas_Common.h::evas_alloc_error" ref="gacfae4f589c777003f58d51e502c52835" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Evas_Alloc_Error <a class="el" href="group__Evas__Main__Group.html#gacfae4f589c777003f58d51e502c52835">evas_alloc_error</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the error status of the most recent memory allocation call. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Allocation error codes EVAS_ALLOC_ERROR_NONE, EVAS_ALLOC_ERROR_FATAL or EVAS_ALLOC_ERROR_RECOVERED.</dd></dl>
<p>Accesses the current error status for memory allocation, or EVAS_ALLOC_ERROR_NONE if allocation succeeded with no errors.</p>
<p>EVAS_ALLOC_ERROR_FATAL means that no memory allocation was possible, but the function call exited as cleanly as possible. This is a sign of very low memory, and indicates the caller should attempt a safe recovery and possibly re-try after freeing up additional memory.</p>
<p>EVAS_ALLOC_ERROR_RECOVERED indicates that Evas was able to free up sufficient memory internally to perform the requested memory allocation and the program will continue to function normally, but memory is in a low state and the program should strive to free memory itself. Evas' approach to free memory internally may reduce the resolution of images, free cached fonts or images, throw out pre-rendered data, or reduce the complexity of change lists.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *object;
 <span class="keywordtype">void</span> callback (<span class="keywordtype">void</span> *data, <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *obj, <span class="keywordtype">void</span> *event_info);

 <a class="code" href="group__Evas__Object__Group__Events.html#ga23be30ac5cdfb780f1ff82e9108ec26b">evas_object_event_callback_add</a>(<span class="keywordtype">object</span>, EVAS_CALLBACK_MOUSE_DOWN, callback, NULL);
 <span class="keywordflow">if</span> (<a class="code" href="group__Evas__Main__Group.html#gacfae4f589c777003f58d51e502c52835" title="Get the error status of the most recent memory allocation call.">evas_alloc_error</a>() == EVAS_ALLOC_ERROR_FATAL)
   {
     fprintf(stderr, <span class="stringliteral">&quot;ERROR: Failed to attach callback.  Out of memory.\n&quot;</span>);
     fprintf(stderr, <span class="stringliteral">&quot;       Must destroy object now as it cannot be used.\n&quot;</span>);
     <a class="code" href="group__Evas__Object__Group__Basic.html#ga7e7a625dab7a3890532aa13b43117076">evas_object_del</a>(<span class="keywordtype">object</span>);
     <span class="keywordtype">object</span> = NULL;
     fprintf(stderr, <span class="stringliteral">&quot;WARNING: Cleaning out RAM.\n&quot;</span>);
     my_memory_cleanup();
   }
 <span class="keywordflow">if</span> (<a class="code" href="group__Evas__Main__Group.html#gacfae4f589c777003f58d51e502c52835" title="Get the error status of the most recent memory allocation call.">evas_alloc_error</a>() == EVAS_ALLOC_ERROR_RECOVERED)
   {
     fprintf(stderr, <span class="stringliteral">&quot;WARNING: Memory is really low. Cleaning out RAM.\n&quot;</span>);
     my_memory_cleanup();
   }
</pre></div> <dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-events_8c-example.html#a32">evas-events.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga301c7d776c3d00085659fcf00c52b22d"></a><!-- doxytag: member="Evas_Common.h::evas_async_events_fd_get" ref="ga301c7d776c3d00085659fcf00c52b22d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Main__Group.html#ga301c7d776c3d00085659fcf00c52b22d">evas_async_events_fd_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the canvas' asynchronous event queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A file descriptor to the asynchronous events.</dd></dl>
<p>Normally, Evas handles asynchronous events internally, particularly in Evas-using modules that are part of the EFL infrastructure. Notably, ecore-evas takes care of processing these events for canvases instantiated through it.</p>
<p>However, when asynchronous calculations need to be done outside the main thread (in some other mainloop) with some followup action, this function permits accessing the events. An example would be asynchronous image preloading. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga80fa27be7ba9fe5180ebbd1ec551e4a3"></a><!-- doxytag: member="Evas_Common.h::evas_async_events_process" ref="ga80fa27be7ba9fe5180ebbd1ec551e4a3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Main__Group.html#ga80fa27be7ba9fe5180ebbd1ec551e4a3">evas_async_events_process</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process the asynchronous event queue. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of events processed.</dd></dl>
<p>Triggers the callback functions for asynchronous events that were queued up by <a class="el" href="group__Evas__Main__Group.html#gab4dda3c2ef0c587a849935bafea9f66a" title="Insert asynchronous events on the canvas.">evas_async_events_put()</a>. The callbacks are called in the same order that they were queued. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="gab4dda3c2ef0c587a849935bafea9f66a"></a><!-- doxytag: member="Evas_Common.h::evas_async_events_put" ref="gab4dda3c2ef0c587a849935bafea9f66a" args="(const void *target, Evas_Callback_Type type, void *event_info, Evas_Async_Events_Put_Cb func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Main__Group.html#gab4dda3c2ef0c587a849935bafea9f66a">evas_async_events_put</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Callback_Type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>event_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Async_Events_Put_Cb&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert asynchronous events on the canvas. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be affected by the events. </td></tr>
    <tr><td class="paramname">type</td><td>The type of callback function. </td></tr>
    <tr><td class="paramname">event_info</td><td>Information about the event. </td></tr>
    <tr><td class="paramname">func</td><td>The callback function pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EINA_FALSE if an error occurred, EINA_TRUE otherwise.</dd></dl>
<p>Allows routines running outside Evas' main thread to report an asynchronous event. The target, type, and event info will be passed to the callback function when <a class="el" href="group__Evas__Main__Group.html#ga80fa27be7ba9fe5180ebbd1ec551e4a3" title="Process the asynchronous event queue.">evas_async_events_process()</a> is called. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dc5f05144dd72e8d58a043344e373b8"></a><!-- doxytag: member="Evas_Common.h::evas_init" ref="ga5dc5f05144dd72e8d58a043344e373b8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#gad5b2116495471db12a34bab9a34edfaa">EINA_DEPRECATED</a> int <a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8">evas_init</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Directly initialize Evas and its required dependencies. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000335">Deprecated:</a></b></dt><dd>This function now returns NULL as cserve2 support has been removed</dd></dl>
<p>Get the path for the cserve binary to execute</p>
<p>There is little need for anyone except a desktop environment to call this. This can be called before <a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init()</a> has been called. It will try and find the full path to the to the cserve binary to run to provide cserve image and font caching services for evas.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL if error, or a string with the full path to the cserve binary.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.8 </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of times <a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init()</a> has been called.</dd></dl>
<p>Permits use of Evas independently from <a class="el" href="group__Ecore.html">Ecore</a>. This can be useful in certain types of examples and test programs, as well as by Ecore-Evas' <code><a class="el" href="group__Ecore__Evas__Group.html#gad36db3002bbf891d28af0d6b22dda1b5" title="Inits the Ecore_Evas system.">ecore_evas_init()</a></code> itself (which is what most EFL applications will be using instead).</p>
<p>The <a class="el" href="Example_Evas_Buffer_Simple.html">evas-buffer-simple.c</a> example demonstrates use of <a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init()</a>, and then manually setting up the canvas:</p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *bg, *r1, *r2, *r3;

   <a class="code" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init</a>();

   <span class="comment">/* After turning Evas on, we create an Evas canvas to work in.</span>
<span class="comment">    * Canvases are graphical workspaces used for placing and organizing</span>
<span class="comment">    * graphical objects.  Normally we&#39;d be using Ecore-Evas to create</span>
<span class="comment">    * the canvas, but for this example we&#39;ll hide the details in a</span>
<span class="comment">    * separate routine for convenience.</span>
<span class="comment">    */</span>
   canvas = create_canvas(WIDTH, HEIGHT);
   <span class="keywordflow">if</span> (!canvas)
     <span class="keywordflow">return</span> -1;
</pre></div></p>
<p>The canvas is set up using the example's create_canvas() routine, which forces selection of Evas' "buffer" rendering engine. The buffer engine simply renders to a memory buffer with no hardware acceleration.</p>
<p><div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *create_canvas(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   Evas_Engine_Info_Buffer *einfo;
   <span class="keywordtype">int</span> method;
   <span class="keywordtype">void</span> *pixels;

   <span class="comment">/* Request a handle for the &#39;buffer&#39; type of rendering engine. */</span>
   method = <a class="code" href="group__Evas__Output__Method.html#ga9f9871fdcc40ce1062d6565308020eb8">evas_render_method_lookup</a>(<span class="stringliteral">&quot;buffer&quot;</span>);
   <span class="keywordflow">if</span> (method &lt;= 0)
     {
    fputs(<span class="stringliteral">&quot;ERROR: evas was not compiled with &#39;buffer&#39; engine!\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Create a general canvas object.</span>
<span class="comment">    * Note that we are responsible for freeing the canvas when we&#39;re done. */</span>
   canvas = <a class="code" href="group__Evas__Canvas.html#ga67e8eb17d2a676bfdfb8794fc5f72bc0">evas_new</a>();
   <span class="keywordflow">if</span> (!canvas)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not instantiate new evas canvas.\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Specify that the canvas will be rendering using the buffer engine method.</span>
<span class="comment">    * We also size the canvas and viewport to the same width and height, with</span>
<span class="comment">    * the viewport set to the origin of the canvas.</span>
<span class="comment">    */</span>
   <a class="code" href="group__Evas__Canvas.html#ga15b85dc673baa6aa40f91f8bfcd3cbaa" title="Sets the output engine for the given evas.">evas_output_method_set</a>(canvas, method);
   <a class="code" href="group__Evas__Canvas.html#gaf6478cb249ed09fa0fe961085773fe1e" title="Sets the output size of the render engine of the given evas.">evas_output_size_set</a>(canvas, width, height);
   <a class="code" href="group__Evas__Canvas.html#ga6dcd13997f7825f03807dc0ec38dd38e" title="Sets the output viewport of the given evas in evas units.">evas_output_viewport_set</a>(canvas, 0, 0, width, height);
</pre></div></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09" title="Directly shutdown Evas.">evas_shutdown()</a>. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="eina_tiler_01_8c-example.html#a18">eina_tiler_01.c</a>, <a class="el" href="evas-buffer-simple_8c-example.html#a0">evas-buffer-simple.c</a>, and <a class="el" href="evas-init-shutdown_8c-example.html#a1">evas-init-shutdown.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga95a8864f81d944a92bb012b77ffd1b09"></a><!-- doxytag: member="Evas_Common.h::evas_shutdown" ref="ga95a8864f81d944a92bb012b77ffd1b09" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09">evas_shutdown</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Directly shutdown Evas. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The (decremented) init reference counter.</dd></dl>
<p>Low level routine to finalize Evas. Decrements a counter of the number of times <a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init()</a> has been called, and, if appropriate, shuts down associated dependency modules and libraries. A return value of 0 indicates that everything has been properly shut down.</p>
<p>Ecore-Evas applications will typically use <a class="el" href="group__Ecore__Evas__Group.html#gab1a47c09b475148c037c0a3d68644fa4" title="Shuts down the Ecore_Evas system.">ecore_evas_shutdown()</a> instead, as described in <a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init()</a>.</p>
<p>The <a class="el" href="Example_Evas_Buffer_Simple.html">evas-buffer-simple.c</a> example shows use of <a class="el" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09" title="Directly shutdown Evas.">evas_shutdown()</a> in its destroy_canvas() routine:</p>
 <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> destroy_canvas(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas);
<span class="keyword">static</span> <span class="keywordtype">void</span> draw_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas);
<span class="keyword">static</span> <span class="keywordtype">void</span> save_scene(<a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas, <span class="keyword">const</span> <span class="keywordtype">char</span> *dest);

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *bg, *r1, *r2, *r3;

   <a class="code" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init</a>();

   <span class="comment">/* After turning Evas on, we create an Evas canvas to work in.</span>
<span class="comment">    * Canvases are graphical workspaces used for placing and organizing</span>
<span class="comment">    * graphical objects.  Normally we&#39;d be using Ecore-Evas to create</span>
<span class="comment">    * the canvas, but for this example we&#39;ll hide the details in a</span>
<span class="comment">    * separate routine for convenience.</span>
<span class="comment">    */</span>
   canvas = create_canvas(WIDTH, HEIGHT);
   <span class="keywordflow">if</span> (!canvas)
     <span class="keywordflow">return</span> -1;

   <span class="comment">/* Next set the background to solid white.  This is typically done by</span>
<span class="comment">    * creating a rectangle sized to the canvas, placed at the canvas</span>
<span class="comment">    * origin.</span>
<span class="comment">    *</span>
<span class="comment">    * Note that if the canvas were to change size, our background</span>
<span class="comment">    * rectangle will not automatically resize itself; we&#39;d need to do</span>
<span class="comment">    * that manually with another evas_object_resize() call.  In a real</span>
<span class="comment">    * application using Ecore-Evas, functionality in Ecore will take</span>
<span class="comment">    * care of resizing things.  For this example, we&#39;ll just keep the</span>
<span class="comment">    * canvas dimensions fixed to avoid the problem.</span>
<span class="comment">    */</span>
   bg = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(bg, 255, 255, 255, 255); <span class="comment">// white bg, no transparency</span>
   evas_object_move(bg, 0, 0);                    <span class="comment">// at origin</span>
   evas_object_resize(bg, WIDTH, HEIGHT);         <span class="comment">// covers full canvas</span>
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(bg);

   puts(<span class="stringliteral">&quot;initial scene, with just background:&quot;</span>);
   draw_scene(canvas);

   <span class="comment">/* To make the scene interesting let&#39;s add a few more rectangles of</span>
<span class="comment">    * various sizes and colors, starting with a big red one.</span>
<span class="comment">    *</span>
<span class="comment">    * By default all Evas objects are created in a &#39;hidden&#39; state,</span>
<span class="comment">    * meaning they are not visible, won&#39;t be checked for changes during</span>
<span class="comment">    * canvas rendering, and won&#39;t receive input events.  Thus, like we</span>
<span class="comment">    * did for the background object we must call evas_object_show() to</span>
<span class="comment">    * make our graphics objects usable.</span>
<span class="comment">    */</span>
   r1 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r1, 255, 0, 0, 255); <span class="comment">// 100% opaque red</span>
   evas_object_move(r1, 10, 10);
   evas_object_resize(r1, 100, 100);
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r1);

   <span class="comment">/* Let&#39;s add a partly transparent rectangle on top of the red one.</span>
<span class="comment">    *</span>
<span class="comment">    * Graphics objects are treated as a stack in the canvas for drawing</span>
<span class="comment">    * purposes, so subsequent objects are drawn above the ones we&#39;ve</span>
<span class="comment">    * already added to the canvas.  This is important in objects that</span>
<span class="comment">    * have partially transparent fill coloring since we&#39;ll see part of</span>
<span class="comment">    * what&#39;s &quot;behind&quot; our object.</span>
<span class="comment">    *</span>
<span class="comment">    * In Evas, color values are pre-multiplied by their alpha.  This means</span>
<span class="comment">    * that if we want a green rectangle that&#39;s half transparent, we&#39;d have:</span>
<span class="comment">    *</span>
<span class="comment">    * non-premul: r=0, g=255, b=0    a=128 (50% alpha)</span>
<span class="comment">    * premul:</span>
<span class="comment">    *         r_premul = r * a / 255 =      0 * 128 / 255 =      0</span>
<span class="comment">    *         g_premul = g * a / 255 =    255 * 128 / 255 =    128</span>
<span class="comment">    *         b_premul = b * a / 255 =      0 * 128 / 255 =      0</span>
<span class="comment">    *</span>
<span class="comment">    * Since we&#39;re placing our half transparent green rectangle on top of</span>
<span class="comment">    * a red one, in the final output we will actually see a yellow square</span>
<span class="comment">    * (since in RGBA color green + red = yellow).</span>
<span class="comment">    */</span>
   r2 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r2, 0, 128, 0, 128); <span class="comment">// 50% opaque green</span>
   evas_object_move(r2, 10, 10);
   evas_object_resize(r2, 50, 50);
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r2);

   <span class="comment">/* Lastly, for comparison add a dark green rectangle with no</span>
<span class="comment">    * transparency. */</span>
   r3 = <a class="code" href="group__Evas__Object__Rectangle.html#ga4d80fc32ad1cac28428cebd65d746751">evas_object_rectangle_add</a>(canvas);
   <a class="code" href="group__Evas__Object__Group__Basic.html#gae34bdcfd7f5100151f6ea8ef4a392949">evas_object_color_set</a>(r3, 0, 128, 0, 255); <span class="comment">// 100% opaque dark green</span>
   evas_object_move(r3, 60, 60);
   evas_object_resize(r3, 50, 50);
   <a class="code" href="group__Evas__Object__Group__Basic.html#ga9cbc13661584e49fb9d9cdab514a1eeb">evas_object_show</a>(r3);

   puts(<span class="stringliteral">&quot;final scene (note updates):&quot;</span>);
   draw_scene(canvas);

   <span class="comment">/* In addition to displaying the canvas to the screen, let&#39;s also</span>
<span class="comment">    * output the buffer to a graphics file, for comparison.  Evas</span>
<span class="comment">    * supports a range of graphics file formats, but PPM is particularly</span>
<span class="comment">    * trivial to write, so our save_scene routine will output as PPM.</span>
<span class="comment">    */</span>
   save_scene(canvas, <span class="stringliteral">&quot;/tmp/evas-buffer-simple-render.ppm&quot;</span>);

   destroy_canvas(canvas);

   <a class="code" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09" title="Directly shutdown Evas.">evas_shutdown</a>();

   <span class="keywordflow">return</span> 0;
}

<span class="comment">/* Convenience routine to allocate and initialize the canvas.</span>
<span class="comment"> * In a real application we&#39;d be using ecore_evas_buffer_new() instead.</span>
<span class="comment"> */</span>
<span class="keyword">static</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *create_canvas(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   Evas_Engine_Info_Buffer *einfo;
   <span class="keywordtype">int</span> method;
   <span class="keywordtype">void</span> *pixels;

   <span class="comment">/* Request a handle for the &#39;buffer&#39; type of rendering engine. */</span>
   method = <a class="code" href="group__Evas__Output__Method.html#ga9f9871fdcc40ce1062d6565308020eb8">evas_render_method_lookup</a>(<span class="stringliteral">&quot;buffer&quot;</span>);
   <span class="keywordflow">if</span> (method &lt;= 0)
     {
    fputs(<span class="stringliteral">&quot;ERROR: evas was not compiled with &#39;buffer&#39; engine!\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Create a general canvas object.</span>
<span class="comment">    * Note that we are responsible for freeing the canvas when we&#39;re done. */</span>
   canvas = <a class="code" href="group__Evas__Canvas.html#ga67e8eb17d2a676bfdfb8794fc5f72bc0">evas_new</a>();
   <span class="keywordflow">if</span> (!canvas)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not instantiate new evas canvas.\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <span class="comment">/* Specify that the canvas will be rendering using the buffer engine method.</span>
<span class="comment">    * We also size the canvas and viewport to the same width and height, with</span>
<span class="comment">    * the viewport set to the origin of the canvas.</span>
<span class="comment">    */</span>
   <a class="code" href="group__Evas__Canvas.html#ga15b85dc673baa6aa40f91f8bfcd3cbaa" title="Sets the output engine for the given evas.">evas_output_method_set</a>(canvas, method);
   <a class="code" href="group__Evas__Canvas.html#gaf6478cb249ed09fa0fe961085773fe1e" title="Sets the output size of the render engine of the given evas.">evas_output_size_set</a>(canvas, width, height);
   <a class="code" href="group__Evas__Canvas.html#ga6dcd13997f7825f03807dc0ec38dd38e" title="Sets the output viewport of the given evas in evas units.">evas_output_viewport_set</a>(canvas, 0, 0, width, height);

   <span class="comment">/* Before we can use the engine, we *must* set its configuration</span>
<span class="comment">    * parameters.  The available parameters are kept in a struct</span>
<span class="comment">    * named Evas_Engine_Info which is internal to Evas.  Thus to set</span>
<span class="comment">    * parameters we must first request the current info object from</span>
<span class="comment">    * our canvas:</span>
<span class="comment">    */</span>
   einfo = (Evas_Engine_Info_Buffer *)<a class="code" href="group__Evas__Canvas.html#gaf396b44e1b97ec0d9dce49fcf9ad54b7" title="Retrieves the current render engine info struct from the given evas.">evas_engine_info_get</a>(canvas);
   <span class="keywordflow">if</span> (!einfo)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not get evas engine info!\n&quot;</span>, stderr);
    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
</pre></div></p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Main__Group.html#ga5dc5f05144dd72e8d58a043344e373b8" title="Directly initialize Evas and its required dependencies.">evas_init()</a>. </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0f(2.3.1) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="eina_tiler_01_8c-example.html#a30">eina_tiler_01.c</a>, <a class="el" href="evas-buffer-simple_8c-example.html#a4">evas-buffer-simple.c</a>, and <a class="el" href="evas-init-shutdown_8c-example.html#a5">evas-init-shutdown.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
