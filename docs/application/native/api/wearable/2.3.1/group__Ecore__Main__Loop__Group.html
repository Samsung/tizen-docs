<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore Main Loop</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Wearable&#160;Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<div class="title">Ecore Main Loop</div>  </div>
<div class="ingroups"><a class="el" href="group__Ecore__Group.html">Ecore</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gad4c3bd5fb81af093ce3d64f6f8331043">ecore_fork_reset_callback_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function to be called by <a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808" title="Resets the ecore&#39;s internal state after a fork.">ecore_fork_reset()</a>.  <a href="#gad4c3bd5fb81af093ce3d64f6f8331043"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga10a1b477404946b0de4d01e32f84fec5">ecore_fork_reset_callback_del</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified callback.  <a href="#ga10a1b477404946b0de4d01e32f84fec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808">ecore_fork_reset</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the ecore's internal state after a fork.  <a href="#gaadff0a56ba8818d8a35f9dc95e25a808"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga0b23ea5d7f31f45e2c2f37d4393ddb2e">ecore_main_loop_iterate</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a single iteration of the main loop to process everything on the queue.  <a href="#ga0b23ea5d7f31f45e2c2f37d4393ddb2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede">ecore_main_loop_select_func_set</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a> func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of the file descriptors before ready for some class of I/O operation.  <a href="#gab140536aa1a0f69136f50cc927b8cede"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga5e959406d2cc4aac55e040d47e42f5bd">ecore_main_loop_select_func_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the select function set by ecore_select_func_set(), or the native select function if none was set.  <a href="#ga5e959406d2cc4aac55e040d47e42f5bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga111f77f35bf6f6065357dd0033d75e5c">ecore_main_loop_glib_integrate</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request ecore to integrate GLib's main loop.  <a href="#ga111f77f35bf6f6065357dd0033d75e5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga41c7d11043af50636ec75082c9d745c8">ecore_main_loop_glib_always_integrate_disable</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable always integrating glib.  <a href="#ga41c7d11043af50636ec75082c9d745c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the application main loop.  <a href="#gaf103b9f668bb3e4fed12e52c6180132d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Quits the main loop once all the events currently on the queue have been processed.  <a href="#ga95cf8e97dff0716433c2c5474d606a98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga12c98ccc13eb136ed62f8177d12a8fc0">ecore_main_loop_thread_safe_call_async</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a> callback, void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called asynchronously in the main loop.  <a href="#ga12c98ccc13eb136ed62f8177d12a8fc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga0df1b736c7f358c1df054c126d8dbc00">ecore_main_loop_thread_safe_call_sync</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#gac4edb7065bb785df0d1a90041380ea76">Ecore_Data_Cb</a> callback, void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called synchronously in the main loop.  <a href="#ga0df1b736c7f358c1df054c126d8dbc00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6">ecore_thread_main_loop_begin</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the main loop in the know state.  <a href="#ga0624ccd91c607ed241f45ac1da8875a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296">ecore_thread_main_loop_end</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the main loop.  <a href="#gabd2ff96845800d5fcb7cd2607fffa296"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a36ef1ac24bfa317a7826617264e530"></a><!-- doxytag: member="Ecore_Main_Loop_Group::Ecore_Task_Cb" ref="ga8a36ef1ac24bfa317a7826617264e530" args=")(void *data)" -->
typedef <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> )(void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean type for a callback that is run for a task (timer, idler, poller, animator, and so on). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00aa98b68b33de046b49a0158956874f"></a><!-- doxytag: member="Ecore_Main_Loop_Group::Ecore_Cb" ref="ga00aa98b68b33de046b49a0158956874f" args=")(void *data)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a> )(void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called as a hook when a certain point in the execution is reached. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4edb7065bb785df0d1a90041380ea76"></a><!-- doxytag: member="Ecore_Main_Loop_Group::Ecore_Data_Cb" ref="gac4edb7065bb785df0d1a90041380ea76" args=")(void *data)" -->
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gac4edb7065bb785df0d1a90041380ea76">Ecore_Data_Cb</a> )(void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to return data to the main function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa812c3d1e70623817acce9dcd2e8b71"></a><!-- doxytag: member="Ecore_Main_Loop_Group::Ecore_Select_Function" ref="gaaa812c3d1e70623817acce9dcd2e8b71" args=")(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)" -->
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a> )(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer type for a function that can be used to replace select() in the main loop. <br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#gae0c653baad8836232c0dc27f91f875d6">ECORE_CALLBACK_CANCEL</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga6a2922b8aa10c60f27c8ab49d84d75f2">ECORE_CALLBACK_PASS_ON</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga780091d7d49a4bb6cb753f12e1a3b19d">ECORE_CALLBACK_DONE</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2> </h2>
<p>This group discusses functions that are acting on Ecore's main loop itself or on events and infrastructure directly linked to it. Most programs only need to start and end the main loop, the rest of the function discussed here is meant to be used in special situations, and with great care. </p>
<p>For details on the usage of ecore's main loop and how it interacts with other ecore facilities see: <a class="el" href="Ecore_Main_Loop_Page.html">The Ecore Main Loop</a>. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gae0c653baad8836232c0dc27f91f875d6"></a><!-- doxytag: member="Ecore.h::ECORE_CALLBACK_CANCEL" ref="gae0c653baad8836232c0dc27f91f875d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Ecore__Main__Loop__Group.html#gae0c653baad8836232c0dc27f91f875d6">ECORE_CALLBACK_CANCEL</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return value to remove a callback </p>

</div>
</div>
<a class="anchor" id="ga780091d7d49a4bb6cb753f12e1a3b19d"></a><!-- doxytag: member="Ecore.h::ECORE_CALLBACK_DONE" ref="ga780091d7d49a4bb6cb753f12e1a3b19d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Ecore__Main__Loop__Group.html#ga780091d7d49a4bb6cb753f12e1a3b19d">ECORE_CALLBACK_DONE</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301">EINA_FALSE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return value to stop event handling </p>

</div>
</div>
<a class="anchor" id="ga6a2922b8aa10c60f27c8ab49d84d75f2"></a><!-- doxytag: member="Ecore.h::ECORE_CALLBACK_PASS_ON" ref="ga6a2922b8aa10c60f27c8ab49d84d75f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Ecore__Main__Loop__Group.html#ga6a2922b8aa10c60f27c8ab49d84d75f2">ECORE_CALLBACK_PASS_ON</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return value to pass an event to the next handler </p>

</div>
</div>
<a class="anchor" id="ga1ee9db07f9a46a8b20fb83e1c6dbed09"></a><!-- doxytag: member="Ecore.h::ECORE_CALLBACK_RENEW" ref="ga1ee9db07f9a46a8b20fb83e1c6dbed09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>&#160;&#160;&#160;<a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return value to keep a callback </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaadff0a56ba8818d8a35f9dc95e25a808"></a><!-- doxytag: member="Ecore.h::ecore_fork_reset" ref="gaadff0a56ba8818d8a35f9dc95e25a808" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808">ecore_fork_reset</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the ecore's internal state after a fork. </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Ecore maintains the internal data that can be affected by the fork() system call, which creates a duplicate of the current process. This also duplicates file descriptors, which is problematic as these file descriptors still point to their original sources. This function makes ecore's reset internal state (e.g. pipes used for signalling between threads) so they function correctly afterwards.</dd>
<dd>
It is highly suggested that you call this function after any fork() system call inside the child process. If you intend to use ecore features after this point and not call exec() family functions. Not doing so causes a possible misbehaviour. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4c3bd5fb81af093ce3d64f6f8331043"></a><!-- doxytag: member="Ecore.h::ecore_fork_reset_callback_add" ref="gad4c3bd5fb81af093ce3d64f6f8331043" args="(Ecore_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#gad4c3bd5fb81af093ce3d64f6f8331043">ecore_fork_reset_callback_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a function to be called by <a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808" title="Resets the ecore&#39;s internal state after a fork.">ecore_fork_reset()</a>. </p>
<p>This queues <em>func</em> to be called (and passes <em>data</em> as its argument) when <a class="el" href="group__Ecore__Main__Loop__Group.html#gaadff0a56ba8818d8a35f9dc95e25a808" title="Resets the ecore&#39;s internal state after a fork.">ecore_fork_reset()</a> is called. This allows other libraries and subsystems to also reset their internal state after a fork.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A data pointer to pass to the called function <em>func</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> if succeed, otherwise <a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301" title="Definition of the boolean value FALSE (numerical value 0).">EINA_FALSE</a>.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga10a1b477404946b0de4d01e32f84fec5"></a><!-- doxytag: member="Ecore.h::ecore_fork_reset_callback_del" ref="ga10a1b477404946b0de4d01e32f84fec5" args="(Ecore_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#ga10a1b477404946b0de4d01e32f84fec5">ecore_fork_reset_callback_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified callback. </p>
<p>This deletes the callback added by <a class="el" href="group__Ecore__Main__Loop__Group.html#gad4c3bd5fb81af093ce3d64f6f8331043" title="Adds a function to be called by ecore_fork_reset().">ecore_fork_reset_callback_add()</a> using the function and data pointer to specify which callback to remove.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A data pointer to pass to the called function <em>func</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> if succeed, otherwise <a class="el" href="group__Eina__Types__Group.html#ga1feb115f8e9913e806e090d9bd5a7301" title="Definition of the boolean value FALSE (numerical value 0).">EINA_FALSE</a>.</dd></dl>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.7 </dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="gaf103b9f668bb3e4fed12e52c6180132d"></a><!-- doxytag: member="Ecore.h::ecore_main_loop_begin" ref="gaf103b9f668bb3e4fed12e52c6180132d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runs the application main loop. </p>
<p>This function will not return until <a class="el" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a> is called. It will check for expired timers, idlers, file descriptors being watched by fd handlers, etc. Once everything is done, before entering again on idle state, any callback set as <code>Idle_Enterer</code> will be called.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Each main loop iteration is done by calling <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0b23ea5d7f31f45e2c2f37d4393ddb2e" title="Runs a single iteration of the main loop to process everything on the queue.">ecore_main_loop_iterate()</a> internally.</dd>
<dd>
The polling (select) function used can be changed with <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a>.</dd>
<dd>
The function used to check for file descriptors, events, and that has a timeout for the timers can be changed using <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a>.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga41c7d11043af50636ec75082c9d745c8"></a><!-- doxytag: member="Ecore.h::ecore_main_loop_glib_always_integrate_disable" ref="ga41c7d11043af50636ec75082c9d745c8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#ga41c7d11043af50636ec75082c9d745c8">ecore_main_loop_glib_always_integrate_disable</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable always integrating glib. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If ecore is compiled with --with-glib=always (to always call <a class="el" href="group__Ecore__Main__Loop__Group.html#ga111f77f35bf6f6065357dd0033d75e5c" title="Request ecore to integrate GLib&#39;s main loop.">ecore_main_loop_glib_integrate()</a>), This is for apps that explicitly do not want this to happen for whatever reasons they may have.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga111f77f35bf6f6065357dd0033d75e5c"></a><!-- doxytag: member="Ecore.h::ecore_main_loop_glib_integrate" ref="ga111f77f35bf6f6065357dd0033d75e5c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#ga111f77f35bf6f6065357dd0033d75e5c">ecore_main_loop_glib_integrate</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request ecore to integrate GLib's main loop. </p>
<p>This will add a small overhead during every main loop interaction by checking glib's default main context (used by its main loop). If it have events to be checked (timers, file descriptors or idlers), then these will be polled alongside with Ecore's own events, then dispatched before Ecore's. This is done by calling <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a>.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This will cooperate with previously set <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a> by calling the old function. Similarly, if you want to override <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede" title="Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of ...">ecore_main_loop_select_func_set()</a> after main loop is integrated, call the new select function set by this call (get it by calling <a class="el" href="group__Ecore__Main__Loop__Group.html#ga5e959406d2cc4aac55e040d47e42f5bd" title="Gets the select function set by ecore_select_func_set(), or the native select function if none was se...">ecore_main_loop_select_func_get()</a> right after <a class="el" href="group__Ecore__Main__Loop__Group.html#ga111f77f35bf6f6065357dd0033d75e5c" title="Request ecore to integrate GLib&#39;s main loop.">ecore_main_loop_glib_integrate()</a>).</dd>
<dd>
This is useful to use GMainLoop libraries, like GTK, GUPnP, LibSoup, GConf and more. Adobe Flash plugin and other plugins systems depend on this as well.</dd>
<dd>
Once initialized/integrated, it will be valid until Ecore is completely shut down.</dd>
<dd>
This is only available if Ecore was compiled with GLib support. </dd>
<dd>
You don't need to call this function if Ecore was compiled with --with-glib=always.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> on success of <code>EINA_FALSE</code> if it failed, likely no GLib support in Ecore.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b23ea5d7f31f45e2c2f37d4393ddb2e"></a><!-- doxytag: member="Ecore.h::ecore_main_loop_iterate" ref="ga0b23ea5d7f31f45e2c2f37d4393ddb2e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0b23ea5d7f31f45e2c2f37d4393ddb2e">ecore_main_loop_iterate</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runs a single iteration of the main loop to process everything on the queue. </p>
<p>It does everything that is already done inside an <code>Ecore</code> main loop, like checking for expired timers, idlers, etc. But it will do it only once and return, instead of keep watching for new events.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>DO NOT use this function unless you are the person God comes to ask for advice when He has trouble managing the Universe.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga95cf8e97dff0716433c2c5474d606a98"></a><!-- doxytag: member="Ecore.h::ecore_main_loop_quit" ref="ga95cf8e97dff0716433c2c5474d606a98" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Quits the main loop once all the events currently on the queue have been processed. </p>
<p>This function returns immediately, but will mark the <a class="el" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d" title="Runs the application main loop.">ecore_main_loop_begin()</a> function to return at the end of the current main loop iteration.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e959406d2cc4aac55e040d47e42f5bd"></a><!-- doxytag: member="Ecore.h::ecore_main_loop_select_func_get" ref="ga5e959406d2cc4aac55e040d47e42f5bd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a> <a class="el" href="group__Ecore__Main__Loop__Group.html#ga5e959406d2cc4aac55e040d47e42f5bd">ecore_main_loop_select_func_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the select function set by ecore_select_func_set(), or the native select function if none was set. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The select function</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Main__Loop__Group.html#ga5e959406d2cc4aac55e040d47e42f5bd" title="Gets the select function set by ecore_select_func_set(), or the native select function if none was se...">ecore_main_loop_select_func_get()</a></dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="gab140536aa1a0f69136f50cc927b8cede"></a><!-- doxytag: member="Ecore.h::ecore_main_loop_select_func_set" ref="gab140536aa1a0f69136f50cc927b8cede" args="(Ecore_Select_Function func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#gab140536aa1a0f69136f50cc927b8cede">ecore_main_loop_select_func_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#gaaa812c3d1e70623817acce9dcd2e8b71">Ecore_Select_Function</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the function to use when monitoring multiple file descriptors, and waiting until one of more of the file descriptors before ready for some class of I/O operation. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function will be used instead of the system call select and could possible be used to integrate the Ecore event loop with an external event loop.</dd>
<dd>
you don't know how to use, don't even try to use it.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Main__Loop__Group.html#ga5e959406d2cc4aac55e040d47e42f5bd" title="Gets the select function set by ecore_select_func_set(), or the native select function if none was se...">ecore_main_loop_select_func_get()</a></dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga12c98ccc13eb136ed62f8177d12a8fc0"></a><!-- doxytag: member="Ecore.h::ecore_main_loop_thread_safe_call_async" ref="ga12c98ccc13eb136ed62f8177d12a8fc0" args="(Ecore_Cb callback, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Main__Loop__Group.html#ga12c98ccc13eb136ed62f8177d12a8fc0">ecore_main_loop_thread_safe_call_async</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga00aa98b68b33de046b49a0158956874f">Ecore_Cb</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called asynchronously in the main loop. </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1.0</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>For all calls that need to happen in the main loop (most EFL functions do), this helper function provides the infrastructure needed to do it safely by avoiding a dead lock, race condition, and by properly waking up the main loop.</dd>
<dd>
Remember that after the function call, you should never touch the <em>data</em> in the thread again, it is owned by the main loop and your callback should take care of freeing it, if necessary.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to call in the main loop </td></tr>
    <tr><td class="paramname">data</td><td>The data to give to that call</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0df1b736c7f358c1df054c126d8dbc00"></a><!-- doxytag: member="Ecore.h::ecore_main_loop_thread_safe_call_sync" ref="ga0df1b736c7f358c1df054c126d8dbc00" args="(Ecore_Data_Cb callback, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0df1b736c7f358c1df054c126d8dbc00">ecore_main_loop_thread_safe_call_sync</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#gac4edb7065bb785df0d1a90041380ea76">Ecore_Data_Cb</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called synchronously in the main loop. </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1.0</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>For all calls that need to happen in the main loop (most EFL functions do), this helper function provides the infrastructure needed to do it safely by avoiding a dead lock, race condition, and by properly waking up the main loop.</dd>
<dd>
Remember that this function blocks until the callback is executed in the main loop. It can take time and you have no guarantee about the timeline.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to call in the main loop </td></tr>
    <tr><td class="paramname">data</td><td>The data to give to that call </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value returned by the callback in the main loop</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="ga0624ccd91c607ed241f45ac1da8875a6"></a><!-- doxytag: member="Ecore.h::ecore_thread_main_loop_begin" ref="ga0624ccd91c607ed241f45ac1da8875a6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6">ecore_thread_main_loop_begin</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suspends the main loop in the know state. </p>
<p>This function suspends the main loop in the know state. This lets you use any EFL call that you want after it returns. Be careful, the main loop is blocked until you call <a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296" title="Unlocks the main loop.">ecore_thread_main_loop_end()</a>. This is the only way to achieve pseudo thread safety.</p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1.0</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Notice that till the main loop is blocked, the thread is blocked and there is no way around that.</dd>
<dd>
We still advise you, if possible, to use <a class="el" href="group__Ecore__Main__Loop__Group.html#ga12c98ccc13eb136ed62f8177d12a8fc0" title="Called asynchronously in the main loop.">ecore_main_loop_thread_safe_call_async()</a> as it does not block the thread or the main loop.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of times <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6" title="Suspends the main loop in the know state.">ecore_thread_main_loop_begin()</a> has been called in this thread, if the main loop is suspended correctly <br/>
 If not, it returns <code>-1</code>.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
<a class="anchor" id="gabd2ff96845800d5fcb7cd2607fffa296"></a><!-- doxytag: member="Ecore.h::ecore_thread_main_loop_end" ref="gabd2ff96845800d5fcb7cd2607fffa296" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296">ecore_thread_main_loop_end</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlocks the main loop. </p>
<dl class="user"><dt><b>Since (EFL) :</b></dt><dd>1.1.0</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>After a call to <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6" title="Suspends the main loop in the know state.">ecore_thread_main_loop_begin()</a>, you need to absolutely call <a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296" title="Unlocks the main loop.">ecore_thread_main_loop_end()</a>, or your application stays frozen.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of times <a class="el" href="group__Ecore__Main__Loop__Group.html#gabd2ff96845800d5fcb7cd2607fffa296" title="Unlocks the main loop.">ecore_thread_main_loop_end()</a> needs to be called before the main loop is unlocked again <br/>
 <code>-1</code> is retured if you are trying to unlock when there aren't enough calls to <a class="el" href="group__Ecore__Main__Loop__Group.html#ga0624ccd91c607ed241f45ac1da8875a6" title="Suspends the main loop in the know state.">ecore_thread_main_loop_begin()</a>.</dd></dl>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1 </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
