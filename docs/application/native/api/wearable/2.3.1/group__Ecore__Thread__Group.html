<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore Thread</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Wearable&#160;Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Ecore Thread</div>  </div>
<div class="ingroups"><a class="el" href="group__Ecore__Main__Loop__Group.html">Ecore Main Loop</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_blocking, <a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_end, <a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_cancel, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a task to run in a parallel thread to avoid locking the main loop.  <a href="#gaac9c9933ef0a90ba86f8fd0247e9c7ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_heavy, <a class="el" href="group__Ecore__Thread__Group.html#gad2d0337f9bd59848a3194bac11e71a1a">Ecore_Thread_Notify_Cb</a> func_notify, <a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_end, <a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> func_cancel, const void *data, <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> try_no_queue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Launches a thread to run a task that can talk back to the main thread.  <a href="#ga4bde6b50e177f26ab5b2688aa99e3878"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a running thread.  <a href="#gae9b9b20e1ed53c62c51617b55aed2511"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a thread is in pending cancellation.  <a href="#ga792471a7ed00718b71d58b791ddbd08d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga8fadd19caae011ab1483665f09ce4d91">ecore_thread_feedback</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const void *msg_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data from the worker thread to the main loop.  <a href="#ga8fadd19caae011ab1483665f09ce4d91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185">ecore_thread_reschedule</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks for the function in the thread to be called again at a later period.  <a href="#gadf825c1a58f06bba2a304d025bed3185"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gad7a28588dc26d6af8b6db8abc3ef37ce">ecore_thread_active_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of active threads running jobs.  <a href="#gad7a28588dc26d6af8b6db8abc3ef37ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga3e32f650cfe811e69bba7825c71b9070">ecore_thread_pending_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of short jobs waiting for a thread to run.  <a href="#ga3e32f650cfe811e69bba7825c71b9070"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gaa5c56445198f7b03c1f080039499689a">ecore_thread_pending_feedback_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of feedback jobs waiting for a thread to run.  <a href="#gaa5c56445198f7b03c1f080039499689a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gaeaa014287d578a200d41cca861bceac3">ecore_thread_pending_total_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of pending jobs.  <a href="#gaeaa014287d578a200d41cca861bceac3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220">ecore_thread_max_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of threads that can run simultaneously.  <a href="#gabad7972818b7fb1346ae7a098cd47220"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693">ecore_thread_max_set</a> (int num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of threads allowed to run simultaneously.  <a href="#gaaf965a46e0cc12857883806812af7693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga4324944541abf9f84861690b4ff66e18">ecore_thread_max_reset</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the maximum number of concurrently running threads to the default.  <a href="#ga4324944541abf9f84861690b4ff66e18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga6e7703b3013d9c872449f6e2ec093b53">ecore_thread_available_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of threads available for running tasks.  <a href="#ga6e7703b3013d9c872449f6e2ec093b53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66">ecore_thread_local_data_add</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const char *key, void *value, <a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a> cb, <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> direct)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some data present in the hash local to the thread.  <a href="#ga6878f550a9bcc8002c0c709b4b4dca66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453">ecore_thread_local_data_set</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const char *key, void *value, <a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a> cb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets some data present in the hash local to the given thread.  <a href="#ga56a7d8c062f5c42fbc338c9ded4da453"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad">ecore_thread_local_data_find</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const char *key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets data stored in the hash local to the given thread.  <a href="#ga1a937d674f1a20162b31b95d0ed100ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779">ecore_thread_local_data_del</a> (<a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, const char *key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the data corresponding to the given key from the thread's hash.  <a href="#gad3c1d51a24772b885b26486be86c2779"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a> (const char *key, void *value, <a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a> cb, <a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> direct)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds some data to a hash shared by all threads.  <a href="#ga4e9de7492f8400e19ddd157d8cc21811"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd">ecore_thread_global_data_set</a> (const char *key, void *value, <a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a> cb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets some data in the hash shared by all threads.  <a href="#gace0bfd51f1dceef9d66f620bcffccabd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find</a> (const char *key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets data stored in the hash shared by all threads.  <a href="#ga011eeb2f99aaa950089ddc6ea989da29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132">ecore_thread_global_data_del</a> (const char *key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the data corresponding to the given key from the shared hash.  <a href="#ga8e53feb974331550744cbc2e40dc9132"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga910b00728b8b0201677f7a09e8d44896">ecore_thread_global_data_wait</a> (const char *key, double seconds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets data stored in the shared hash or waits for it if it doesn't exist.  <a href="#ga910b00728b8b0201677f7a09e8d44896"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c2e1f8d562ccf80ecc0009ada72496f"></a><!-- doxytag: member="Ecore_Thread_Group::Ecore_Thread" ref="ga0c2e1f8d562ccf80ecc0009ada72496f" args="" -->
typedef struct _Ecore_Thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for threaded jobs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2df413a7ddcf4912abe99c0be8de4d33"></a><!-- doxytag: member="Ecore_Thread_Group::Ecore_Thread_Cb" ref="ga2df413a7ddcf4912abe99c0be8de4d33" args=")(void *data, Ecore_Thread *thread)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a> )(void *data, <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to be used by Ecore_Thread helper. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad2d0337f9bd59848a3194bac11e71a1a"></a><!-- doxytag: member="Ecore_Thread_Group::Ecore_Thread_Notify_Cb" ref="gad2d0337f9bd59848a3194bac11e71a1a" args=")(void *data, Ecore_Thread *thread, void *msg_data)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Thread__Group.html#gad2d0337f9bd59848a3194bac11e71a1a">Ecore_Thread_Notify_Cb</a> )(void *data, <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *thread, void *msg_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to be used by the main loop to receive data sent by an <a class="el" href="group__Ecore__Thread__Group.html">Ecore Thread</a>. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2> </h2>
<p>Facilities to run heavy tasks in different threads to avoid blocking the main loop. </p>
<p>The EFL is, for the most part, not thread safe. This means that if you have some task running in another thread and you have, for example, an Evas object to show the status progress of this task, you cannot update the object from within the thread. This can only be done from the main thread, the one running the main loop. This problem can be solved by running a thread that sends messages to the main one using an <a class="el" href="group__Ecore__Pipe__Group.html">Ecore_Pipe</a>, but when you need to handle other things like cancelling the thread, your code grows in complexity and gets much harder to maintain.</p>
<p>Ecore Thread is here to solve that problem. It is not a simple wrapper around standard POSIX threads (or an equivalent in other systems) and it's not meant to be used to run parallel tasks throughout the entire duration of the program, especially when these tasks are performance critical, as Ecore manages these tasks using a pool of threads based on system configuration.</p>
<p>What Ecore Thread does is it makes it a lot easier to dispatch a worker function to perform some heavy tasks and then get the result once it completes, without blocking the application's UI. In addition, cancelling and rescheduling comes practically for free and the developer need not worry about how many threads are launched, since Ecore schedules them according to the number of processors the system has and the maximum amount of concurrent threads set for the application.</p>
<p>At the system level, Ecore starts a new thread on an as-needed basis until the maximum set is reached. When no more threads can be launched, new worker functions are queued in a waiting list until a thread becomes available. This way, system threads are shared throughout different worker functions, but running only one at a time. At the same time, a worker function that is rescheduled may be run on a different thread the next time.</p>
<p>The <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f" title="A handle for threaded jobs.">Ecore_Thread</a> handler has two meanings, depending on what context it is on. The one returned when starting a worker with any of the functions <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef" title="Schedules a task to run in a parallel thread to avoid locking the main loop.">ecore_thread_run()</a> or <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878" title="Launches a thread to run a task that can talk back to the main thread.">ecore_thread_feedback_run()</a> is an identifier of that specific instance of the function and can be used from the main loop with the <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511" title="Cancels a running thread.">ecore_thread_cancel()</a> and <a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d" title="Checks whether a thread is in pending cancellation.">ecore_thread_check()</a> functions. This handler must not be shared with the worker function running in the thread. This same handler is the one received on the <code>end</code>, <code>cancel</code>, and <code>feedback</code> callbacks.</p>
<p>The worker function, that's the one running in the thread, also receives an <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f" title="A handle for threaded jobs.">Ecore_Thread</a> handler that can be used with <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511" title="Cancels a running thread.">ecore_thread_cancel()</a> and <a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d" title="Checks whether a thread is in pending cancellation.">ecore_thread_check()</a>, sharing the flag with the main loop. But this handler is also associated with the thread where the function is running. This has strong implications when working with thread local data.</p>
<p>There are two kinds of worker threads that Ecore handles: simple or short, workers, and feedback workers.</p>
<p>The first kind is for simple functions that perform a usually small but time consuming task. Ecore runs this function in a thread as soon as one becomes available and notifies the calling user of its completion once the task is done.</p>
<p>The following image shows the flow of a program running four tasks on a pool of two threads.</p>
<div class="image">
<img src="ecore_thread.png" alt="ecore_thread.png"/>
</div>
  <p>For larger tasks that may require continuous communication with the main program, the feedback workers provide the same functionality plus a way for the function running in the thread to send messages to the main thread.</p>
<p>The next diagram omits some details shown in the previous one regarding how threads are spawned and tasks are queued, but illustrates how feedback jobs communicate with the main loop and the special case of threads running out of the pool.</p>
<div class="image">
<img src="ecore_thread_feedback.png" alt="ecore_thread_feedback.png"/>
</div>
   <hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad7a28588dc26d6af8b6db8abc3ef37ce"></a><!-- doxytag: member="Ecore.h::ecore_thread_active_get" ref="gad7a28588dc26d6af8b6db8abc3ef37ce" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#gad7a28588dc26d6af8b6db8abc3ef37ce">ecore_thread_active_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of active threads running jobs. </p>
<p>This returns the number of threads currently running jobs of any type through the Ecore_Thread API.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Jobs started through the <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878" title="Launches a thread to run a task that can talk back to the main thread.">ecore_thread_feedback_run()</a> function with the <em>try_no_queue</em> parameter set to <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> are not accounted for in the return of this function unless the thread creation fails and it falls back to using one from the pool.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of active threads running jobs </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e7703b3013d9c872449f6e2ec093b53"></a><!-- doxytag: member="Ecore.h::ecore_thread_available_get" ref="ga6e7703b3013d9c872449f6e2ec093b53" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#ga6e7703b3013d9c872449f6e2ec093b53">ecore_thread_available_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of threads available for running tasks. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is same as doing <a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220" title="Gets the maximum number of threads that can run simultaneously.">ecore_thread_max_get()</a> - <a class="el" href="group__Ecore__Thread__Group.html#gad7a28588dc26d6af8b6db8abc3ef37ce" title="Gets the number of active threads running jobs.">ecore_thread_active_get()</a>.</dd>
<dd>
This function may return a negative number only in the case when the user changes the maximum number of running threads while other tasks are running.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of available threads </dd></dl>

</div>
</div>
<a class="anchor" id="gae9b9b20e1ed53c62c51617b55aed2511"></a><!-- doxytag: member="Ecore.h::ecore_thread_cancel" ref="gae9b9b20e1ed53c62c51617b55aed2511" args="(Ecore_Thread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511">ecore_thread_cancel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancels a running thread. </p>
<p>This function cancels a running thread. If <em>thread</em> can be immediately cancelled (its still pending execution after creation or rescheduling), then the <em>cancel</em> callback is called, <em>thread</em> is freed and the function returns <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If the thread is already running, then this function returns <code>EINA_FALSE</code> after marking the <em>thread</em> as pending cancellation. For the thread to actually be terminated, it needs to return from the user function back into Ecore control. This can happen in several ways: <ul>
<li>The function ends and returns normally. If it hadn't been cancelled, <em>func_end</em> would be called here, but instead <em>func_cancel</em> happens. </li>
<li>The function returns after requesting to be rescheduled with <a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185" title="Asks for the function in the thread to be called again at a later period.">ecore_thread_reschedule()</a>. </li>
<li>The function is prepared to leave early by checking if <a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d" title="Checks whether a thread is in pending cancellation.">ecore_thread_check()</a> returns <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a>.</li>
</ul>
</dd>
<dd>
The user function can cancel itself by calling <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511" title="Cancels a running thread.">ecore_thread_cancel()</a>, but it should always use the <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f" title="A handle for threaded jobs.">Ecore_Thread</a> handle passed to it and never share it with the main loop thread by means of shared user data or in any other way.</dd>
<dd>
<em>thread</em> is freed and should not be used again if this function returns <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> or after the <em>func_cancel</em> callback returns.</dd>
<dd>
This function can be called both in the main loop and in the running thread.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread to cancel </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> if the thread has been cancelled, otherwise <code>EINA_FALSE</code> if it is pending</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d" title="Checks whether a thread is in pending cancellation.">ecore_thread_check()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga792471a7ed00718b71d58b791ddbd08d"></a><!-- doxytag: member="Ecore.h::ecore_thread_check" ref="ga792471a7ed00718b71d58b791ddbd08d" args="(Ecore_Thread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga792471a7ed00718b71d58b791ddbd08d">ecore_thread_check</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a thread is in pending cancellation. </p>
<p>This function can be called both in the main loop and in the running thread.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>When <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511" title="Cancels a running thread.">ecore_thread_cancel()</a> is called on an already running task, the thread is marked as pending cancellation. This function returns <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> if this mark is set for the given <em>thread</em> and can be used from the main loop thread to check if a still active thread has been cancelled, or from the user function running in the thread to check if it should stop doing what it's doing and return early, effectively cancelling the task.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> if the thread is in pending cancellation, otherwise <code>EINA_FALSE</code> if it is not</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511" title="Cancels a running thread.">ecore_thread_cancel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8fadd19caae011ab1483665f09ce4d91"></a><!-- doxytag: member="Ecore.h::ecore_thread_feedback" ref="ga8fadd19caae011ab1483665f09ce4d91" args="(Ecore_Thread *thread, const void *msg_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga8fadd19caae011ab1483665f09ce4d91">ecore_thread_feedback</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msg_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends data from the worker thread to the main loop. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>You should use this function only in the <em>func_heavy</em> call.</dd>
<dd>
Only the address to <em>msg_data</em> is sent and once this function returns <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a>, the job running in the thread should never touch the contents of it again. The data sent should be malloc()'ed or something similar, as long as it's not the memory that is local to the thread that risks being overwritten or deleted once it goes out of scope or the thread finishes.</dd>
<dd>
Care must be taken that <em>msg_data</em> is properly freed in the <em>func_notify</em> callback set when creating the thread.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The current <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f" title="A handle for threaded jobs.">Ecore_Thread</a> context to send data from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_data</td><td>The data to be transmitted to the main loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> if <em>msg_data</em> is successfully sent to the main loop, otherwise <code>EINA_FALSE</code> if anything goes wrong</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878" title="Launches a thread to run a task that can talk back to the main thread.">ecore_thread_feedback_run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bde6b50e177f26ab5b2688aa99e3878"></a><!-- doxytag: member="Ecore.h::ecore_thread_feedback_run" ref="ga4bde6b50e177f26ab5b2688aa99e3878" args="(Ecore_Thread_Cb func_heavy, Ecore_Thread_Notify_Cb func_notify, Ecore_Thread_Cb func_end, Ecore_Thread_Cb func_cancel, const void *data, Eina_Bool try_no_queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a>* <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878">ecore_thread_feedback_run</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_heavy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#gad2d0337f9bd59848a3194bac11e71a1a">Ecore_Thread_Notify_Cb</a>&#160;</td>
          <td class="paramname"><em>func_notify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>try_no_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Launches a thread to run a task that can talk back to the main thread. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The difference in the above is that <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef" title="Schedules a task to run in a parallel thread to avoid locking the main loop.">ecore_thread_run()</a> is meant for tasks that don't need to communicate anything until they finish, while this function is provided with a new callback, <em>func_notify</em>, that is called from the main thread for every message sent from <em>func_heavy</em> with <a class="el" href="group__Ecore__Thread__Group.html#ga8fadd19caae011ab1483665f09ce4d91" title="Sends data from the worker thread to the main loop.">ecore_thread_feedback()</a>.</dd>
<dd>
Like with <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef" title="Schedules a task to run in a parallel thread to avoid locking the main loop.">ecore_thread_run()</a>, a new thread is launched to run <em>func_heavy</em> unless the maximum number of simultaneous threads has been reached, in which case the function is scheduled to run whenever a running task ends and a thread becomes free. But if <em>try_no_queue</em> is set, Ecore first tries to launch a thread outside of the pool to run the task. If it fails, it reverts to the normal behaviour of using a thread from the pool as if <em>try_no_queue</em> had not been set.</dd>
<dd>
Keep in mind that Ecore handles the thread pool based on the number of CPUs available, but running a thread outside of the pool doesn't count for this, so having too many of them may have drastic effects over the program's performance.</dd>
<dd>
See <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef" title="Schedules a task to run in a parallel thread to avoid locking the main loop.">ecore_thread_run()</a> for a general description of this function.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func_heavy</td><td>The function that should run in another thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_notify</td><td>the function that receives the data sent from the thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_end</td><td>The function to call from the main loop when <em>func_heavy</em> completes its task successfully </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_cancel</td><td>The function to call from the main loop if the thread running <em>func_heavy</em> is cancelled or fails to start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The user context data to pass to all callbacks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">try_no_queue</td><td>The boolean value that indicates whether to run outside the thread pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new thread handler, otherwise <code>NULL</code> on failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga8fadd19caae011ab1483665f09ce4d91" title="Sends data from the worker thread to the main loop.">ecore_thread_feedback()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef" title="Schedules a task to run in a parallel thread to avoid locking the main loop.">ecore_thread_run()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511" title="Cancels a running thread.">ecore_thread_cancel()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185" title="Asks for the function in the thread to be called again at a later period.">ecore_thread_reschedule()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693" title="Sets the maximum number of threads allowed to run simultaneously.">ecore_thread_max_set()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e9de7492f8400e19ddd157d8cc21811"></a><!-- doxytag: member="Ecore.h::ecore_thread_global_data_add" ref="ga4e9de7492f8400e19ddd157d8cc21811" args="(const char *key, void *value, Eina_Free_Cb cb, Eina_Bool direct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811">ecore_thread_global_data_add</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>direct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds some data to a hash shared by all threads. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Ecore Thread keeps a hash that can be used to share data across several threads, including the main loop thread, without having to manually handle mutexes to do it safely.</dd>
<dd>
This function adds the data <em>value</em> to this hash under the given <em>key</em>. No other value in the hash may have the same <em>key</em>. If you need to change the value under a <em>key</em>, or you don't know if one exists already, you can use <a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd" title="Sets some data in the hash shared by all threads.">ecore_thread_global_data_set()</a>.</dd></dl>
<p>Neither <em>key</em> nor <em>value</em> may be <code>NULL</code> and <em>key</em> gets copied in the hash, unless <em>direct</em> is set, in which case the string used should not be freed until the data is removed from the hash.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The <em>cb</em> function is called when the data in the hash needs to be freed, be it because it got deleted with <a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132" title="Deletes the data corresponding to the given key from the shared hash.">ecore_thread_global_data_del()</a> or because Ecore Thread got shut down and the hash got destroyed. This parameter may be <code>NULL</code>, in which case <em>value</em> needs to be manually freed after removing it from the hash with either by <a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132" title="Deletes the data corresponding to the given key from the shared hash.">ecore_thread_global_data_del()</a> or <a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd" title="Sets some data in the hash shared by all threads.">ecore_thread_global_data_set()</a>.</dd></dl>
<p>Manually freeing any data that is added to the hash with the <em>cb</em> function is likely to produce a segmentation fault, or any other strange happening at a later stage in the program.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The data to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>The function to free the data when removed from the hash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direct</td><td>If <code>true</code>, this does not copy the key string (like <a class="el" href="group__Eina__Hash__Group.html#ga50aa7d4303e5efbe8dc7f593b59b9f63" title="Adds an entry to the given hash table without duplicating the string key.">eina_hash_direct_add()</a>), otherwise <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> on success, otherwise <code>EINA_FALSE</code> on failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132" title="Deletes the data corresponding to the given key from the shared hash.">ecore_thread_global_data_del()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd" title="Sets some data in the hash shared by all threads.">ecore_thread_global_data_set()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29" title="Gets data stored in the hash shared by all threads.">ecore_thread_global_data_find()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e53feb974331550744cbc2e40dc9132"></a><!-- doxytag: member="Ecore.h::ecore_thread_global_data_del" ref="ga8e53feb974331550744cbc2e40dc9132" args="(const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132">ecore_thread_global_data_del</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the data corresponding to the given key from the shared hash. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If there's any data associated with <code>key</code> that is stored in the global hash, this function removes it from the hash and returns <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a>. If no data exists or an error occurs, it returns <code>EINA_FALSE</code>.</dd>
<dd>
If the data is added to the hash with a free function, then it is also freed after removing it from the hash, otherwise it requires to be manually freed by the user, which means that if no other reference to it exists before calling this function, it results in a memory leak.</dd></dl>
<p>Note, also, that freeing data that other threads may be using results in a crash, so appropriate care must be taken by the application when that possibility exists.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> on success, otherwise <code>EINA_FALSE</code> on failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811" title="Adds some data to a hash shared by all threads.">ecore_thread_global_data_add()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga011eeb2f99aaa950089ddc6ea989da29"></a><!-- doxytag: member="Ecore.h::ecore_thread_global_data_find" ref="ga011eeb2f99aaa950089ddc6ea989da29" args="(const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29">ecore_thread_global_data_find</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets data stored in the hash shared by all threads. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<p>This finds and returns the data stored in the shared hash under the key <em>key</em>.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Keep in mind that the data returned may be used by more than one thread at the same time and no reference counting is done on it by Ecore. Freeing the data or modifying its contents may require additional precautions to be considered, depending on the application's design.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value under the given key, otherwise <code>NULL</code> on an error</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811" title="Adds some data to a hash shared by all threads.">ecore_thread_global_data_add()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga910b00728b8b0201677f7a09e8d44896" title="Gets data stored in the shared hash or waits for it if it doesn&#39;t exist.">ecore_thread_global_data_wait()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gace0bfd51f1dceef9d66f620bcffccabd"></a><!-- doxytag: member="Ecore.h::ecore_thread_global_data_set" ref="gace0bfd51f1dceef9d66f620bcffccabd" args="(const char *key, void *value, Eina_Free_Cb cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd">ecore_thread_global_data_set</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets some data in the hash shared by all threads. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If no data exists in the hash under the <em>key</em>, this function adds <em>value</em> in the hash under the given <em>key</em> and returns <code>NULL</code>. The key itself is copied.</dd></dl>
<p>If the hash already contains something under <em>key</em>, the data is replaced by <em>value</em> and the old value is returned.</p>
<p><code>NULL</code> is also returned if either <em>key</em> or <em>value</em> is <code>NULL</code>, or if an error occurs.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The data to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>The function to free the data when removed from the hash</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811" title="Adds some data to a hash shared by all threads.">ecore_thread_global_data_add()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga8e53feb974331550744cbc2e40dc9132" title="Deletes the data corresponding to the given key from the shared hash.">ecore_thread_global_data_del()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29" title="Gets data stored in the hash shared by all threads.">ecore_thread_global_data_find()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga910b00728b8b0201677f7a09e8d44896"></a><!-- doxytag: member="Ecore.h::ecore_thread_global_data_wait" ref="ga910b00728b8b0201677f7a09e8d44896" args="(const char *key, double seconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#ga910b00728b8b0201677f7a09e8d44896">ecore_thread_global_data_wait</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets data stored in the shared hash or waits for it if it doesn't exist. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This finds and returns the data stored in the shared hash under the key <em>key</em>.</dd></dl>
<p>If there's nothing in the hash under the given <em>key</em>, the function blocks and waits for <em>seconds</em> seconds for some other thread to add it with either <a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811" title="Adds some data to a hash shared by all threads.">ecore_thread_global_data_add()</a> or <a class="el" href="group__Ecore__Thread__Group.html#gace0bfd51f1dceef9d66f620bcffccabd" title="Sets some data in the hash shared by all threads.">ecore_thread_global_data_set()</a>. If after waiting there's still no data to obtain, <code>NULL</code> is returned.</p>
<p>If <em>seconds</em> is <code>0</code>, then no waiting happens and this function works like <a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29" title="Gets data stored in the hash shared by all threads.">ecore_thread_global_data_find()</a>. If <em>seconds</em> is less than <code>0</code>, then the function waits indefinitely.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Keep in mind that the data returned may be used by more than one thread at the same time and no reference counting is done on it by Ecore. Freeing the data or modifying its contents may require additional precautions to be considered, depending on the application's design.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seconds</td><td>The amount of time in seconds to wait for the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value under the given key, otherwise <code>NULL</code> on an error</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4e9de7492f8400e19ddd157d8cc21811" title="Adds some data to a hash shared by all threads.">ecore_thread_global_data_add()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga011eeb2f99aaa950089ddc6ea989da29" title="Gets data stored in the hash shared by all threads.">ecore_thread_global_data_find()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6878f550a9bcc8002c0c709b4b4dca66"></a><!-- doxytag: member="Ecore.h::ecore_thread_local_data_add" ref="ga6878f550a9bcc8002c0c709b4b4dca66" args="(Ecore_Thread *thread, const char *key, void *value, Eina_Free_Cb cb, Eina_Bool direct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66">ecore_thread_local_data_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td>
          <td class="paramname"><em>direct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds some data present in the hash local to the thread. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Ecore Thread has a mechanism to share data across several worker functions that run on the same system thread. That is, the data is stored per thread and for a worker function to have access to it, it must be run by the same thread that stored the data.</dd>
<dd>
When there are no more workers pending, the thread is destroyed along with the internal hash and any data left in it is freed with the given <em>cb</em> function.</dd></dl>
<p>@ This set of functions is useful to share things around several instances of a function when that thing is costly to create and can be reused, but may only be used by one function at a time.</p>
<p>For example, if you have a program doing requisitions to a database, these requisitions can be done in threads so that waiting for the database to respond doesn't block the UI. Each of these threads run a function, and each function is dependent on a connection to the database, which may not be able to handle more than one request at a time so for each running function you need one connection handle.</p>
<p>The options then are: </p>
<ul>
<li>Each function opens a connection when it's called, does the work and closes the connection when it finishes. This may be costly, wasting a lot of time on resolving hostnames, negotiating permissions, and allocating memory. </li>
<li>Open the connections in the main loop and pass it to the threads using the data pointer. Even worse, it's just as costly as before and now it may even be kept with connections open doing nothing until a thread becomes available to run the function. </li>
<li>Have a way to share connection handles, so that each instance of the function can check if an available connection exists, and if it doesn't, create one and add it to the pool. When no more connections are needed, they are all closed.</li>
</ul>
<p>The last option is the most efficient, but it requires a lot of work to be implemented properly. Using thread local data helps to achieve the same result while avoiding all the tracking work on your code. The way to use it would be at the worker function, to ask for the connection using <a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad" title="Gets data stored in the hash local to the given thread.">ecore_thread_local_data_find()</a> and if it doesn't exist, then open a new one and save it with <a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66" title="Adds some data present in the hash local to the thread.">ecore_thread_local_data_add()</a>. Complete the work and forget about the connection handle, when everything is done the function just ends. The next worker to run on that thread checks if a connection exists and finds that it does, so the process of opening a new one has been spared. When no more workers exist, the thread is destroyed and the callback used when saving the connection is called to close it.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function adds the data <em>value</em> to the thread data under the given <em>key</em>. No other value in the hash may have the same <em>key</em>. If you need to change the value under a <em>key</em>, or you don't know if one exists already, you can use <a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453" title="Sets some data present in the hash local to the given thread.">ecore_thread_local_data_set()</a>.</dd></dl>
<p>Neither <em>key</em> nor <em>value</em> may be <code>NULL</code> and <em>key</em> gets copied in the hash, unless <em>direct</em> is set, in which case the string used should not be freed until the data is removed from the hash.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The <em>cb</em> function is called when the data in the hash needs to be freed, be it because it got deleted by <a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779" title="Deletes the data corresponding to the given key from the thread&#39;s hash.">ecore_thread_local_data_del()</a> or because <em>thread</em> got terminated and the hash got destroyed. This parameter may be <code>NULL</code>, in which case <em>value</em> needs to be manually freed after removing it from the hash with either <a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779" title="Deletes the data corresponding to the given key from the thread&#39;s hash.">ecore_thread_local_data_del()</a> or <a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453" title="Sets some data present in the hash local to the given thread.">ecore_thread_local_data_set()</a>, but it's very unlikely that this is what you want.</dd></dl>
<p>This function, and all of the others in the <em>ecore_thread_local_data</em> family of functions, can only be called within the worker function running in the thread. Do not call them from the main loop or from a thread other than the one represented by <em>thread</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread context the data belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The data to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>The function to free the data when removed from the hash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direct</td><td>If <code>true</code>, this does not copy the key string (like <a class="el" href="group__Eina__Hash__Group.html#ga50aa7d4303e5efbe8dc7f593b59b9f63" title="Adds an entry to the given hash table without duplicating the string key.">eina_hash_direct_add()</a>), otherwise <code>false</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> on success, otherwise <code>EINA_FALSE</code> on failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453" title="Sets some data present in the hash local to the given thread.">ecore_thread_local_data_set()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad" title="Gets data stored in the hash local to the given thread.">ecore_thread_local_data_find()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779" title="Deletes the data corresponding to the given key from the thread&#39;s hash.">ecore_thread_local_data_del()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad3c1d51a24772b885b26486be86c2779"></a><!-- doxytag: member="Ecore.h::ecore_thread_local_data_del" ref="gad3c1d51a24772b885b26486be86c2779" args="(Ecore_Thread *thread, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779">ecore_thread_local_data_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the data corresponding to the given key from the thread's hash. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If there's any data associated with <em>key</em> that is stored in the global hash, this function removes it from the hash and returns <a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a>. If no data exists or an error occurs, it returns <code>EINA_FALSE</code>.</dd>
<dd>
If the data is added to the hash with a free function, then it is also freed after removing it from the hash, otherwise it requires to be manually freed by the user, which means that if no other reference to it exists before calling this function, it results in a memory leak.</dd>
<dd>
This function, and all the others in the <em>ecore_thread_local_data</em> family of functions, can only be called within the worker function running in the thread. Do not call them from the main loop or from a thread other than the one represented by <em>thread</em>.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread context the data belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> on success, otherwise <code>EINA_FALSE</code> on failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66" title="Adds some data present in the hash local to the thread.">ecore_thread_local_data_add()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a937d674f1a20162b31b95d0ed100ad"></a><!-- doxytag: member="Ecore.h::ecore_thread_local_data_find" ref="ga1a937d674f1a20162b31b95d0ed100ad" args="(Ecore_Thread *thread, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad">ecore_thread_local_data_find</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets data stored in the hash local to the given thread. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<p>This finds and returns the data stored in the shared hash under the key <em>key</em>.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function, and all the others in the <em>ecore_thread_local_data</em> family of functions, can only be called within the worker function running in the thread. Do not call them from the main loop or from a thread other than the one represented by <em>thread</em>.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread context the data belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value under the given key, otherwise <code>NULL</code> on an error</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66" title="Adds some data present in the hash local to the thread.">ecore_thread_local_data_add()</a> </dd>
<dd>
ecore_thread_local_data_wait() </dd></dl>

</div>
</div>
<a class="anchor" id="ga56a7d8c062f5c42fbc338c9ded4da453"></a><!-- doxytag: member="Ecore.h::ecore_thread_local_data_set" ref="ga56a7d8c062f5c42fbc338c9ded4da453" args="(Ecore_Thread *thread, const char *key, void *value, Eina_Free_Cb cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Thread__Group.html#ga56a7d8c062f5c42fbc338c9ded4da453">ecore_thread_local_data_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Eina__Types__Group.html#gadbac560ba2bca5c61d97bfbb542018f3">Eina_Free_Cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets some data present in the hash local to the given thread. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>If no data exists in the hash under the <em>key</em>, this function adds <em>value</em> in the hash under the given <em>key</em> and returns <code>NULL</code>. The key itself is copied.</dd></dl>
<p>If the hash already contains something under <em>key</em>, the data is replaced by <em>value</em> and the old value is returned.</p>
<p><code>NULL</code> is also returned if either <em>key</em> or <em>value</em> are <code>NULL</code>, or if an error occurs.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function, and all of the others in the <em>ecore_thread_local_data</em> family of functions, can only be called within the worker function running in the thread. Do not call them from the main loop or from a thread other than the one represented by <em>thread</em>.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread context the data belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name under which the data is stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The data to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>The function to free the data when removed from the hash</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga6878f550a9bcc8002c0c709b4b4dca66" title="Adds some data present in the hash local to the thread.">ecore_thread_local_data_add()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gad3c1d51a24772b885b26486be86c2779" title="Deletes the data corresponding to the given key from the thread&#39;s hash.">ecore_thread_local_data_del()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga1a937d674f1a20162b31b95d0ed100ad" title="Gets data stored in the hash local to the given thread.">ecore_thread_local_data_find()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabad7972818b7fb1346ae7a098cd47220"></a><!-- doxytag: member="Ecore.h::ecore_thread_max_get" ref="gabad7972818b7fb1346ae7a098cd47220" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220">ecore_thread_max_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the maximum number of threads that can run simultaneously. </p>
<p>This returns the maximum number of Ecore_Thread's that may be running at the same time. If this number is reached, new jobs started by either <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef" title="Schedules a task to run in a parallel thread to avoid locking the main loop.">ecore_thread_run()</a> or <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878" title="Launches a thread to run a task that can talk back to the main thread.">ecore_thread_feedback_run()</a> are added to the respective pending queues until one of the running threads finishes its task and becomes available to run a new one.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>By default, this is the number of available CPUs for the running program, or <code>1</code> if this value could not be fetched.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The maximum possible number of Ecore_Thread's running concurrently</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693" title="Sets the maximum number of threads allowed to run simultaneously.">ecore_thread_max_set()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga4324944541abf9f84861690b4ff66e18" title="Resets the maximum number of concurrently running threads to the default.">ecore_thread_max_reset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4324944541abf9f84861690b4ff66e18"></a><!-- doxytag: member="Ecore.h::ecore_thread_max_reset" ref="ga4324944541abf9f84861690b4ff66e18" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Thread__Group.html#ga4324944541abf9f84861690b4ff66e18">ecore_thread_max_reset</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the maximum number of concurrently running threads to the default. </p>
<p>This resets the value returned by <a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220" title="Gets the maximum number of threads that can run simultaneously.">ecore_thread_max_get()</a> back to its default.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220" title="Gets the maximum number of threads that can run simultaneously.">ecore_thread_max_get()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693" title="Sets the maximum number of threads allowed to run simultaneously.">ecore_thread_max_set()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf965a46e0cc12857883806812af7693"></a><!-- doxytag: member="Ecore.h::ecore_thread_max_set" ref="gaaf965a46e0cc12857883806812af7693" args="(int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693">ecore_thread_max_set</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the maximum number of threads allowed to run simultaneously. </p>
<p>This sets a new value for the maximum number of concurrently running Ecore_Thread's. It <b>must</b> be an integer between <code>1</code> and (<code>16</code> * <code>x</code>), where <code>x</code> is the number for CPUs available.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The new maximum</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#gabad7972818b7fb1346ae7a098cd47220" title="Gets the maximum number of threads that can run simultaneously.">ecore_thread_max_get()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#ga4324944541abf9f84861690b4ff66e18" title="Resets the maximum number of concurrently running threads to the default.">ecore_thread_max_reset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5c56445198f7b03c1f080039499689a"></a><!-- doxytag: member="Ecore.h::ecore_thread_pending_feedback_get" ref="gaa5c56445198f7b03c1f080039499689a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#gaa5c56445198f7b03c1f080039499689a">ecore_thread_pending_feedback_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of feedback jobs waiting for a thread to run. </p>
<p>This returns the number of tasks started with <a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878" title="Launches a thread to run a task that can talk back to the main thread.">ecore_thread_feedback_run()</a> that are pending and waiting for a thread to become available to run them.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of pending threads running "feedback" jobs </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e32f650cfe811e69bba7825c71b9070"></a><!-- doxytag: member="Ecore.h::ecore_thread_pending_get" ref="ga3e32f650cfe811e69bba7825c71b9070" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#ga3e32f650cfe811e69bba7825c71b9070">ecore_thread_pending_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of short jobs waiting for a thread to run. </p>
<p>This returns the number of tasks started with <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef" title="Schedules a task to run in a parallel thread to avoid locking the main loop.">ecore_thread_run()</a> that are pending and waiting for a thread to become available to run them.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of pending threads running "short" jobs </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaa014287d578a200d41cca861bceac3"></a><!-- doxytag: member="Ecore.h::ecore_thread_pending_total_get" ref="gaeaa014287d578a200d41cca861bceac3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Ecore__Thread__Group.html#gaeaa014287d578a200d41cca861bceac3">ecore_thread_pending_total_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the total number of pending jobs. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is same as the sum of <a class="el" href="group__Ecore__Thread__Group.html#ga3e32f650cfe811e69bba7825c71b9070" title="Gets the number of short jobs waiting for a thread to run.">ecore_thread_pending_get()</a> and <a class="el" href="group__Ecore__Thread__Group.html#gaa5c56445198f7b03c1f080039499689a" title="Gets the number of feedback jobs waiting for a thread to run.">ecore_thread_pending_feedback_get()</a>.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of pending threads running jobs </dd></dl>

</div>
</div>
<a class="anchor" id="gadf825c1a58f06bba2a304d025bed3185"></a><!-- doxytag: member="Ecore.h::ecore_thread_reschedule" ref="gadf825c1a58f06bba2a304d025bed3185" args="(Ecore_Thread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185">ecore_thread_reschedule</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asks for the function in the thread to be called again at a later period. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function should be called only from the function represented by <em>thread</em>.</dd></dl>
<p>Calling this function marks the thread for a reschedule, so as soon as it returns, it is added to the end of the list of pending tasks. If no other tasks are waiting or there are sufficient threads available, the rescheduled task is launched again immediately.</p>
<p>This should never return <code>EINA_FALSE</code>, unless it is called from the wrong thread or with the wrong arguments.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The <em>func_end</em> callback set when the thread is created is not called until the function in the thread returns without being rescheduled. Similarly, if the <em>thread</em> is cancelled, the reschedule does not take effect.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The current <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f" title="A handle for threaded jobs.">Ecore_Thread</a> context to reschedule </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc" title="Definition of the boolean value TRUE (numerical value 1).">EINA_TRUE</a> if the task is successfully rescheduled, otherwise <code>EINA_FALSE</code> if anything goes wrong </dd></dl>

</div>
</div>
<a class="anchor" id="gaac9c9933ef0a90ba86f8fd0247e9c7ef"></a><!-- doxytag: member="Ecore.h::ecore_thread_run" ref="gaac9c9933ef0a90ba86f8fd0247e9c7ef" args="(Ecore_Thread_Cb func_blocking, Ecore_Thread_Cb func_end, Ecore_Thread_Cb func_cancel, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f">Ecore_Thread</a>* <a class="el" href="group__Ecore__Thread__Group.html#gaac9c9933ef0a90ba86f8fd0247e9c7ef">ecore_thread_run</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Ecore__Thread__Group.html#ga2df413a7ddcf4912abe99c0be8de4d33">Ecore_Thread_Cb</a>&#160;</td>
          <td class="paramname"><em>func_cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedules a task to run in a parallel thread to avoid locking the main loop. </p>
<p>This function tries to create a new thread to run <em>func_blocking</em> in, or if the maximum number of concurrent threads has been reached it adds it to the pending list, where it waits until a thread becomes available. The return value is an <a class="el" href="group__Ecore__Thread__Group.html#ga0c2e1f8d562ccf80ecc0009ada72496f" title="A handle for threaded jobs.">Ecore_Thread</a> handle that can be used to cancel the thread before its completion.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This function should always return immediately, but in the rare case that Ecore is built with no thread support, <em>func_blocking</em> is be called here, actually blocking the main loop.</dd>
<dd>
Once a thread becomes available, <em>func_blocking</em> is run in it until it finishes, then <em>func_end</em> is called from the thread containing the main loop to inform the user of its completion. While in <em>func_blocking</em>, no functions from the EFL can be used, except for those from Eina that are marked to be thread-safe. Even for the latter, caution needs to be taken if the data is shared across several threads.</dd>
<dd>
<em>func_end</em> is called from the main thread when <em>func_blocking</em> ends, so here it's safe to use anything from the EFL freely.</dd>
<dd>
The thread can also be cancelled before its completion by calling <a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511" title="Cancels a running thread.">ecore_thread_cancel()</a>, either from the main thread or <em>func_blocking</em>. In this case, <em>func_cancel</em> is called, also from the main thread to inform of this happening. If the thread could not be created, this function is called and its <code>thread</code> parameter is <code>NULL</code>. It's also safe to call any EFL function here, as it is running in the main thread.</dd>
<dd>
Inside <em>func_blocking</em>, it's possible to call <a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185" title="Asks for the function in the thread to be called again at a later period.">ecore_thread_reschedule()</a> to tell Ecore that this function should be called again.</dd>
<dd>
Be aware that no assumptions can be made about the order in which the <em>func_end</em> callbacks for each task are called. Once the function is running in a different thread, it's the OS that handles its running schedule, and different functions may take longer to finish than others. Also remember that just starting several tasks together doesn't mean they are going to run at the same time. Ecore schedules them based on the number of threads available for the particular system it's running in, so some of the jobs started may be waiting until another one finishes before it can execute its own <em>func_blocking</em>.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func_blocking</td><td>The function that should run in another thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_end</td><td>The function to call from the main loop when <em>func_blocking</em> completes its task successfully (may be <code>NULL</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_cancel</td><td>The function to call from the main loop if the thread running <em>func_blocking</em> is cancelled or fails to start (may be <code>NULL</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The user context data to pass to all callbacks </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new thread handler, otherwise <code>NULL</code> on failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Ecore__Thread__Group.html#ga4bde6b50e177f26ab5b2688aa99e3878" title="Launches a thread to run a task that can talk back to the main thread.">ecore_thread_feedback_run()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gae9b9b20e1ed53c62c51617b55aed2511" title="Cancels a running thread.">ecore_thread_cancel()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gadf825c1a58f06bba2a304d025bed3185" title="Asks for the function in the thread to be called again at a later period.">ecore_thread_reschedule()</a> </dd>
<dd>
<a class="el" href="group__Ecore__Thread__Group.html#gaaf965a46e0cc12857883806812af7693" title="Sets the maximum number of threads allowed to run simultaneously.">ecore_thread_max_set()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
