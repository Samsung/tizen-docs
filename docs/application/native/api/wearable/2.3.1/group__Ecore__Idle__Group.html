<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Ecore Idle</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Wearable&#160;Native&#160;API&#160;Reference</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Ecore Idle</div>  </div>
<div class="ingroups"><a class="el" href="group__Ecore__Main__Loop__Group.html">Ecore Main Loop</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#gafa631f9b2ed1c20c44e8fc32fcaa2492">Ecore_Idler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga048ed35688c416f1f495912a900e9297">ecore_idler_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an idler handler.  <a href="#ga048ed35688c416f1f495912a900e9297"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#gaf7b5ec4cc0d26179c1b5e3ee907e5d58">ecore_idler_del</a> (<a class="el" href="group__Ecore__Idle__Group.html#gafa631f9b2ed1c20c44e8fc32fcaa2492">Ecore_Idler</a> *idler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an idler callback from the list to be executed.  <a href="#gaf7b5ec4cc0d26179c1b5e3ee907e5d58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#ga3e47441188c0658f929e83696ec1ab78">Ecore_Idle_Enterer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga0805b9840716bd08ae44956dba8de3e6">ecore_idle_enterer_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an idle enterer handler.  <a href="#ga0805b9840716bd08ae44956dba8de3e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#ga3e47441188c0658f929e83696ec1ab78">Ecore_Idle_Enterer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga6aa00afaecb0a5a29add3bb92f534a0d">ecore_idle_enterer_before_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an idle enterer handler at the start of the list so it gets called earlier than others.  <a href="#ga6aa00afaecb0a5a29add3bb92f534a0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga7e1106729c49d0cd714ef58e0343470c">ecore_idle_enterer_del</a> (<a class="el" href="group__Ecore__Idle__Group.html#ga3e47441188c0658f929e83696ec1ab78">Ecore_Idle_Enterer</a> *idle_enterer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an idle enterer callback.  <a href="#ga7e1106729c49d0cd714ef58e0343470c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Ecore__Idle__Group.html#gabc1923e21a85882731a2c3be7ba3cb94">Ecore_Idle_Exiter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga4bbd02660dd2b36a2da262a9bda3dfb4">ecore_idle_exiter_add</a> (<a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a> func, const void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an idle exiter handler.  <a href="#ga4bbd02660dd2b36a2da262a9bda3dfb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga89b7d6e94230fcbc331258f7aedf6010">ecore_idle_exiter_del</a> (<a class="el" href="group__Ecore__Idle__Group.html#gabc1923e21a85882731a2c3be7ba3cb94">Ecore_Idle_Exiter</a> *idle_exiter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an idle exiter handler from the list to be run on exiting idle state.  <a href="#ga89b7d6e94230fcbc331258f7aedf6010"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa631f9b2ed1c20c44e8fc32fcaa2492"></a><!-- doxytag: member="Ecore_Idle_Group::Ecore_Idler" ref="gafa631f9b2ed1c20c44e8fc32fcaa2492" args="" -->
typedef struct _Ecore_Idler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#gafa631f9b2ed1c20c44e8fc32fcaa2492">Ecore_Idler</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for idlers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3e47441188c0658f929e83696ec1ab78"></a><!-- doxytag: member="Ecore_Idle_Group::Ecore_Idle_Enterer" ref="ga3e47441188c0658f929e83696ec1ab78" args="" -->
typedef struct _Ecore_Idle_Enterer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#ga3e47441188c0658f929e83696ec1ab78">Ecore_Idle_Enterer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for idle enterers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc1923e21a85882731a2c3be7ba3cb94"></a><!-- doxytag: member="Ecore_Idle_Group::Ecore_Idle_Exiter" ref="gabc1923e21a85882731a2c3be7ba3cb94" args="" -->
typedef struct _Ecore_Idle_Exiter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Ecore__Idle__Group.html#gabc1923e21a85882731a2c3be7ba3cb94">Ecore_Idle_Exiter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for idle exiters. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2> </h2>
<p>The idler functionality in Ecore allows for callbacks to be called when the program isn't handling <a class="el" href="group__Ecore__Event__Group.html">events</a>, <a class="el" href="group__Ecore__Timer__Group.html">timers</a>, or <a class="el" href="group__Ecore__FD__Handler__Group.html">fd handlers</a>. </p>
<p>There are three types of idlers: Enterers, Idlers(proper), and Exiters. They are called respectively when the program is about to enter an idle state, when the program is in an idle state and when the program has just left an idle state and begins processing <a class="el" href="group__Ecore__Event__Group.html">events</a>, <a class="el" href="group__Ecore__Timer__Group.html">timers</a>, or <a class="el" href="group__Ecore__FD__Handler__Group.html">fd handlers</a>.</p>
<p>Enterer callbacks are good for updating your program's state, if it has a state engine. Once all of the enterer handlers are called, the program enters a "sleeping" state.</p>
<p>Idler callbacks are called when the main loop has called all enterer handlers. They are useful for interfaces that require polling and timers without which they would be too slow to use.</p>
<p>Exiter callbacks are called when the main loop wakes up from an idle state.</p>
<p>If no idler callbacks are specified, then the process literally goes to sleep. Otherwise, the idler callbacks are called continuously while the loop is "idle", using as much CPU as is available to the process.</p>
<p>Idle state doesn't mean that the <b>program</b> is idle, but that the <b>main loop</b> is idle. It doesn't have any timers, events, fd handlers, or anything else to process (which in most <em>event driven</em> programs also means that the <b>program</b> is idle too, but it's not a rule). The program itself may be doing a lot of processing in the idler, or in another thread, for example. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0805b9840716bd08ae44956dba8de3e6"></a><!-- doxytag: member="Ecore.h::ecore_idle_enterer_add" ref="ga0805b9840716bd08ae44956dba8de3e6" args="(Ecore_Task_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#ga3e47441188c0658f929e83696ec1ab78">Ecore_Idle_Enterer</a>* <a class="el" href="group__Ecore__Idle__Group.html#ga0805b9840716bd08ae44956dba8de3e6">ecore_idle_enterer_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an idle enterer handler. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function func will be called every time the main loop is entering idle state, as long as it returns 1 (or ECORE_CALLBACK_RENEW). A return of 0 (or ECORE_CALLBACK_CANCEL) deletes the idle enterer.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to call when entering an idle state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be passed to the <code>func</code> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to the idle enterer callback if successful. Otherwise, NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6aa00afaecb0a5a29add3bb92f534a0d"></a><!-- doxytag: member="Ecore.h::ecore_idle_enterer_before_add" ref="ga6aa00afaecb0a5a29add3bb92f534a0d" args="(Ecore_Task_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#ga3e47441188c0658f929e83696ec1ab78">Ecore_Idle_Enterer</a>* <a class="el" href="group__Ecore__Idle__Group.html#ga6aa00afaecb0a5a29add3bb92f534a0d">ecore_idle_enterer_before_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an idle enterer handler at the start of the list so it gets called earlier than others. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function func will be called every time the main loop is entering idle state, as long as it returns 1 (or ECORE_CALLBACK_RENEW). A return of 0 (or ECORE_CALLBACK_CANCEL) deletes the idle enterer.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to call when entering an idle state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be passed to the <code>func</code> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to the idle enterer callback if successful. Otherwise, NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e1106729c49d0cd714ef58e0343470c"></a><!-- doxytag: member="Ecore.h::ecore_idle_enterer_del" ref="ga7e1106729c49d0cd714ef58e0343470c" args="(Ecore_Idle_Enterer *idle_enterer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Idle__Group.html#ga7e1106729c49d0cd714ef58e0343470c">ecore_idle_enterer_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Idle__Group.html#ga3e47441188c0658f929e83696ec1ab78">Ecore_Idle_Enterer</a> *&#160;</td>
          <td class="paramname"><em>idle_enterer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete an idle enterer callback. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idle_enterer</td><td>The idle enterer to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data pointer passed to the idler enterer callback on success. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bbd02660dd2b36a2da262a9bda3dfb4"></a><!-- doxytag: member="Ecore.h::ecore_idle_exiter_add" ref="ga4bbd02660dd2b36a2da262a9bda3dfb4" args="(Ecore_Task_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#gabc1923e21a85882731a2c3be7ba3cb94">Ecore_Idle_Exiter</a>* <a class="el" href="group__Ecore__Idle__Group.html#ga4bbd02660dd2b36a2da262a9bda3dfb4">ecore_idle_exiter_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an idle exiter handler. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function func will be called every time the main loop is exiting idle state, as long as it returns 1 (or ECORE_CALLBACK_RENEW). A return of 0 (or ECORE_CALLBACK_CANCEL) deletes the idle exiter.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to call when exiting an idle state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be passed to the <code>func</code> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A handle to the idle exiter callback on success. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga89b7d6e94230fcbc331258f7aedf6010"></a><!-- doxytag: member="Ecore.h::ecore_idle_exiter_del" ref="ga89b7d6e94230fcbc331258f7aedf6010" args="(Ecore_Idle_Exiter *idle_exiter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Idle__Group.html#ga89b7d6e94230fcbc331258f7aedf6010">ecore_idle_exiter_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Idle__Group.html#gabc1923e21a85882731a2c3be7ba3cb94">Ecore_Idle_Exiter</a> *&#160;</td>
          <td class="paramname"><em>idle_exiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete an idle exiter handler from the list to be run on exiting idle state. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idle_exiter</td><td>The idle exiter to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data pointer that was being being passed to the handler if successful. NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga048ed35688c416f1f495912a900e9297"></a><!-- doxytag: member="Ecore.h::ecore_idler_add" ref="ga048ed35688c416f1f495912a900e9297" args="(Ecore_Task_Cb func, const void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Ecore__Idle__Group.html#gafa631f9b2ed1c20c44e8fc32fcaa2492">Ecore_Idler</a>* <a class="el" href="group__Ecore__Idle__Group.html#ga048ed35688c416f1f495912a900e9297">ecore_idler_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Main__Loop__Group.html#ga8a36ef1ac24bfa317a7826617264e530">Ecore_Task_Cb</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an idler handler. </p>
<p>This adds an idler handle to the event loop, returning a handle on success and <code>NULL</code> otherwise. The function <em>func</em> is called repeatedly while no other events are ready to be processed, as long as it returns <code>1</code> (or <code>ECORE_CALLBACK_RENEW</code>). A return of <code>0</code> (or <code>ECORE_CALLBACK_CANCEL</code>) deletes the idler.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Idlers are useful for progressively processing data without blocking.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to call when idling </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be passed to this <em>func</em> call </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A idler handle if successfully added, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7b5ec4cc0d26179c1b5e3ee907e5d58"></a><!-- doxytag: member="Ecore.h::ecore_idler_del" ref="gaf7b5ec4cc0d26179c1b5e3ee907e5d58" args="(Ecore_Idler *idler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="group__Ecore__Idle__Group.html#gaf7b5ec4cc0d26179c1b5e3ee907e5d58">ecore_idler_del</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Ecore__Idle__Group.html#gafa631f9b2ed1c20c44e8fc32fcaa2492">Ecore_Idler</a> *&#160;</td>
          <td class="paramname"><em>idler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes an idler callback from the list to be executed. </p>
<dl class="user"><dt><b>Since :</b></dt><dd>2.3.1</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idler</td><td>The handle of the idler callback to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The data pointer passed to the idler callback on success, otherwise <code>NULL</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
