<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: Top Level Functions</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">4.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__Evas__Main__Group.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Top Level Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__Evas.html">Evas</a></div></div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2> </h2>
<p>Functions that affect Evas as a whole. </p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#ga65b3f060b6dd9e488afd0b8cbe101869">evas_init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09">evas_shutdown</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Evas_Alloc_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#gacfae4f589c777003f58d51e502c52835">evas_alloc_error</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#ga301c7d776c3d00085659fcf00c52b22d">evas_async_events_fd_get</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get evas' internal asynchronous events read file descriptor.  <a href="#ga301c7d776c3d00085659fcf00c52b22d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#ga80fa27be7ba9fe5180ebbd1ec551e4a3">evas_async_events_process</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger the processing of all events waiting on the file descriptor returned by <a class="el" href="group__Evas__Main__Group.html#ga301c7d776c3d00085659fcf00c52b22d" title="Get evas&#39; internal asynchronous events read file descriptor.">evas_async_events_fd_get()</a>.  <a href="#ga80fa27be7ba9fe5180ebbd1ec551e4a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Evas__Main__Group.html#gab4dda3c2ef0c587a849935bafea9f66a">evas_async_events_put</a> (const void *target, <a class="el" href="group__Evas.html#gad64cde0da38a60e7cb7905b3ab216968">Evas_Callback_Type</a> type, void *event_info, Evas_Async_Events_Put_Cb func)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gacfae4f589c777003f58d51e502c52835"></a><!-- doxytag: member="Evas_Common.h::evas_alloc_error" ref="gacfae4f589c777003f58d51e502c52835" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Evas_Alloc_Error <a class="el" href="group__Evas__Main__Group.html#gacfae4f589c777003f58d51e502c52835">evas_alloc_error</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return if any allocation errors have occurred during the prior function </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The allocation error flag</dd></dl>
<p>This function will return if any memory allocation errors occurred during, and what kind they were. The return value will be one of EVAS_ALLOC_ERROR_NONE, EVAS_ALLOC_ERROR_FATAL or EVAS_ALLOC_ERROR_RECOVERED with each meaning something different.</p>
<p>EVAS_ALLOC_ERROR_NONE means that no errors occurred at all and the function worked as expected.</p>
<p>EVAS_ALLOC_ERROR_FATAL means the function was completely unable to perform its job and will have exited as cleanly as possible. The programmer should consider this as a sign of very low memory and should try and safely recover from the prior functions failure (or try free up memory elsewhere and try again after more memory is freed).</p>
<p>EVAS_ALLOC_ERROR_RECOVERED means that an allocation error occurred, but was recovered from by evas finding memory of its own it has allocated and freeing what it sees as not really usefully allocated memory. What is freed may vary. Evas may reduce the resolution of images, free cached images or fonts, throw out pre-rendered data, reduce the complexity of change lists etc. Evas and the program will function as per normal after this, but this is a sign of low memory, and it is suggested that the program try and identify memory it doesn't need, and free it.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">extern</span> <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *object;
 <span class="keywordtype">void</span> callback (<span class="keywordtype">void</span> *data, <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *e, <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *obj, <span class="keywordtype">void</span> *event_info);

 <a class="code" href="group__Evas__Object__Group__Events.html#ga23be30ac5cdfb780f1ff82e9108ec26b">evas_object_event_callback_add</a>(<span class="keywordtype">object</span>, <a class="code" href="group__Evas.html#ggad64cde0da38a60e7cb7905b3ab216968a9fa52651ccf7e47cd3b7785fc4cf393f">EVAS_CALLBACK_MOUSE_DOWN</a>, callback, NULL);
 <span class="keywordflow">if</span> (<a class="code" href="group__Evas__Main__Group.html#gacfae4f589c777003f58d51e502c52835">evas_alloc_error</a>() == EVAS_ALLOC_ERROR_FATAL)
   {
     fprintf(stderr, <span class="stringliteral">&quot;ERROR: Completely unable to attach callback. Must\n&quot;</span>);
     fprintf(stderr, <span class="stringliteral">&quot;       destroy object now as it cannot be used.\n&quot;</span>);
     <a class="code" href="group__Evas__Font__Group.html#ga7e7a625dab7a3890532aa13b43117076">evas_object_del</a>(<span class="keywordtype">object</span>);
     <span class="keywordtype">object</span> = NULL;
     fprintf(stderr, <span class="stringliteral">&quot;WARNING: Memory is really low. Cleaning out RAM.\n&quot;</span>);
     my_memory_cleanup();
   }
 <span class="keywordflow">if</span> (<a class="code" href="group__Evas__Main__Group.html#gacfae4f589c777003f58d51e502c52835">evas_alloc_error</a>() == EVAS_ALLOC_ERROR_RECOVERED)
   {
     fprintf(stderr, <span class="stringliteral">&quot;WARNING: Memory is really low. Cleaning out RAM.\n&quot;</span>);
     my_memory_cleanup();
   }
</pre></div><dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="evas-events_8c-example.html#a33">evas-events.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga301c7d776c3d00085659fcf00c52b22d"></a><!-- doxytag: member="Evas_Common.h::evas_async_events_fd_get" ref="ga301c7d776c3d00085659fcf00c52b22d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Main__Group.html#ga301c7d776c3d00085659fcf00c52b22d">evas_async_events_fd_get</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get evas' internal asynchronous events read file descriptor. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The canvas' asynchronous events read file descriptor.</dd></dl>
<p>Evas' asynchronous events are meant to be dealt with internally, i. e., when building stuff to be glued together into the EFL infrastructure -- a module, for example. The context which demands its use is when calculations need to be done out of the main thread, asynchronously, and some action must be performed after that.</p>
<p>An example of actual use of this API is for image asynchronous preload inside evas. If the canvas was instantiated through ecore-evas usage, ecore itself will take care of calling those events' processing.</p>
<p>This function returns the read file descriptor where to get the asynchronous events of the canvas. Naturally, other mainloops, apart from ecore, may make use of it.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga80fa27be7ba9fe5180ebbd1ec551e4a3"></a><!-- doxytag: member="Evas_Common.h::evas_async_events_process" ref="ga80fa27be7ba9fe5180ebbd1ec551e4a3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Main__Group.html#ga80fa27be7ba9fe5180ebbd1ec551e4a3">evas_async_events_process</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trigger the processing of all events waiting on the file descriptor returned by <a class="el" href="group__Evas__Main__Group.html#ga301c7d776c3d00085659fcf00c52b22d" title="Get evas&#39; internal asynchronous events read file descriptor.">evas_async_events_fd_get()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of events processed.</dd></dl>
<p>All asynchronous events queued up by <a class="el" href="group__Evas__Main__Group.html#gab4dda3c2ef0c587a849935bafea9f66a">evas_async_events_put()</a> are processed here. More precisely, the callback functions, informed together with other event parameters, when queued, get called (with those parameters), in that order.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="gab4dda3c2ef0c587a849935bafea9f66a"></a><!-- doxytag: member="Evas_Common.h::evas_async_events_put" ref="gab4dda3c2ef0c587a849935bafea9f66a" args="(const void *target, Evas_Callback_Type type, void *event_info, Evas_Async_Events_Put_Cb func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a> <a class="el" href="group__Evas__Main__Group.html#gab4dda3c2ef0c587a849935bafea9f66a">evas_async_events_put</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Evas.html#gad64cde0da38a60e7cb7905b3ab216968">Evas_Callback_Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>event_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Evas_Async_Events_Put_Cb&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert asynchronous events on the canvas.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be affected by the events. </td></tr>
    <tr><td class="paramname">type</td><td>The type of callback function. </td></tr>
    <tr><td class="paramname">event_info</td><td>Information about the event. </td></tr>
    <tr><td class="paramname">func</td><td>The callback function pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EINA_FALSE if an error occurred, EINA_TRUE otherwise.</dd></dl>
<p>This is the way, for a routine running outside evas' main thread, to report an asynchronous event. A callback function is informed, whose call is to happen after <a class="el" href="group__Evas__Main__Group.html#ga80fa27be7ba9fe5180ebbd1ec551e4a3" title="Trigger the processing of all events waiting on the file descriptor returned by evas_async_events_fd_...">evas_async_events_process()</a> is called.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ga65b3f060b6dd9e488afd0b8cbe101869"></a><!-- doxytag: member="Evas_Common.h::evas_init" ref="ga65b3f060b6dd9e488afd0b8cbe101869" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Main__Group.html#ga65b3f060b6dd9e488afd0b8cbe101869">evas_init</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize Evas</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The init counter value.</dd></dl>
<p>This function initializes Evas and increments a counter of the number of calls to it. It returns the new counter's value.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09">evas_shutdown()</a>.</dd></dl>
<p>Most EFL users wouldn't be using this function directly, because they wouldn't access Evas directly by themselves. Instead, they would be using higher level helpers, like <code><a class="el" href="group__Ecore__Evas__Group.html#gad36db3002bbf891d28af0d6b22dda1b5" title="Inits the Ecore_Evas system.">ecore_evas_init()</a></code>. See <a class="el" href="group__Ecore.html">Ecore</a>.</p>
<p>You should be using this if your use is something like the following. The buffer engine is just one of the many ones Evas provides.</p>
 <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   <a class="code" href="group__Evas__Object__Group.html#ga9e19e6dd1f517a0ba437c0114d3e7c97">Evas_Object</a> *bg, *r1, *r2, *r3;

   <a class="code" href="group__Evas__Main__Group.html#ga65b3f060b6dd9e488afd0b8cbe101869">evas_init</a>();

   <span class="comment">// create your canvas</span>
   <span class="comment">// NOTE: consider using ecore_evas_buffer_new() instead!</span>
   canvas = create_canvas(WIDTH, HEIGHT);
   <span class="keywordflow">if</span> (!canvas)
     <span class="keywordflow">return</span> -1;
</pre></div> And being the canvas creation something like: <div class="fragment"><pre class="fragment"><span class="keyword">static</span> <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *create_canvas(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
{
   <a class="code" href="group__Evas__Canvas.html#ga5ff87cc4ce6bc43e3b640a6d37f73043">Evas</a> *canvas;
   Evas_Engine_Info_Buffer *einfo;
   <span class="keywordtype">int</span> method;
   <span class="keywordtype">void</span> *pixels;

   method = <a class="code" href="group__Evas__Output__Method.html#ga9f9871fdcc40ce1062d6565308020eb8">evas_render_method_lookup</a>(<span class="stringliteral">&quot;buffer&quot;</span>);
   <span class="keywordflow">if</span> (method &lt;= 0)
     {
    fputs(<span class="stringliteral">&quot;ERROR: evas was not compiled with &#39;buffer&#39; engine!\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   canvas = <a class="code" href="group__Evas__Canvas.html#ga67e8eb17d2a676bfdfb8794fc5f72bc0">evas_new</a>();
   <span class="keywordflow">if</span> (!canvas)
     {
    fputs(<span class="stringliteral">&quot;ERROR: could not instantiate new evas canvas.\n&quot;</span>, stderr);
    <span class="keywordflow">return</span> NULL;
     }

   <a class="code" href="group__Evas__Canvas.html#ga17f2ac9f3bef135cd825774c33762ef2" title="Sets the output engine for the given evas.">evas_output_method_set</a>(canvas, method);
   <a class="code" href="group__Evas__Canvas.html#ga681f2af7d325735af201e18f56f6ef61" title="Sets the output size of the render engine of the given evas.">evas_output_size_set</a>(canvas, width, height);
   <a class="code" href="group__Evas__Canvas.html#ga0a14db31aa30b701688caf67a4649239" title="Sets the output viewport of the given evas in evas units.">evas_output_viewport_set</a>(canvas, 0, 0, width, height);
</pre></div></p>
<p>Note that this is code creating an Evas canvas with no usage of Ecore helpers at all -- no linkage with Ecore on this scenario, thus. Again, this wouldn't be on Evas common usage for most developers. See the full <a class="el" href="Example_Evas_Buffer_Simple.html">example</a>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="eina_tiler_01_8c-example.html#a23">eina_tiler_01.c</a>, <a class="el" href="evas-buffer-simple_8c-example.html#a0">evas-buffer-simple.c</a>, and <a class="el" href="evas-init-shutdown_8c-example.html#a1">evas-init-shutdown.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga95a8864f81d944a92bb012b77ffd1b09"></a><!-- doxytag: member="Evas_Common.h::evas_shutdown" ref="ga95a8864f81d944a92bb012b77ffd1b09" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09">evas_shutdown</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shutdown Evas</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Evas' init counter value.</dd></dl>
<p>This function finalizes Evas, decrementing the counter of the number of calls to the function <a class="el" href="group__Evas__Main__Group.html#ga65b3f060b6dd9e488afd0b8cbe101869">evas_init()</a>. This new value for the counter is returned.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Evas__Main__Group.html#ga65b3f060b6dd9e488afd0b8cbe101869">evas_init()</a>.</dd></dl>
<p>If you were the sole user of Evas, by means of <a class="el" href="group__Evas__Main__Group.html#ga65b3f060b6dd9e488afd0b8cbe101869">evas_init()</a>, you can check if it's being properly shut down by expecting a return value of 0.</p>
<p>Example code follows.  <div class="fragment"><pre class="fragment">   <span class="comment">// NOTE: use ecore_evas_buffer_new() and here ecore_evas_free()</span>
   destroy_canvas(canvas);

   <a class="code" href="group__Evas__Main__Group.html#ga95a8864f81d944a92bb012b77ffd1b09">evas_shutdown</a>();
</pre></div> Where that function would contain: <div class="fragment"><pre class="fragment">    <a class="code" href="group__Evas__Canvas.html#gaa0d5d3f1a1e1ffa3b14b09bb374215b4">evas_free</a>(canvas);
</pre></div></p>
<p>Most users would be using <a class="el" href="group__Ecore__Evas__Group.html#gab1a47c09b475148c037c0a3d68644fa4" title="Shuts down the Ecore_Evas system.">ecore_evas_shutdown()</a> instead, like told in <a class="el" href="group__Evas__Main__Group.html#ga65b3f060b6dd9e488afd0b8cbe101869">evas_init()</a>. See the full <a class="el" href="Example_Evas_Buffer_Simple.html">example</a>.</p>
<dl class="user"><dt><b>Since :</b></dt><dd>3.0 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="eina_tiler_01_8c-example.html#a34">eina_tiler_01.c</a>, <a class="el" href="evas-buffer-simple_8c-example.html#a6">evas-buffer-simple.c</a>, and <a class="el" href="evas-init-shutdown_8c-example.html#a5">evas-init-shutdown.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
