<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tizen Native API: ecore poller - Repetitive polling tasks</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen_html_stylesheet.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Tizen Native API"/>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tizen Native API
   &#160;<span id="projectnumber">4.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>The&#160;Basics&#160;of&#160;Tizen&#160;Native&#160;API&#160;Reference</span></a></li>
      <li><a href="modules.html"><span>Native&#160;API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('ecore_poller_example_c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">ecore poller - Repetitive polling tasks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This example shows how to setup, and explains how an <a class="el" href="group__Ecore__Poller__Group.html#ga437f925a7a71ee670bbf8cdd4a258f53">Ecore_Poller</a> is called. You can <a class="el" href="ecore_poller_example_8c-example.html">see the full source code here</a>.</p>
<p>In this example we store the initial time of the program just to use as comparison to the time when the poller callbacks are called. It will be stored in <code>_initial_time</code> :</p>
<p><div class="fragment"><pre class="fragment"><span class="comment">//Compile with:</span>
<span class="comment">// gcc -o ecore_poller_example ecore_poller_example.c `pkg-config --libs --cflags ecore eo`</span>

<span class="preprocessor">#include &lt;Ecore.h&gt;</span>
<span class="comment">//#include &lt;Ecore_Eo.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="keyword">static</span> <span class="keywordtype">double</span> _initial_time = 0;
</pre></div></p>
<p>Then next step is to define the poller callback. This callback assumes that a <code>data</code> pointer is passed to it on creation, and is a string just used to identify the poller. The callback prints this string and the time since the program started, and returns <a class="el" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a> to keep being called.</p>
<p><div class="fragment"><pre class="fragment">
<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_poller_print_cb(<span class="keywordtype">void</span> *data)
{
   <span class="keywordtype">char</span> *str = data;
   printf(<span class="stringliteral">&quot;Ecore Poller &#39;%s&#39; callback called after %0.3f seconds.\n&quot;</span>,
          str, <a class="code" href="group__Ecore__Time__Group.html#ga98f2439b5d3e7114a75bfe2f0c22c4e9">ecore_time_get</a>() - _initial_time);

   <span class="keywordflow">return</span> <a class="code" href="group__Ecore__Main__Loop__Group.html#ga1ee9db07f9a46a8b20fb83e1c6dbed09">ECORE_CALLBACK_RENEW</a>;
}
</pre></div></p>
<p>Now in the main function we initialize Ecore, and save the initial time of the program, so we can compare it later with the time that the pollers are being called:</p>
<p><div class="fragment"><pre class="fragment">
<span class="keyword">static</span> <a class="code" href="group__Eina__Types__Group.html#ga3fe0caf72e93b1bab1ca8ee3ccf3f226">Eina_Bool</a>
_poller_quit_cb(<span class="keywordtype">void</span> *data EINA_UNUSED)
{

   <a class="code" href="group__Ecore__Main__Loop__Group.html#ga95cf8e97dff0716433c2c5474d606a98">ecore_main_loop_quit</a>();
   <span class="keywordflow">return</span> <a class="code" href="group__Eina__Types__Group.html#ga05c12dacc8b4058994df842b41be85fc">EINA_TRUE</a>;
}

<span class="keywordtype">int</span>
main(<span class="keywordtype">void</span>)
{
   <span class="keywordtype">double</span> interval = 0.3; <span class="comment">// tick each 0.3 seconds</span>
   <a class="code" href="group__Ecore__Poller__Group.html#ga437f925a7a71ee670bbf8cdd4a258f53">Ecore_Poller</a> *poller1, *poller2, *poller3;
   <span class="keywordtype">char</span> *str1 = <span class="stringliteral">&quot;poller1&quot;</span>;
   <span class="keywordtype">char</span> *str2 = <span class="stringliteral">&quot;poller2&quot;</span>;
   <span class="keywordtype">char</span> *str3 = <span class="stringliteral">&quot;poller3&quot;</span>;

   <span class="keywordflow">if</span> (!<a class="code" href="group__Ecore__Init__Group.html#ga77757609684a2c922dc5ec398274751b">ecore_init</a>())
     {
        printf(<span class="stringliteral">&quot;ERROR: Cannot init Ecore!\n&quot;</span>);
        <span class="keywordflow">return</span> -1;
     }

   _initial_time = <a class="code" href="group__Ecore__Time__Group.html#ga98f2439b5d3e7114a75bfe2f0c22c4e9">ecore_time_get</a>();
</pre></div></p>
<p>Then we change the poll interval to 0.3 seconds (the default is 0.125 seconds) just to show the API usage.</p>
<p>Finally, we create two pollers, one that will be called every 4 ticks, and another one that will be called every 8 ticks. This means the the first poller interval will be around 1.2 seconds, and the second one will be around 2.4 seconds. But the most important point is: since the second poller interval is a multiple of the first one, they will be always synchronized. Ecore calls pollers that are in the "same tick" together. It doesn't go back to the main loop and check if there's another poller to execute at this time, but instead it calls all the pollers registered to this "tick" at the same time. See the description of <a class="el" href="group__Ecore__Poller__Group.html#gadd8ee7135864da4313bc88faa0a2d7c9" title="Creates a poller to call the given function at a particular tick interval.">ecore_poller_add()</a> for more details. This is easy to see in the time printed by both of them.</p>
<p>If instead of two synchronized pollers, we were using two different timers, one with interval of 1.2 seconds and another one with an interval of 2.4 seconds, there would be no guarantee that they would be totally in sync. Some delay in the execution of another task, or even in the task called in the callback, could make them get out of sync, forcing Ecore's main loop to wake up more than necessary.</p>
<p>Well, this is the code that create these two pollers and set the poll interval, then starts the main loop:</p>
<p><div class="fragment"><pre class="fragment">
   <a class="code" href="group__Ecore__Poller__Group.html#ga466dff0c7fb7eb0f5b4e5a3825fa10ac" title="Sets the time(in seconds) between ticks for the given poller type.">ecore_poller_poll_interval_set</a>(<a class="code" href="group__Ecore__Poller__Group.html#gga50dcd2652ba68fe4aac51c70c3fa1e2ca022dfec751388e380cf01621bd0f797f">ECORE_POLLER_CORE</a>, interval);

   poller1 = <a class="code" href="group__Ecore__Poller__Group.html#gadd8ee7135864da4313bc88faa0a2d7c9" title="Creates a poller to call the given function at a particular tick interval.">ecore_poller_add</a>(<a class="code" href="group__Ecore__Poller__Group.html#gga50dcd2652ba68fe4aac51c70c3fa1e2ca022dfec751388e380cf01621bd0f797f">ECORE_POLLER_CORE</a>, 4, _poller_print_cb, str1);
   poller2 = <a class="code" href="group__Ecore__Poller__Group.html#gadd8ee7135864da4313bc88faa0a2d7c9" title="Creates a poller to call the given function at a particular tick interval.">ecore_poller_add</a>(<a class="code" href="group__Ecore__Poller__Group.html#gga50dcd2652ba68fe4aac51c70c3fa1e2ca022dfec751388e380cf01621bd0f797f">ECORE_POLLER_CORE</a>, 8, _poller_print_cb, str2);
   poller3 = <a class="code" href="group__Ecore__Poller__Group.html#gadd8ee7135864da4313bc88faa0a2d7c9" title="Creates a poller to call the given function at a particular tick interval.">ecore_poller_add</a>(<a class="code" href="group__Ecore__Poller__Group.html#gga50dcd2652ba68fe4aac51c70c3fa1e2ca022dfec751388e380cf01621bd0f797f">ECORE_POLLER_CORE</a>, 30, _poller_quit_cb, str3);

<span class="comment">//   poller1 = eo_add(ECORE_POLLER_CLASS, NULL,</span>
<span class="comment">//         ecore_poller_constructor(ECORE_POLLER_CORE, 4, _poller_print_cb, str1));</span>
<span class="comment">//   poller2 = eo_add(ECORE_POLLER_CLASS, NULL,</span>
<span class="comment">//         ecore_poller_constructor(ECORE_POLLER_CORE, 8, _poller_print_cb, str2));</span>
<span class="comment">//   poller3 = eo_add(ECORE_POLLER_CLASS, NULL,</span>
<span class="comment">//         ecore_poller_constructor(ECORE_POLLER_CORE, 20, _poller_quit_cb, str3));</span>


   <a class="code" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a>();
</pre></div></p>
<p>If you hit CTRL-C during the execution of the program, the main loop will quit, since there are some signal handlers already set by default to do this. So after the main loop begin call, we change the second poller's interval to 16 ticks, so it will happen each 4.8 seconds (or each 4 times that the first poller is called).</p>
<p>This means: the program is started, the first poller is called each 4 ticks and the second is called each 8 ticks. After CTRL-C is used, the second poller will be called each 16 ticks.</p>
<p><div class="fragment"><pre class="fragment">
   printf(<span class="stringliteral">&quot;changing poller2 interval to 16\n&quot;</span>);

   ecore_poller_poller_interval_set(poller2, 16);
<span class="comment">//   eo_do(poller2, ecore_poller_interval_set(16, NULL));</span>
   <a class="code" href="group__Ecore__Main__Loop__Group.html#gaf103b9f668bb3e4fed12e52c6180132d">ecore_main_loop_begin</a>();

<span class="comment">//   eo_unref(poller1);</span>
<span class="comment">//   eo_unref(poller2);</span>
<span class="comment">//   eo_unref(poller3);</span>
   <a class="code" href="group__Ecore__Poller__Group.html#ga52e6245cfbceaed9b721a1addd29d311" title="Deletes the specified poller from the timer list.">ecore_poller_del</a>(poller1);
   <a class="code" href="group__Ecore__Poller__Group.html#ga52e6245cfbceaed9b721a1addd29d311" title="Deletes the specified poller from the timer list.">ecore_poller_del</a>(poller2);
   <a class="code" href="group__Ecore__Poller__Group.html#ga52e6245cfbceaed9b721a1addd29d311" title="Deletes the specified poller from the timer list.">ecore_poller_del</a>(poller3);

   <a class="code" href="group__Ecore__Init__Group.html#ga768298b932f18d7e7593a447493e5cde">ecore_shutdown</a>();
}
</pre></div></p>
<p>The rest of the program is just deleting the pollers and shutting down the library. </p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr size="1"/>
<center>
<small>Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a>
and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br/>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.&nbsp;</small>
</center>
</body>
</html>
